
<!-- saved from url=(0259)https://483337774-atari-embeds.googleusercontent.com/embeds/16cb204cf3a9d4d223a0a3fd8b0eec5d/inner-frame-minified.html?jsh=m%3B%2F_%2Fscs%2Fabc-static%2F_%2Fjs%2Fk%3Dgapi.lb.en.AMZ27oQJoUI.O%2Fd%3D1%2Frs%3DAHpOoo9dsXwz2g0gTMdQFEKa7ZoVvtQf4g%2Fm%3D__features__ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!--<base target="_blank">--><base href="." target="_blank">



    
    <title>Candy Crush</title>
    
    <meta name="format-detection" content="telephone=no">
    <meta name="HandheldFriendly" content="true">
    <meta name="robots" content="noindex,nofollow">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Phaser App">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimum-scale=1.0, maximum-scale=1.01">
    <meta name="game-slug" content="Mayas-Match">
    <meta name="splashscreen-game-url" content="https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/img/teaser.jpg">
    <meta name="supports-ad-play-button" content="true">
    <style>
        body {
    margin: 0px 0px 1px 0px;
    /* the extra 1px allows the iOS inner/outer check to work */
    overflow: hidden;
}

@font-face {
    font-family: 'ComicSansBold';
    src: url('https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/fonts/ComicSansBold.woff2') format('woff2'), url('https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/fonts/ComicSansBold.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}

#gameFontPreload {
    position: absolute;
    left: -1000px;
    top: -1000px;
}

#orientation {
    margin: 0 auto;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url(https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/img/orientation.jpg);
    background-repeat: no-repeat;
    background-position: center;
    background-color: rgb(0, 0, 0);
    z-index: 999;
    display: none;
}
    </style>
    <script>/* Phaser v2.10.0 - http://phaser.io - @photonstorm - (c) 2016 Photon Storm Ltd. */

        (function() {
            function t(t, e, i, n) {
                var r = t.createTexture();
                return t.bindTexture(t.TEXTURE_2D, r), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n === s.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n === s.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null), r
            }
        
            function e(e, i, s, r, o) {
                var a = e.createFramebuffer(),
                    h = e.createRenderbuffer(),
                    u = null,
                    l = 0;
                return e.activeTexture(e.TEXTURE0 + o), e.bindFramebuffer(e.FRAMEBUFFER, a), e.bindRenderbuffer(e.RENDERBUFFER, h), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, this.renderBuffer), u = t(e, i, s, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, u, 0), (l = e.checkFramebufferStatus(e.FRAMEBUFFER)) !== e.FRAMEBUFFER_COMPLETE && console.error("Incomplete GL framebuffer. ", n[l]), a.width = i, a.height = s, a.targetTexture = u, a.renderBuffer = h, a
            }
            var i = this,
                s = s || {};
            s.DisplayObject = function() {
                this.position = new s.Point(0, 0), this.scale = new s.Point(1, 1), this.pivot = new s.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new Phaser.Matrix, this.worldPosition = new s.Point(0, 0), this.worldScale = new s.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new s.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
            }, s.DisplayObject.prototype = {
                constructor: s.DisplayObject,
                destroy: function() {
                    if (this.children) {
                        for (var t = this.children.length; t--;) this.children[t].destroy();
                        this.children = []
                    }
                    this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
                },
                updateTransform: function(t) {
                    if (!t && !this.parent && !this.game) return this;
                    var e = this.parent;
                    t ? e = t : this.parent || (e = this.game.world);
                    var i, s, n, r, o, a, h = e.worldTransform,
                        u = this.worldTransform;
                    this.rotation % Phaser.Math.PI2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), i = this._cr * this.scale.x, s = this._sr * this.scale.x, n = -this._sr * this.scale.y, r = this._cr * this.scale.y, o = this.position.x, a = this.position.y, (this.pivot.x || this.pivot.y) && (o -= this.pivot.x * i + this.pivot.y * n, a -= this.pivot.x * s + this.pivot.y * r), u.a = i * h.a + s * h.c, u.b = i * h.b + s * h.d, u.c = n * h.a + r * h.c, u.d = n * h.b + r * h.d, u.tx = o * h.a + a * h.c + h.tx, u.ty = o * h.b + a * h.d + h.ty) : (i = this.scale.x, s = 0, n = 0, r = this.scale.y, o = this.position.x - this.pivot.x * i, a = this.position.y - this.pivot.y * r, u.a = i * h.a, u.b = i * h.b, u.c = r * h.c, u.d = r * h.d, u.tx = o * h.a + a * h.c + h.tx, u.ty = o * h.b + a * h.d + h.ty), i = u.a, s = u.b, n = u.c;
                    var l = i * (r = u.d) - s * n;
                    if (i || s) {
                        var c = Math.sqrt(i * i + s * s);
                        this.worldRotation = s > 0 ? Math.acos(i / c) : -Math.acos(i / c), this.worldScale.x = c, this.worldScale.y = l / c
                    } else if (n || r) {
                        var d = Math.sqrt(n * n + r * r);
                        this.worldRotation = Phaser.Math.HALF_PI - (r > 0 ? Math.acos(-n / d) : -Math.acos(n / d)), this.worldScale.x = l / d, this.worldScale.y = d
                    } else this.worldScale.x = 0, this.worldScale.y = 0;
                    return this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.x = u.tx, this.worldPosition.y = u.ty, this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, u, h), this
                },
                preUpdate: function() {},
                generateTexture: function(t, e, i) {
                    var n = this.getLocalBounds(),
                        r = new Phaser.RenderTexture(this.game, 0 | n.width, 0 | n.height, i, e, t);
                    return s.DisplayObject._tempMatrix.tx = -n.x, s.DisplayObject._tempMatrix.ty = -n.y, r.render(this, s.DisplayObject._tempMatrix), r
                },
                updateCache: function() {
                    return this._generateCachedSprite(), this
                },
                toGlobal: function(t) {
                    return this.updateTransform(), this.worldTransform.apply(t)
                },
                toLocal: function(t, e) {
                    return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
                },
                _renderCachedSprite: function(t) {
                    this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? s.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : s.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
                },
                _generateCachedSprite: function() {
                    this._cacheAsBitmap = !1;
                    var t = this.getLocalBounds();
                    if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
                    else {
                        var e = 0;
                        this.texture && this.texture.baseTexture && s._enableMultiTextureToggle && (e = this.texture.baseTexture.textureIndex);
                        var i = new Phaser.RenderTexture(this.game, t.width, t.height, void 0, void 0, void 0, void 0, e);
                        this._cachedSprite = new s.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform
                    }
                    var n = this._filters;
                    this._filters = null, this._cachedSprite.filters = n, s.DisplayObject._tempMatrix.tx = -t.x, s.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, s.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = n, this._cacheAsBitmap = !0
                },
                _destroyCachedSprite: function() {
                    this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
                }
            }, s.DisplayObject.prototype.displayObjectUpdateTransform = s.DisplayObject.prototype.updateTransform, Object.defineProperties(s.DisplayObject.prototype, {
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(t) {
                        this.position.x = t
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(t) {
                        this.position.y = t
                    }
                },
                worldVisible: {
                    get: function() {
                        if (this.visible) {
                            var t = this.parent;
                            if (!t) return this.visible;
                            do {
                                if (!t.visible) return !1;
                                t = t.parent
                            } while (t);
                            return !0
                        }
                        return !1
                    }
                },
                mask: {
                    get: function() {
                        return this._mask
                    },
                    set: function(t) {
                        this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                    }
                },
                filters: {
                    get: function() {
                        return this._filters
                    },
                    set: function(t) {
                        if (Array.isArray(t)) {
                            for (var e = [], i = 0; i < t.length; i++)
                                for (var n = t[i].passes, r = 0; r < n.length; r++) e.push(n[r]);
                            this._filterBlock = {
                                target: this,
                                filterPasses: e
                            }
                        }
                        this._filters = t, this.blendMode && this.blendMode === s.blendModes.MULTIPLY && (this.blendMode = s.blendModes.NORMAL)
                    }
                },
                cacheAsBitmap: {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                    }
                }
            }), s.DisplayObjectContainer = function() {
                s.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
            }, s.DisplayObjectContainer.prototype = Object.create(s.DisplayObject.prototype), s.DisplayObjectContainer.prototype.constructor = s.DisplayObjectContainer, s.DisplayObjectContainer.prototype.addChild = function(t) {
                return this.addChildAt(t, this.children.length)
            }, s.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
                if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
                throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
            }, s.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
                if (t !== e) {
                    var i = this.getChildIndex(t),
                        s = this.getChildIndex(e);
                    if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                    this.children[i] = e, this.children[s] = t
                }
            }, s.DisplayObjectContainer.prototype.getChildIndex = function(t) {
                var e = this.children.indexOf(t);
                if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
                return e
            }, s.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
                if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
                var i = this.getChildIndex(t);
                this.children.splice(i, 1), this.children.splice(e, 0, t)
            }, s.DisplayObjectContainer.prototype.getChildAt = function(t) {
                if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
                return this.children[t]
            }, s.DisplayObjectContainer.prototype.removeChild = function(t) {
                var e = this.children.indexOf(t);
                if (-1 !== e) return this.removeChildAt(e)
            }, s.DisplayObjectContainer.prototype.removeChildAt = function(t) {
                var e = this.getChildAt(t);
                return e && (e.parent = void 0, this.children.splice(t, 1)), e
            }, s.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
                var i = e - t;
                if (i > 0 && i <= e) {
                    for (var s = this.children.splice(t, i), n = 0; n < s.length; n++) s[n].parent = void 0;
                    return s
                }
                if (0 === i && 0 === this.children.length) return [];
                throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
            }, s.DisplayObjectContainer.prototype.updateTransform = function() {
                if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                    for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
            }, s.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = s.DisplayObjectContainer.prototype.updateTransform, s.DisplayObjectContainer.prototype.getBounds = function(t) {
                var e = t && t instanceof s.DisplayObject,
                    i = !0;
                e ? i = t instanceof s.DisplayObjectContainer && t.contains(this) : t = this;
                var n;
                if (e) {
                    var r = t.worldTransform;
                    for (t.worldTransform = Phaser.identityMatrix, n = 0; n < t.children.length; n++) t.children[n].updateTransform()
                }
                var o, a, h, u = 1 / 0,
                    l = 1 / 0,
                    c = -1 / 0,
                    d = -1 / 0,
                    p = !1;
                for (n = 0; n < this.children.length; n++) this.children[n].visible && (p = !0, u = u < (o = this.children[n].getBounds()).x ? u : o.x, l = l < o.y ? l : o.y, a = o.width + o.x, h = o.height + o.y, c = c > a ? c : a, d = d > h ? d : h);
                var f = this._bounds;
                if (!p) {
                    var g = (f = new s.Rectangle).x,
                        m = f.width + f.x,
                        y = f.y,
                        v = f.height + f.y,
                        x = this.worldTransform,
                        _ = x.a,
                        b = x.b,
                        T = x.c,
                        w = x.d,
                        C = x.tx,
                        S = x.ty,
                        P = _ * m + T * v + C,
                        E = w * v + b * m + S,
                        A = _ * g + T * v + C,
                        M = w * v + b * g + S,
                        R = _ * g + T * y + C,
                        O = w * y + b * g + S,
                        I = _ * m + T * y + C,
                        L = w * y + b * m + S;
                    c = P, d = E, l = E, u = I < (u = R < (u = A < (u = P) ? A : u) ? R : u) ? I : u, l = L < (l = O < (l = M < l ? M : l) ? O : l) ? L : l, c = I > (c = R > (c = A > c ? A : c) ? R : c) ? I : c, d = L > (d = O > (d = M > d ? M : d) ? O : d) ? L : d
                }
                if (f.x = u, f.y = l, f.width = c - u, f.height = d - l, e)
                    for (t.worldTransform = r, n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                if (!i) {
                    var D = t.getBounds();
                    f.x -= D.x, f.y -= D.y
                }
                return f
            }, s.DisplayObjectContainer.prototype.getLocalBounds = function() {
                return this.getBounds(this)
            }, s.DisplayObjectContainer.prototype.contains = function(t) {
                return !!t && (t === this || this.contains(t.parent))
            }, s.DisplayObjectContainer.prototype._renderWebGL = function(t) {
                if (this.visible && !(this.alpha <= 0))
                    if (this._cacheAsBitmap) this._renderCachedSprite(t);
                    else {
                        var e;
                        if (this._mask || this._filters) {
                            for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                            t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                        } else
                            for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
                    }
            }, s.DisplayObjectContainer.prototype._renderCanvas = function(t) {
                if (!1 !== this.visible && 0 !== this.alpha)
                    if (this._cacheAsBitmap) this._renderCachedSprite(t);
                    else {
                        this._mask && t.maskManager.pushMask(this._mask, t);
                        for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
            }, Object.defineProperty(s.DisplayObjectContainer.prototype, "width", {
                get: function() {
                    return this.getLocalBounds().width * this.scale.x
                },
                set: function(t) {
                    var e = this.getLocalBounds().width;
                    this.scale.x = 0 !== e ? t / e : 1, this._width = t
                }
            }), Object.defineProperty(s.DisplayObjectContainer.prototype, "height", {
                get: function() {
                    return this.getLocalBounds().height * this.scale.y
                },
                set: function(t) {
                    var e = this.getLocalBounds().height;
                    this.scale.y = 0 !== e ? t / e : 1, this._height = t
                }
            }), s.Sprite = function(t) {
                s.DisplayObjectContainer.call(this), this.anchor = new s.Point(s.Sprite.defaultAnchor.x, s.Sprite.defaultAnchor.y), this.texture = t || s.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = s.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
            }, s.Sprite.defaultAnchor = {
                x: 0,
                y: 0
            }, s.Sprite.prototype = Object.create(s.DisplayObjectContainer.prototype), s.Sprite.prototype.constructor = s.Sprite, Object.defineProperty(s.Sprite.prototype, "width", {
                get: function() {
                    return this.scale.x * this.texture.frame.width
                },
                set: function(t) {
                    this.scale.x = t / this.texture.frame.width, this._width = t
                }
            }), Object.defineProperty(s.Sprite.prototype, "height", {
                get: function() {
                    return this.scale.y * this.texture.frame.height
                },
                set: function(t) {
                    this.scale.y = t / this.texture.frame.height, this._height = t
                }
            }), s.Sprite.prototype.setTexture = function(t, e) {
                e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
            }, s.Sprite.prototype.onTextureUpdate = function() {
                this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
            }, s.Sprite.prototype.getBounds = function(t) {
                var e = this.texture.frame.width,
                    i = this.texture.frame.height,
                    s = e * (1 - this.anchor.x),
                    n = e * -this.anchor.x,
                    r = i * (1 - this.anchor.y),
                    o = i * -this.anchor.y,
                    a = t || this.worldTransform,
                    h = a.a,
                    u = a.b,
                    l = a.c,
                    c = a.d,
                    d = a.tx,
                    p = a.ty,
                    f = -1 / 0,
                    g = -1 / 0,
                    m = 1 / 0,
                    y = 1 / 0;
                if (0 === u && 0 === l) {
                    if (h < 0) {
                        h *= -1;
                        v = s;
                        s = -n, n = -v
                    }
                    if (c < 0) {
                        c *= -1;
                        var v = r;
                        r = -o, o = -v
                    }
                    m = h * n + d, f = h * s + d, y = c * o + p, g = c * r + p
                } else {
                    var x = h * n + l * o + d,
                        _ = c * o + u * n + p,
                        b = h * s + l * o + d,
                        T = c * o + u * s + p,
                        w = h * s + l * r + d,
                        C = c * r + u * s + p,
                        S = h * n + l * r + d,
                        P = c * r + u * n + p;
                    m = S < (m = w < (m = b < (m = x < m ? x : m) ? b : m) ? w : m) ? S : m, y = P < (y = C < (y = T < (y = _ < y ? _ : y) ? T : y) ? C : y) ? P : y, f = S > (f = w > (f = b > (f = x > f ? x : f) ? b : f) ? w : f) ? S : f, g = P > (g = C > (g = T > (g = _ > g ? _ : g) ? T : g) ? C : g) ? P : g
                }
                var E = this._bounds;
                return E.x = m, E.width = f - m, E.y = y, E.height = g - y, this._currentBounds = E, E
            }, s.Sprite.prototype.getLocalBounds = function() {
                var t = this.worldTransform;
                this.worldTransform = Phaser.identityMatrix;
                for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                var i = this.getBounds();
                for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                return i
            }, s.Sprite.prototype._renderWebGL = function(t, e) {
                if (this.visible && !(this.alpha <= 0) && this.renderable) {
                    var i = this.worldTransform;
                    if (e && (i = e), this._mask || this._filters) {
                        var s = t.spriteBatch;
                        this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                        for (n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                        s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
                    } else {
                        t.spriteBatch.render(this);
                        for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
                    }
                }
            }, s.Sprite.prototype._renderCanvas = function(t, e) {
                if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                    var i = this.worldTransform;
                    if (e && (i = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = s.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                        var n = this.texture.baseTexture.resolution / t.resolution;
                        t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === s.scaleModes.LINEAR);
                        var r = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                            o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                            a = i.tx * t.resolution + t.shakeX,
                            h = i.ty * t.resolution + t.shakeY,
                            u = this.texture.crop.width,
                            l = this.texture.crop.height;
                        if (this.texture.rotated) {
                            var c = i.a,
                                d = i.b,
                                p = i.c,
                                f = i.d,
                                g = u;
                            a = i.c * l + a, h = i.d * l + h, i.a = 6.123233995736766e-17 * c - p, i.b = 6.123233995736766e-17 * d - f, i.c = c + 6.123233995736766e-17 * p, i.d = d + 6.123233995736766e-17 * f, u = l, l = g
                        }
                        if (t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | a, 0 | h), r |= 0, o |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, a, h), r /= n, o /= n, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = s.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, u, l, r, o, u / n, l / n);
                        else {
                            var m = this.texture.crop.x,
                                y = this.texture.crop.y;
                            u = Math.floor(u), l = Math.floor(l), t.context.drawImage(this.texture.baseTexture.source, m, y, u, l, r, o, u / n, l / n)
                        }
                        for (v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    } else {
                        for (var v = 0; v < this.children.length; v++) this.children[v]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                }
            }, s.initDefaultShaders = function() {}, s.CompileVertexShader = function(t, e) {
                return s._CompileShader(t, e, t.VERTEX_SHADER)
            }, s.CompileFragmentShader = function(t, e) {
                return s._CompileShader(t, e, t.FRAGMENT_SHADER)
            }, s._CompileShader = function(t, e, i) {
                var s = e;
                Array.isArray(e) && (s = e.join("\n"));
                var n = t.createShader(i);
                return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
            }, s.compileProgram = function(t, e, i) {
                var n = s.CompileFragmentShader(t, i),
                    r = s.CompileVertexShader(t, e),
                    o = t.createProgram();
                return t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(o)), window.console.log("Could not initialise shaders")), o
            }, s.PixiShader = function(t) {
                this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = null, this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
            }, s.PixiShader.prototype.constructor = s.PixiShader, s.PixiShader.prototype.initMultitexShader = function() {
                var t = this.gl;
                this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) {gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;return;}\n";
                this.fragmentSrc = ["// PixiShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}", "}"];
                var n = s.compileProgram(t, this.vertexSrc || s.PixiShader.defaultVertexSrc, this.fragmentSrc);
                t.useProgram(n), this.uSamplerArray = t.getUniformLocation(n, "uSamplerArray[0]"), this.projectionVector = t.getUniformLocation(n, "projectionVector"), this.offsetVector = t.getUniformLocation(n, "offsetVector"), this.dimensions = t.getUniformLocation(n, "dimensions"), this.aVertexPosition = t.getAttribLocation(n, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(n, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(n, "aColor"), this.aTextureIndex = t.getAttribLocation(n, "aTextureIndex");
                var r = [],
                    o = t.createTexture();
                t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, o), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                for (var a = 0; a < this.MAX_TEXTURES; ++a) t.activeTexture(t.TEXTURE0 + a), t.bindTexture(t.TEXTURE_2D, o), r.push(a);
                t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSamplerArray, r), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
                for (var h in this.uniforms) this.uniforms[h].uniformLocation = t.getUniformLocation(n, h);
                this.initUniforms(), this.program = n
            }, s.PixiShader.prototype.initDefaultShader = function() {
                null === this.fragmentSrc && (this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]);
                var t = this.gl,
                    e = s.compileProgram(t, this.vertexSrc || s.PixiShader.defaultVertexSrc, this.fragmentSrc);
                t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex];
                for (var i in this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
                this.initUniforms(), this.program = e
            }, s.PixiShader.prototype.init = function(t) {
                s._enableMultiTextureToggle && !t ? this.initMultitexShader() : this.initDefaultShader()
            }, s.PixiShader.prototype.initUniforms = function() {
                this.textureCount = 1;
                var t, e = this.gl;
                for (var i in this.uniforms) {
                    var s = (t = this.uniforms[i]).type;
                    "sampler2D" === s ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === s || "mat3" === s || "mat4" === s ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === s ? t.glFunc = e.uniformMatrix2fv : "mat3" === s ? t.glFunc = e.uniformMatrix3fv : "mat4" === s && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + s], t.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
                }
            }, s.PixiShader.prototype.initSampler2D = function(t) {
                if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                    var e = this.gl;
                    if (e.activeTexture(e.TEXTURE0 + this.textureCount), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                        var i = t.textureData,
                            s = i.magFilter ? i.magFilter : e.LINEAR,
                            n = i.minFilter ? i.minFilter : e.LINEAR,
                            r = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                            o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                            a = i.luminance ? e.LUMINANCE : e.RGBA;
                        if (i.repeat && (r = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                            var h = i.width ? i.width : 512,
                                u = i.height ? i.height : 2,
                                l = i.border ? i.border : 0;
                            e.texImage2D(e.TEXTURE_2D, 0, a, h, u, l, a, e.UNSIGNED_BYTE, null)
                        } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
                    }
                    e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
                }
            }, s.PixiShader.prototype.syncUniforms = function() {
                this.textureCount = 1;
                var t, e = this.gl;
                for (var i in this.uniforms) 1 === (t = this.uniforms[i]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? s.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
            }, s.PixiShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
            }, s.PixiShader.defaultVertexSrc = ["// PixiShader Vertex Shader", "// With multi-texture rendering", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "   vTextureIndex = aTextureIndex;", "}"], s.PixiFastShader = function(t) {
                if (this._UID = Phaser._UID++, this.gl = t, this.program = null, s._enableMultiTextureToggle) {
                    var t = this.gl;
                    this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                    for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) { gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;return;}\n";
                    this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
                } else this.fragmentSrc = ["// PixiFastShader Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"];
                this.vertexSrc = ["// PixiFastShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute float aTextureIndex;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "varying float vTextureIndex;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
            }, s.PixiFastShader.prototype.constructor = s.PixiFastShader, s.PixiFastShader.prototype.init = function() {
                var t = this.gl,
                    e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                if (t.useProgram(e), this.uSampler = s._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), s._enableMultiTextureToggle) {
                    var i = [],
                        n = t.createTexture();
                    t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                    for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), i.push(r);
                    t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, i)
                }
                this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute, this.aTextureIndex], this.program = e
            }, s.PixiFastShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
            }, s.StripShader = function(t) {
                if (this._UID = Phaser._UID++, this.gl = t, this.program = null, s._enableMultiTextureToggle) {
                    var t = this.gl;
                    this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                    for (var e = "\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) { gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) ;return;}\n";
                    this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);", "const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);", "void main(void) {", e, "   if(vTextureIndex >= " + this.MAX_TEXTURES + ".0) { gl_FragColor = BLUE;return;}", "   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}", "}"]
                } else this.fragmentSrc = ["//StripShader Fragment Shader.", "precision mediump float;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord);", "}"];
                this.vertexSrc = ["//StripShader Vertex Shader.", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aTextureIndex;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying float vTextureIndex;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vTextureIndex = aTextureIndex;", "}"], this.init()
            }, s.StripShader.prototype.constructor = s.StripShader, s.StripShader.prototype.init = function() {
                var t = this.gl,
                    e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                if (t.useProgram(e), this.uSampler = s._enableMultiTextureToggle ? t.getUniformLocation(e, "uSamplerArray[0]") : t.getUniformLocation(e, "uSampler"), s._enableMultiTextureToggle) {
                    var i = [],
                        n = t.createTexture();
                    t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, t.RGB, 1, 1, 0, t.RGB, t.UNSIGNED_BYTE, null);
                    for (var r = 0; r < this.MAX_TEXTURES; ++r) t.activeTexture(t.TEXTURE0 + r), t.bindTexture(t.TEXTURE_2D, n), i.push(r);
                    t.activeTexture(t.TEXTURE0), t.uniform1iv(this.uSampler, i)
                }
                this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aTextureIndex = t.getAttribLocation(e, "aTextureIndex"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.aTextureIndex], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
            }, s.StripShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
            }, s.PrimitiveShader = function(t) {
                this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
            }, s.PrimitiveShader.prototype.constructor = s.PrimitiveShader, s.PrimitiveShader.prototype.init = function() {
                var t = this.gl,
                    e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
            }, s.PrimitiveShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
            }, s.ComplexPrimitiveShader = function(t) {
                this._UID = Phaser._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
            }, s.ComplexPrimitiveShader.prototype.constructor = s.ComplexPrimitiveShader, s.ComplexPrimitiveShader.prototype.init = function() {
                var t = this.gl,
                    e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
                t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
            }, s.ComplexPrimitiveShader.prototype.destroy = function() {
                this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
            }, s.glContexts = [], s.instances = [], s._enableMultiTextureToggle = !1, s.WebGLRenderer = function(t, e) {
                this.game = t, s.defaultRenderer || (s.defaultRenderer = this), this.extensions = {}, this.type = Phaser.WEBGL, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                    alpha: this.transparent,
                    antialias: t.antialias,
                    failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat,
                    premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                    stencil: !0,
                    preserveDrawingBuffer: this.preserveDrawingBuffer
                }, this.projection = new s.Point, this.offset = new s.Point, this.shaderManager = new s.WebGLShaderManager, this.spriteBatch = new s.WebGLSpriteBatch(t), this.maskManager = new s.WebGLMaskManager, this.filterManager = new s.WebGLFilterManager, this.stencilManager = new s.WebGLStencilManager, this.blendModeManager = new s.WebGLBlendModeManager, this.renderSession = {}, this.currentBatchedTextures = [], this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.renderSession.roundPixels = e.roundPixels || !1, this.renderSession.maxTextureAvailableSpace = null, this.initContext(), this.mapBlendModes()
            }, s.WebGLRenderer.prototype.constructor = s.WebGLRenderer, s.WebGLRenderer.prototype.initContext = function() {
                var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
                if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
                this.maxTextures = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = this.gl.getParameter(t.MAX_TEXTURE_SIZE), this.glContextId = t.id = s.WebGLRenderer.glContextId++, s.glContexts[this.glContextId] = t, s.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height), this.extensions.compression = {};
                var e = t.getExtension("WEBGL_compressed_texture_etc1") || t.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                    n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                e && (this.extensions.compression.ETC1 = e), i && (this.extensions.compression.PVRTC = i), n && (this.extensions.compression.S3TC = n)
            }, s.WebGLRenderer.prototype.setTexturePriority = function(t) {
                if (s._enableMultiTextureToggle) {
                    for (var e = function(t) {
                            return --t, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t
                        }, i = this.gl, n = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), r = i.getParameter(i.MAX_TEXTURE_SIZE), o = this.game.cache._cache.image, a = null, h = 0; h < this.currentBatchedTextures.length; h++)(a = this.currentBatchedTextures[h]) in o ? o[a].base.textureIndex = 0 : console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
                    var u = r - e(Math.max(this.width, this.height));
                    this.currentBatchedTextures.length = 0;
                    for (var l = 0; l < t.length; ++l)
                        if ((a = t[l]) in o) {
                            var c = o[a].base;
                            (u -= e(Math.max(c.width, c.height))) <= 0 ? (c.textureIndex = 0, console.warn('setTexturePriority: Image "%s" was given textureIndex=0 because there is no available texture space (%s).', a, u)) : c.textureIndex = 1 + l % (n - 1), this.currentBatchedTextures.push(a)
                        } else console.warn('setTexturePriority: There is no image "%s" in the image cache.', a);
                    return this.renderSession.maxTextureAvailableSpace = u, this.currentBatchedTextures
                }
                console.warn("setTexturePriority error: Multi Texture support hasn't been enabled in the Phaser Game Config.")
            }, s.WebGLRenderer.prototype.render = function(t) {
                if (!this.contextLost) {
                    var e = this.gl;
                    e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
                }
            }, s.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, n) {
                this.renderSession.blendModeManager.setBlendMode(s.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, n), this.spriteBatch.end()
            }, s.WebGLRenderer.prototype.resize = function(t, e) {
                this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
            }, s.WebGLRenderer.prototype.updateCompressedTexture = function(t) {
                if (!t.hasLoaded) return !1;
                var e = this.gl,
                    i = t.source;
                return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.compressedTexImage2D(e.TEXTURE_2D, 0, i.glExtensionFormat, i.width, i.height, 0, i.textureData), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
            }, s.WebGLRenderer.prototype.updateTexture = function(t) {
                if (!t.hasLoaded) return !1;
                if (t.source.compressionAlgorithm) return this.updateCompressedTexture(t);
                var e = this.gl;
                return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.activeTexture(e.TEXTURE0 + t.textureIndex), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && Phaser.Math.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
            }, s.WebGLRenderer.prototype.destroy = function() {
                s.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, Phaser.CanvasPool.remove(this), s.instances[this.glContextId] = null, s.WebGLRenderer.glContextId--
            }, s.WebGLRenderer.prototype.mapBlendModes = function() {
                var t = this.gl;
                if (!s.blendModesWebGL) {
                    var e = [],
                        i = s.blendModes;
                    e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[i.SCREEN] = [t.SRC_ALPHA, t.ONE], e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], s.blendModesWebGL = e
                }
            }, s.WebGLRenderer.prototype.getMaxTextureUnit = function() {
                var t = this.gl;
                return t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
            }, s.enableMultiTexture = function() {
                s._enableMultiTextureToggle = !0
            }, s.WebGLRenderer.glContextId = 0, s.WebGLRenderer.textureArray = [], s.WebGLBlendModeManager = function() {
                this.currentBlendMode = 99999
            }, s.WebGLBlendModeManager.prototype.constructor = s.WebGLBlendModeManager, s.WebGLBlendModeManager.prototype.setContext = function(t) {
                this.gl = t
            }, s.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
                if (this.currentBlendMode === t) return !1;
                this.currentBlendMode = t;
                var e = s.blendModesWebGL[this.currentBlendMode];
                return e && this.gl.blendFunc(e[0], e[1]), !0
            }, s.WebGLBlendModeManager.prototype.destroy = function() {
                this.gl = null
            }, s.WebGLMaskManager = function() {}, s.WebGLMaskManager.prototype.constructor = s.WebGLMaskManager, s.WebGLMaskManager.prototype.setContext = function(t) {
                this.gl = t
            }, s.WebGLMaskManager.prototype.pushMask = function(t, e) {
                var i = e.gl;
                t.dirty && s.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
            }, s.WebGLMaskManager.prototype.popMask = function(t, e) {
                var i = this.gl;
                void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
            }, s.WebGLMaskManager.prototype.destroy = function() {
                this.gl = null
            }, s.WebGLStencilManager = function() {
                this.stencilStack = [], this.reverse = !0, this.count = 0
            }, s.WebGLStencilManager.prototype.setContext = function(t) {
                this.gl = t
            }, s.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
                var s = this.gl;
                this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
                var n = this.count;
                s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
            }, s.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
                this._currentGraphics = t;
                var s, n = this.gl,
                    r = i.projection,
                    o = i.offset;
                1 === e.mode ? (s = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(s), n.uniform1f(s.flipY, i.flipY), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform3fv(s.color, e.color), n.uniform1f(s.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (s = i.shaderManager.primitiveShader, i.shaderManager.setShader(s), n.uniformMatrix3fv(s.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(s.flipY, i.flipY), n.uniform2f(s.projectionVector, r.x, -r.y), n.uniform2f(s.offsetVector, -o.x, -o.y), n.uniform3fv(s.tintColor, Phaser.Color.hexToRGBArray(t.tint)), n.uniform1f(s.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(s.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(s.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
            }, s.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
                var s = this.gl;
                if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
                else {
                    var n = this.count;
                    this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
                }
            }, s.WebGLStencilManager.prototype.destroy = function() {
                this.stencilStack = null, this.gl = null
            }, s.WebGLShaderManager = function() {
                this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
                for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
                this.stack = []
            }, s.WebGLShaderManager.prototype.constructor = s.WebGLShaderManager, s.WebGLShaderManager.prototype.setContext = function(t) {
                this.gl = t, this.primitiveShader = new s.PrimitiveShader(t), this.complexPrimitiveShader = new s.ComplexPrimitiveShader(t), this.defaultShader = new s.PixiShader(t), this.fastShader = new s.PixiFastShader(t), this.stripShader = new s.StripShader(t), this.creatureShader = s.CreatureShader ? new s.CreatureShader(t) : null, this.setShader(this.defaultShader)
            }, s.WebGLShaderManager.prototype.setAttribs = function(t) {
                var e;
                for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
                for (e = 0; e < t.length; e++) {
                    var i = t[e];
                    this.tempAttribState[i] = !0
                }
                var s = this.gl;
                for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
            }, s.WebGLShaderManager.prototype.setShader = function(t) {
                return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
            }, s.WebGLShaderManager.prototype.destroy = function() {
                this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.creatureShader && this.creatureShader.destroy(), this.gl = null
            }, s.WebGLSpriteBatch = function(t) {
                this.game = t, this.vertSize = 5, this.size = 2e3, this.vertexSize = 24;
                var e = this.vertexSize * this.size * 4,
                    i = 6 * this.size;
                this.vertices = new ArrayBuffer(e), this.positions = new Float32Array(this.vertices), this.colors = new Uint32Array(this.vertices), this.indices = new Uint16Array(i), this.lastIndexCount = 0;
                for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
                this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = null
            }, s.WebGLSpriteBatch.prototype.setContext = function(t) {
                if (this.MAX_TEXTURES = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.gl = t, s._enableMultiTextureToggle) {
                    for (var e = "\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\n", i = 1; i < this.MAX_TEXTURES; ++i) e += "\tif (vTextureIndex == " + i + ".0) {gl_FragColor = texture2D(uSamplerArray[" + i + "], vTextureCoord) * vColor;return;}\n";
                    this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSamplerArray[" + this.MAX_TEXTURES + "];", "void main(void) {", e, "\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;", "}"])
                } else this.defaultShader = new Phaser.Filter(this.game, void 0, ["//WebGLSpriteBatch Fragment Shader.", "precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureIndex;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;", "}"]);
                this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
                var n = new s.PixiShader(t);
                n.fragmentSrc = this.defaultShader.fragmentSrc, n.uniforms = {}, n.init(), this.defaultShader.shaders[t.id] = n
            }, s.WebGLSpriteBatch.prototype.begin = function(t) {
                this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
            }, s.WebGLSpriteBatch.prototype.end = function() {
                this.flush()
            }, s.WebGLSpriteBatch.prototype.render = function(t, e) {
                var i = t.texture,
                    n = i.baseTexture,
                    r = this.gl;
                s.WebGLRenderer.textureArray[n.textureIndex] != n && (this.flush(), r.activeTexture(r.TEXTURE0 + n.textureIndex), r.bindTexture(r.TEXTURE_2D, n._glTextures[r.id]), s.WebGLRenderer.textureArray[n.textureIndex] = n);
                var o = t.worldTransform;
                e && (o = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
                var a = i._uvs;
                if (a) {
                    var h, u, l, c, d = t.anchor.x,
                        p = t.anchor.y;
                    if (i.trim) {
                        var f = i.trim;
                        h = (u = f.x - d * f.width) + i.crop.width, l = (c = f.y - p * f.height) + i.crop.height
                    } else h = i.frame.width * (1 - d), u = i.frame.width * -d, l = i.frame.height * (1 - p), c = i.frame.height * -p;
                    var g = this.currentBatchSize * this.vertexSize,
                        m = (this.currentBatchSize, i.baseTexture.resolution),
                        y = i.baseTexture.textureIndex,
                        v = o.a / m,
                        x = o.b / m,
                        _ = o.c / m,
                        b = o.d / m,
                        T = o.tx,
                        w = o.ty,
                        C = (i.crop.width, i.crop.height);
                    if (i.rotated) {
                        var S = o.a,
                            P = o.b,
                            E = o.c,
                            A = o.d,
                            M = u,
                            R = h;
                        T = o.c * C + T, w = o.d * C + w, v = 6.123233995736766e-17 * S - E, x = 6.123233995736766e-17 * P - A, _ = S + 6.123233995736766e-17 * E, b = P + 6.123233995736766e-17 * A, i._updateUvsInverted(), h = l, u = c, l = R, c = M
                    }
                    var O = this.colors,
                        I = this.positions,
                        L = t.tint,
                        D = (L >> 16) + (65280 & L) + ((255 & L) << 16) + (255 * t.worldAlpha << 24);
                    this.renderSession.roundPixels ? (I[g++] = v * u + _ * c + T | 0, I[g++] = b * c + x * u + w | 0, I[g++] = a.x0, I[g++] = a.y0, O[g++] = D, I[g++] = y, I[g++] = v * h + _ * c + T | 0, I[g++] = b * c + x * h + w | 0, I[g++] = a.x1, I[g++] = a.y1, O[g++] = D, I[g++] = y, I[g++] = v * h + _ * l + T | 0, I[g++] = b * l + x * h + w | 0, I[g++] = a.x2, I[g++] = a.y2, O[g++] = D, I[g++] = y, I[g++] = v * u + _ * l + T | 0, I[g++] = b * l + x * u + w | 0, I[g++] = a.x3, I[g++] = a.y3, O[g++] = D, I[g++] = y) : (I[g++] = v * u + _ * c + T, I[g++] = b * c + x * u + w, I[g++] = a.x0, I[g++] = a.y0, O[g++] = D, I[g++] = y, I[g++] = v * h + _ * c + T, I[g++] = b * c + x * h + w, I[g++] = a.x1, I[g++] = a.y1, O[g++] = D, I[g++] = y, I[g++] = v * h + _ * l + T, I[g++] = b * l + x * h + w, I[g++] = a.x2, I[g++] = a.y2, O[g++] = D, I[g++] = y, I[g++] = v * u + _ * l + T, I[g++] = b * l + x * u + w, I[g++] = a.x3, I[g++] = a.y3, O[g++] = D, I[g++] = y), this.sprites[this.currentBatchSize++] = t
                }
            }, s.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
                var e = t.tilingTexture,
                    i = e.baseTexture,
                    n = this.gl,
                    r = t.texture.baseTexture.textureIndex;
                s.WebGLRenderer.textureArray[r] != i && (this.flush(), n.activeTexture(n.TEXTURE0 + r), n.bindTexture(n.TEXTURE_2D, i._glTextures[n.id]), s.WebGLRenderer.textureArray[r] = i), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new s.TextureUvs);
                var o = t._uvs,
                    a = e.baseTexture.width,
                    h = e.baseTexture.height;
                t.tilePosition.x %= a * t.tileScaleOffset.x, t.tilePosition.y %= h * t.tileScaleOffset.y;
                var u = t.tilePosition.x / (a * t.tileScaleOffset.x),
                    l = t.tilePosition.y / (h * t.tileScaleOffset.y),
                    c = t.width / a / (t.tileScale.x * t.tileScaleOffset.x),
                    d = t.height / h / (t.tileScale.y * t.tileScaleOffset.y);
                o.x0 = 0 - u, o.y0 = 0 - l, o.x1 = 1 * c - u, o.y1 = 0 - l, o.x2 = 1 * c - u, o.y2 = 1 * d - l, o.x3 = 0 - u, o.y3 = 1 * d - l;
                var p = t.tint,
                    f = (p >> 16) + (65280 & p) + ((255 & p) << 16) + (255 * t.worldAlpha << 24),
                    g = this.positions,
                    m = this.colors,
                    y = t.width,
                    v = t.height,
                    x = t.anchor.x,
                    _ = t.anchor.y,
                    b = y * (1 - x),
                    T = y * -x,
                    w = v * (1 - _),
                    C = v * -_,
                    S = this.currentBatchSize * this.vertexSize,
                    P = e.baseTexture.resolution,
                    E = t.worldTransform,
                    A = E.a / P,
                    M = E.b / P,
                    R = E.c / P,
                    O = E.d / P,
                    I = E.tx,
                    L = E.ty;
                g[S++] = A * T + R * C + I, g[S++] = O * C + M * T + L, g[S++] = o.x0, g[S++] = o.y0, m[S++] = f, g[S++] = r, g[S++] = A * b + R * C + I, g[S++] = O * C + M * b + L, g[S++] = o.x1, g[S++] = o.y1, m[S++] = f, g[S++] = r, g[S++] = A * b + R * w + I, g[S++] = O * w + M * b + L, g[S++] = o.x2, g[S++] = o.y2, m[S++] = f, g[S++] = r, g[S++] = A * T + R * w + I, g[S++] = O * w + M * T + L, g[S++] = o.x3, g[S++] = o.y3, m[S++] = f, g[S++] = r, this.sprites[this.currentBatchSize++] = t
            }, s.WebGLSpriteBatch.prototype.flush = function() {
                if (0 !== this.currentBatchSize) {
                    var t, e = this.gl;
                    if (this.dirty) {
                        this.dirty = !1, t = this.defaultShader.shaders[e.id], e.activeTexture(e.TEXTURE0), e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                        var i = this.vertexSize;
                        e.vertexAttribPointer(t.aVertexPosition, 2, e.FLOAT, !1, i, 0), e.vertexAttribPointer(t.aTextureCoord, 2, e.FLOAT, !1, i, 8), e.vertexAttribPointer(t.colorAttribute, 4, e.UNSIGNED_BYTE, !0, i, 16), e.vertexAttribPointer(t.aTextureIndex, 1, e.FLOAT, !1, i, 20)
                    }
                    if (this.currentBatchSize > .5 * this.size) e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices);
                    else {
                        e.bindBuffer(e.ARRAY_BUFFER, this.vertexBuffer);
                        var n = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);
                        e.bufferSubData(e.ARRAY_BUFFER, 0, n)
                    }
                    for (var r, o, a, h, u = 0, l = 0, c = null, d = this.renderSession.blendModeManager.currentBlendMode, p = null, f = !1, g = !1, m = 0, y = this.currentBatchSize; m < y; m++) {
                        r = (h = this.sprites[m]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, f = d !== (o = h.blendMode), g = p !== (a = h.shader || this.defaultShader);
                        var v = r.skipRender;
                        if (v && h.children.length > 0 && (v = !1), (f || g) && (this.renderBatch(c, u, l), l = m, u = 0, c = r, f && (d = o, this.renderSession.blendModeManager.setBlendMode(d)), g)) {
                            (t = (p = a).shaders[e.id]) || ((t = new s.PixiShader(e)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[e.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms();
                            var x = this.renderSession.projection;
                            e.uniform2f(t.projectionVector, x.x, x.y);
                            var _ = this.renderSession.offset;
                            e.uniform2f(t.offsetVector, _.x, _.y)
                        }
                        u++
                    }
                    this.renderBatch(c, u, l), this.currentBatchSize = 0
                }
            }, s.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
                if (0 !== e) {
                    var s = this.gl;
                    if (t._dirty[s.id]) {
                        if (!this.renderSession.renderer.updateTexture(t)) return
                    } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
                    s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
                }
            }, s.WebGLSpriteBatch.prototype.stop = function() {
                this.flush(), this.dirty = !0
            }, s.WebGLSpriteBatch.prototype.start = function() {
                this.dirty = !0
            }, s.WebGLSpriteBatch.prototype.destroy = function() {
                this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
            }, s.WebGLFastSpriteBatch = function(t) {
                this.vertSize = 11, this.maxSize = 6e3, this.size = this.maxSize;
                var e = 4 * this.size * this.vertSize,
                    i = 6 * this.maxSize;
                this.vertices = new Float32Array(e), this.indices = new Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
                for (var s = 0, n = 0; s < i; s += 6, n += 4) this.indices[s + 0] = n + 0, this.indices[s + 1] = n + 1, this.indices[s + 2] = n + 2, this.indices[s + 3] = n + 0, this.indices[s + 4] = n + 2, this.indices[s + 5] = n + 3;
                this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
            }, s.WebGLFastSpriteBatch.prototype.constructor = s.WebGLFastSpriteBatch, s.WebGLFastSpriteBatch.prototype.setContext = function(t) {
                this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
            }, s.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
                this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
            }, s.WebGLFastSpriteBatch.prototype.end = function() {
                this.flush()
            }, s.WebGLFastSpriteBatch.prototype.render = function(t) {
                var e = t.children,
                    i = e[0];
                if (i.texture._uvs) {
                    this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                    for (var s = 0, n = e.length; s < n; s++) this.renderSprite(e[s]);
                    this.flush()
                }
            }, s.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
                var e = t.texture.baseTexture,
                    i = this.gl,
                    n = t.texture.baseTexture.textureIndex;
                if ((s.WebGLRenderer.textureArray[n] == e || !e._glTextures[i.id] || t.texture.baseTexture.skipRender || (this.flush(), i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, e._glTextures[i.id]), s.WebGLRenderer.textureArray[n] = e, t.texture._uvs)) && t.visible) {
                    var r, o, a, h, u, l, c = this.vertices;
                    if (r = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) {
                        var d = t.texture.trim;
                        o = (a = d.x - t.anchor.x * d.width) + t.texture.crop.width, h = (u = d.y - t.anchor.y * d.height) + t.texture.crop.height
                    } else o = t.texture.frame.width * (1 - t.anchor.x), a = t.texture.frame.width * -t.anchor.x, h = t.texture.frame.height * (1 - t.anchor.y), u = t.texture.frame.height * -t.anchor.y;
                    l = 4 * this.currentBatchSize * this.vertSize, c[l++] = a, c[l++] = u, c[l++] = t.position.x, c[l++] = t.position.y, c[l++] = t.scale.x, c[l++] = t.scale.y, c[l++] = t.rotation, c[l++] = r.x0, c[l++] = r.y1, c[l++] = t.alpha, c[l++] = n, c[l++] = o, c[l++] = u, c[l++] = t.position.x, c[l++] = t.position.y, c[l++] = t.scale.x, c[l++] = t.scale.y, c[l++] = t.rotation, c[l++] = r.x1, c[l++] = r.y1, c[l++] = t.alpha, c[l++] = n, c[l++] = o, c[l++] = h, c[l++] = t.position.x, c[l++] = t.position.y, c[l++] = t.scale.x, c[l++] = t.scale.y, c[l++] = t.rotation, c[l++] = r.x2, c[l++] = r.y2, c[l++] = t.alpha, c[l++] = n, c[l++] = a, c[l++] = h, c[l++] = t.position.x, c[l++] = t.position.y, c[l++] = t.scale.x, c[l++] = t.scale.y, c[l++] = t.rotation, c[l++] = r.x3, c[l++] = r.y3, c[l++] = t.alpha, c[l++] = n, ++this.currentBatchSize >= this.size && this.flush()
                }
            }, s.WebGLFastSpriteBatch.prototype.flush = function() {
                if (0 !== this.currentBatchSize) {
                    var t = this.gl;
                    if (this.currentBaseTexture._glTextures[t.id]) {
                        if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                        else {
                            var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                            t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                        }
                        t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
                    } else this.renderSession.renderer.updateTexture(this.currentBaseTexture, t)
                }
            }, s.WebGLFastSpriteBatch.prototype.stop = function() {
                this.flush()
            }, s.WebGLFastSpriteBatch.prototype.start = function() {
                var t = this.gl;
                t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var e = this.renderSession.projection;
                t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
                var i = 4 * this.vertSize;
                t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36), t.vertexAttribPointer(this.shader.aTextureIndex, 1, t.FLOAT, !1, i, 40)
            }, s.WebGLFilterManager = function() {
                this.filterStack = [], this.offsetX = 0, this.offsetY = 0
            }, s.WebGLFilterManager.prototype.constructor = s.WebGLFilterManager, s.WebGLFilterManager.prototype.setContext = function(t) {
                this.gl = t, this.texturePool = [], this.initShaderBuffers()
            }, s.WebGLFilterManager.prototype.begin = function(t, e) {
                this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
                var i = this.renderSession.projection;
                this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
            }, s.WebGLFilterManager.prototype.pushFilter = function(t) {
                var e = this.gl,
                    i = this.renderSession.projection,
                    n = this.renderSession.offset;
                t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new s.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
                var r = t.filterPasses[0];
                this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
                var o = this.texturePool.pop();
                o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new s.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, o.texture);
                var a = t._filterArea,
                    h = r.padding;
                a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer), e.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), i.x = a.width / 2, i.y = -a.height / 2, n.x = -a.x, n.y = -a.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = o
            }, s.WebGLFilterManager.prototype.popFilter = function() {
                var t = this.gl,
                    e = this.filterStack.pop(),
                    i = e._filterArea,
                    n = e._glFilterTexture,
                    r = this.renderSession.projection,
                    o = this.renderSession.offset;
                if (e.filterPasses.length > 1) {
                    t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                    var a = n,
                        h = this.texturePool.pop();
                    h || (h = new s.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                    for (var u = 0; u < e.filterPasses.length - 1; u++) {
                        var l = e.filterPasses[u];
                        t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(l, i, i.width, i.height);
                        var c = a;
                        a = h, h = c
                    }
                    t.enable(t.BLEND), n = a, this.texturePool.push(h)
                }
                var d = e.filterPasses[e.filterPasses.length - 1];
                this.offsetX -= i.x, this.offsetY -= i.y;
                var p = this.width,
                    f = this.height,
                    g = 0,
                    m = 0,
                    y = this.buffer;
                if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
                else {
                    var v = this.filterStack[this.filterStack.length - 1];
                    p = (i = v._filterArea).width, f = i.height, g = i.x, m = i.y, y = v._glFilterTexture.frameBuffer
                }
                r.x = p / 2, r.y = -f / 2, o.x = g, o.y = m;
                var x = (i = e._filterArea).x - g,
                    _ = i.y - m;
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = x, this.vertexArray[1] = _ + i.height, this.vertexArray[2] = x + i.width, this.vertexArray[3] = _ + i.height, this.vertexArray[4] = x, this.vertexArray[5] = _, this.vertexArray[6] = x + i.width, this.vertexArray[7] = _, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, y), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, i, p, f), this.texturePool.push(n), e._glFilterTexture = null
            }, s.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, n) {
                var r = this.gl,
                    o = t.shaders[r.id];
                o || ((o = new s.PixiShader(r)).fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(!0), t.shaders[r.id] = o), this.renderSession.shaderManager.setShader(o), r.uniform2f(o.projectionVector, i / 2, -n / 2), r.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), r.bindBuffer(r.ARRAY_BUFFER, this.vertexBuffer), r.vertexAttribPointer(o.aVertexPosition, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.uvBuffer), r.vertexAttribPointer(o.aTextureCoord, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this.colorBuffer), r.vertexAttribPointer(o.colorAttribute, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this.indexBuffer), r.drawElements(r.TRIANGLES, 6, r.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
            }, s.WebGLFilterManager.prototype.initShaderBuffers = function() {
                var t = this.gl;
                this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
            }, s.WebGLFilterManager.prototype.destroy = function() {
                var t = this.gl;
                this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
                for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
                this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
            };
            var n = {
                36054: "Incomplete attachment",
                36055: "Missing attachment",
                36057: "Incomplete dimensions",
                36061: "Framebuffer unsupported"
            };
            return s.FilterTexture = function(t, i, n, r, o) {
                o = "number" == typeof o ? o : 0, this.gl = t, this.frameBuffer = e(t, i, n, r || s.scaleModes.DEFAULT, o), this.texture = this.frameBuffer.targetTexture, this.width = i, this.height = n, this.renderBuffer = this.frameBuffer.renderBuffer
            }, s.FilterTexture.prototype.constructor = s.FilterTexture, s.FilterTexture.prototype.clear = function() {
                var t = this.gl;
                t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
            }, s.FilterTexture.prototype.resize = function(t, e) {
                if (this.width !== t || this.height !== e) {
                    this.width = t, this.height = e;
                    var i = this.gl;
                    i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
                }
            }, s.FilterTexture.prototype.destroy = function() {
                var t = this.gl;
                t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
            }, s.CanvasBuffer = function(t, e) {
                this.width = t, this.height = e, this.canvas = Phaser.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
            }, s.CanvasBuffer.prototype.constructor = s.CanvasBuffer, s.CanvasBuffer.prototype.clear = function() {
                this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
            }, s.CanvasBuffer.prototype.resize = function(t, e) {
                this.width = this.canvas.width = t, this.height = this.canvas.height = e
            }, s.CanvasBuffer.prototype.destroy = function() {
                Phaser.CanvasPool.remove(this)
            }, s.CanvasMaskManager = function() {}, s.CanvasMaskManager.prototype.constructor = s.CanvasMaskManager, s.CanvasMaskManager.prototype.pushMask = function(t, e) {
                var i = e.context;
                i.save();
                var n = t.alpha,
                    r = t.worldTransform,
                    o = e.resolution;
                i.setTransform(r.a * o, r.b * o, r.c * o, r.d * o, r.tx * o, r.ty * o), s.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = n
            }, s.CanvasMaskManager.prototype.popMask = function(t) {
                t.context.restore()
            }, s.CanvasTinter = function() {}, s.CanvasTinter.getTintedTexture = function(t, e) {
                var i = t.tintedTexture || Phaser.CanvasPool.create(this);
                return s.CanvasTinter.tintMethod(t.texture, e, i), i
            }, s.CanvasTinter.tintWithMultiply = function(t, e, i) {
                var s = i.getContext("2d"),
                    n = t.crop,
                    r = n.width,
                    o = n.height;
                t.rotated && (r = o, o = n.width), i.width === r && i.height === o || (i.width = r, i.height = o), s.clearRect(0, 0, r, o), s.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), s.fillRect(0, 0, r, o), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, r, o, 0, 0, r, o)
            }, s.CanvasTinter.tintWithPerPixel = function(t, e, i) {
                var n = i.getContext("2d"),
                    r = t.crop,
                    o = r.width,
                    a = r.height;
                t.rotated && (o = a, a = r.width), i.width === o && i.height === a || (i.width = o, i.height = a), n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, r.x, r.y, o, a, 0, 0, o, a);
                for (var h = Phaser.Color.hexToRGBArray(e), u = h[0], l = h[1], c = h[2], d = n.getImageData(0, 0, o, a), p = d.data, f = 0; f < p.length; f += 4)
                    if (p[f + 0] *= u, p[f + 1] *= l, p[f + 2] *= c, !s.CanvasTinter.canHandleAlpha) {
                        var g = p[f + 3];
                        p[f + 0] /= 255 / g, p[f + 1] /= 255 / g, p[f + 2] /= 255 / g
                    }
                n.putImageData(d, 0, 0)
            }, s.CanvasRenderer = function(t, e) {
                this.game = t, s.defaultRenderer || (s.defaultRenderer = this), this.type = Phaser.CANVAS, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                    alpha: this.transparent
                }), this.refresh = !0, this.count = 0, this.maskManager = new s.CanvasMaskManager, this.renderSession = {
                    context: this.context,
                    maskManager: this.maskManager,
                    scaleMode: null,
                    smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                    roundPixels: e.roundPixels || !1
                }, this.mapBlendModes(), this.resize(this.width, this.height)
            }, s.CanvasRenderer.prototype.constructor = s.CanvasRenderer, s.CanvasRenderer.prototype.render = function(t) {
                this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
            }, s.CanvasRenderer.prototype.setTexturePriority = function(t) {}, s.CanvasRenderer.prototype.destroy = function(t) {
                void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
            }, s.CanvasRenderer.prototype.resize = function(t, e) {
                this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === s.scaleModes.LINEAR)
            }, s.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
                this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
            }, s.CanvasRenderer.prototype.mapBlendModes = function() {
                if (!s.blendModesCanvas) {
                    var t = [],
                        e = s.blendModes,
                        i = this.game.device.canUseMultiply;
                    t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", s.blendModesCanvas = t
                }
            }, s.BaseTexture = function(t, e, i) {
                this.resolution = i || 1, this.width = 100, this.height = 100, this.scaleMode = e || s.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this.textureIndex = 0, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
            }, s.BaseTexture.prototype.constructor = s.BaseTexture, s.BaseTexture.prototype.forceLoaded = function(t, e) {
                this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
            }, s.BaseTexture.prototype.destroy = function() {
                this.source && Phaser.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
            }, s.BaseTexture.prototype.dirty = function() {
                for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
            }, s.BaseTexture.prototype.unloadFromGPU = function() {
                this.dirty();
                for (var t = this._glTextures.length - 1; t >= 0; t--) {
                    var e = this._glTextures[t],
                        i = s.glContexts[t];
                    i && e && i.deleteTexture(e)
                }
                this._glTextures.length = 0, this.dirty()
            }, s.BaseTexture.fromCanvas = function(t, e, i) {
                return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), i = i || 1, new s.BaseTexture(t, e, i)
            }, s.TextureSilentFail = !1, s.Texture = function(t, e, i, n) {
                this.noFrame = !1, e || (this.noFrame = !0, e = new s.Rectangle(0, 0, 1, 1)), t instanceof s.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new s.Rectangle(0, 0, 1, 1), this.rotated = !1, t.hasLoaded && (this.noFrame && (e = new s.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
            }, s.Texture.prototype.constructor = s.Texture, s.Texture.prototype.onBaseTextureLoaded = function() {
                var t = this.baseTexture;
                this.noFrame && (this.frame = new s.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
            }, s.Texture.prototype.destroy = function(t) {
                t && this.baseTexture.destroy(), this.valid = !1
            }, s.Texture.prototype.setFrame = function(t) {
                if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
                else {
                    if (!s.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                    this.valid = !1
                }
            }, s.Texture.prototype._updateUvs = function() {
                this._uvs || (this._uvs = new s.TextureUvs);
                var t = this.crop,
                    e = this.baseTexture.width,
                    i = this.baseTexture.height;
                this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
            }, s.Texture.prototype._updateUvsInverted = function() {
                this._uvs || (this._uvs = new s.TextureUvs);
                var t = this.crop,
                    e = this.baseTexture.width,
                    i = this.baseTexture.height;
                this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.height) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.height) / e, this._uvs.y2 = (t.y + t.width) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.width) / i
            }, s.Texture.fromCanvas = function(t, e) {
                var i = s.BaseTexture.fromCanvas(t, e);
                return new s.Texture(i)
            }, s.TextureUvs = function() {
                this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
            }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = s), exports.PIXI = s) : "undefined" != typeof define && define.amd ? define("PIXI", i.PIXI = s) : i.PIXI = s, s
        }).call(this),
            function() {
                function t(t, e) {
                    this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
                }
                var e = this,
                    i = i || {
                        VERSION: "2.10.0",
                        GAMES: [],
                        AUTO: 0,
                        CANVAS: 1,
                        WEBGL: 2,
                        HEADLESS: 3,
                        WEBGL_MULTI: 4,
                        NONE: 0,
                        LEFT: 1,
                        RIGHT: 2,
                        UP: 3,
                        DOWN: 4,
                        SPRITE: 0,
                        BUTTON: 1,
                        IMAGE: 2,
                        GRAPHICS: 3,
                        TEXT: 4,
                        TILESPRITE: 5,
                        BITMAPTEXT: 6,
                        GROUP: 7,
                        RENDERTEXTURE: 8,
                        TILEMAP: 9,
                        TILEMAPLAYER: 10,
                        EMITTER: 11,
                        POLYGON: 12,
                        BITMAPDATA: 13,
                        CANVAS_FILTER: 14,
                        WEBGL_FILTER: 15,
                        ELLIPSE: 16,
                        SPRITEBATCH: 17,
                        RETROFONT: 18,
                        POINTER: 19,
                        ROPE: 20,
                        CIRCLE: 21,
                        RECTANGLE: 22,
                        LINE: 23,
                        MATRIX: 24,
                        POINT: 25,
                        ROUNDEDRECTANGLE: 26,
                        CREATURE: 27,
                        VIDEO: 28,
                        PENDING_ATLAS: -1,
                        HORIZONTAL: 0,
                        VERTICAL: 1,
                        LANDSCAPE: 0,
                        PORTRAIT: 1,
                        ANGLE_UP: 270,
                        ANGLE_DOWN: 90,
                        ANGLE_LEFT: 180,
                        ANGLE_RIGHT: 0,
                        ANGLE_NORTH_EAST: 315,
                        ANGLE_NORTH_WEST: 225,
                        ANGLE_SOUTH_EAST: 45,
                        ANGLE_SOUTH_WEST: 135,
                        TOP_LEFT: 0,
                        TOP_CENTER: 1,
                        TOP_RIGHT: 2,
                        LEFT_TOP: 3,
                        LEFT_CENTER: 4,
                        LEFT_BOTTOM: 5,
                        CENTER: 6,
                        RIGHT_TOP: 7,
                        RIGHT_CENTER: 8,
                        RIGHT_BOTTOM: 9,
                        BOTTOM_LEFT: 10,
                        BOTTOM_CENTER: 11,
                        BOTTOM_RIGHT: 12,
                        blendModes: {
                            NORMAL: 0,
                            ADD: 1,
                            MULTIPLY: 2,
                            SCREEN: 3,
                            OVERLAY: 4,
                            DARKEN: 5,
                            LIGHTEN: 6,
                            COLOR_DODGE: 7,
                            COLOR_BURN: 8,
                            HARD_LIGHT: 9,
                            SOFT_LIGHT: 10,
                            DIFFERENCE: 11,
                            EXCLUSION: 12,
                            HUE: 13,
                            SATURATION: 14,
                            COLOR: 15,
                            LUMINOSITY: 16
                        },
                        scaleModes: {
                            DEFAULT: 0,
                            LINEAR: 0,
                            NEAREST: 1
                        },
                        PIXI: PIXI || {},
                        _UID: 0
                    };
                if (Math.trunc || (Math.trunc = function(t) {
                        return t < 0 ? Math.ceil(t) : Math.floor(t)
                    }), Function.prototype.bind || (Function.prototype.bind = function() {
                        var t = Array.prototype.slice;
                        return function(e) {
                            function i() {
                                var r = n.concat(t.call(arguments));
                                s.apply(this instanceof i ? this : e, r)
                            }
                            var s = this,
                                n = t.call(arguments, 1);
                            if ("function" != typeof s) throw new TypeError;
                            return i.prototype = function t(e) {
                                if (e && (t.prototype = e), !(this instanceof t)) return new t
                            }(s.prototype), i
                        }
                    }()), Array.isArray || (Array.isArray = function(t) {
                        return "[object Array]" === Object.prototype.toString.call(t)
                    }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                        "use strict";
                        if (void 0 === this || null === this) throw new TypeError;
                        var e = Object(this),
                            i = e.length >>> 0;
                        if ("function" != typeof t) throw new TypeError;
                        for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
                    }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
                    var s = function(t) {
                        var e = new Array;
                        window[t] = function(t) {
                            if ("number" == typeof t) {
                                Array.call(this, t), this.length = t;
                                for (e = 0; e < this.length; e++) this[e] = 0
                            } else {
                                Array.call(this, t.length), this.length = t.length;
                                for (var e = 0; e < this.length; e++) this[e] = t[e]
                            }
                        }, window[t].prototype = e, window[t].constructor = window[t]
                    };
                    s("Float32Array"), s("Uint32Array"), s("Uint16Array"), s("Int16Array"), s("ArrayBuffer")
                }
                window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), Object.assign || (Object.assign = function(t, e) {
                    "use strict";
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    for (var i = Object(t), s = Object.prototype.hasOwnProperty, n = 1; n < arguments.length; n++) {
                        var r = arguments[n];
                        if (null != r)
                            for (var o in r) s.call(r, o) && (i[o] = r[o])
                    }
                    return i
                }), i.Utils = {
                    reverseString: function(t) {
                        return t.split("").reverse().join("")
                    },
                    getProperty: function(t, e) {
                        var i = e.split(".");
                        switch (i.length) {
                            case 1:
                                return t[e];
                            case 2:
                                return t[i[0]][i[1]];
                            case 3:
                                return t[i[0]][i[1]][i[2]];
                            case 4:
                                return t[i[0]][i[1]][i[2]][i[3]];
                            default:
                                return this._getProperty(t, e)
                        }
                    },
                    setProperties: function(t, e) {
                        for (var i in e) this.setProperty(t, i, e[i]);
                        return t
                    },
                    setProperty: function(t, e, i) {
                        var s = e.split(".");
                        switch (s.length) {
                            case 1:
                                t[e] = i;
                                break;
                            case 2:
                                t[s[0]][s[1]] = i;
                                break;
                            case 3:
                                t[s[0]][s[1]][s[2]] = i;
                                break;
                            case 4:
                                t[s[0]][s[1]][s[2]][s[3]] = i;
                                break;
                            default:
                                this._setProperty(t, e, i)
                        }
                    },
                    _getProperty: function(t, e) {
                        for (var i = e.split("."), s = i.length, n = 0, r = t; n < s;) {
                            var o = i[n];
                            if (null == r) return;
                            r = r[o], n++
                        }
                        return r
                    },
                    _setProperty: function(t, e, i) {
                        var s = e.split("."),
                            n = s.length,
                            r = 0,
                            o = t,
                            a = s[0];
                        if (1 === n) t[e] = i;
                        else {
                            for (; r < n - 1;) o = o[a], a = s[++r];
                            o[a] = i
                        }
                        return t
                    },
                    chanceRoll: function(t) {
                        return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
                    },
                    randomChoice: function(t, e) {
                        return Math.random() < .5 ? t : e
                    },
                    parseDimension: function(t, e) {
                        var i = 0,
                            s = 0;
                        return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
                    },
                    pad: function(t, e, i, s) {
                        if (void 0 === e) var e = 0;
                        if (void 0 === i) var i = " ";
                        if (void 0 === s) var s = 3;
                        var n = 0;
                        if (e + 1 >= (t = t.toString()).length) switch (s) {
                            case 1:
                                t = new Array(e + 1 - t.length).join(i) + t;
                                break;
                            case 3:
                                var r = Math.ceil((n = e - t.length) / 2),
                                    o = n - r;
                                t = new Array(o + 1).join(i) + t + new Array(r + 1).join(i);
                                break;
                            default:
                                t += new Array(e + 1 - t.length).join(i)
                        }
                        return t
                    },
                    isPlainObject: function(t) {
                        if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                        try {
                            if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                        } catch (t) {
                            return !1
                        }
                        return !0
                    },
                    extend: function() {
                        var t, e, s, n, r, o, a = arguments[0] || {},
                            h = 1,
                            u = arguments.length,
                            l = !1;
                        for ("boolean" == typeof a && (l = a, a = arguments[1] || {}, h = 2), u === h && (a = this, --h); h < u; h++)
                            if (null != (t = arguments[h]))
                                for (e in t) s = a[e], a !== (n = t[e]) && (l && n && (i.Utils.isPlainObject(n) || (r = Array.isArray(n))) ? (r ? (r = !1, o = s && Array.isArray(s) ? s : []) : o = s && i.Utils.isPlainObject(s) ? s : {}, a[e] = i.Utils.extend(l, o, n)) : void 0 !== n && (a[e] = n));
                        return a
                    },
                    mixinPrototype: function(t, e, i) {
                        void 0 === i && (i = !1);
                        for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                            var r = s[n],
                                o = e[r];
                            !i && r in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[r] = o : "function" == typeof o.clone ? t[r] = o.clone() : Object.defineProperty(t, r, o))
                        }
                    },
                    mixin: function(t, e) {
                        if (!t || "object" != typeof t) return e;
                        for (var s in t) {
                            var n = t[s];
                            if (!n.childNodes && !n.cloneNode) {
                                var r = typeof t[s];
                                t[s] && "object" === r ? typeof e[s] === r ? e[s] = i.Utils.mixin(t[s], e[s]) : e[s] = i.Utils.mixin(t[s], new n.constructor) : e[s] = t[s]
                            }
                        }
                        return e
                    }
                }, i.Circle = function(t, e, s) {
                    t = t || 0, e = e || 0, s = s || 0, this.x = t, this.y = e, this._diameter = s, this._radius = 0, s > 0 && (this._radius = .5 * s), this.type = i.CIRCLE
                }, i.Circle.prototype = {
                    circumference: function() {
                        return Math.PI * this._radius * 2
                    },
                    random: function(t) {
                        void 0 === t && (t = new i.Point);
                        var e = 2 * Math.PI * Math.random(),
                            s = Math.random() + Math.random(),
                            n = s > 1 ? 2 - s : s,
                            r = n * Math.cos(e),
                            o = n * Math.sin(e);
                        return t.x = this.x + r * this.radius, t.y = this.y + o * this.radius, t
                    },
                    getBounds: function() {
                        return new i.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                    },
                    setTo: function(t, e, i) {
                        return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.diameter)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                    },
                    distance: function(t, e) {
                        var s = i.Math.distance(this.x, this.y, t.x, t.y);
                        return e ? Math.round(s) : s
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new i.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                    },
                    contains: function(t, e) {
                        return i.Circle.contains(this, t, e)
                    },
                    circumferencePoint: function(t, e, s) {
                        return i.Circle.circumferencePoint(this, t, e, s)
                    },
                    sample: function(t, e, s, n, r) {
                        t || (t = 60), null == e && (e = 0), null == s && (s = i.Math.PI2), r || (r = []);
                        for (var o = 0; o < t;) this.circumferencePoint(i.Math.linear(e, s, o / t), n, r[o] || (r[o] = new i.Point)), o += 1;
                        return r
                    },
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    toString: function() {
                        return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                    }
                }, i.Circle.prototype.constructor = i.Circle, Object.defineProperty(i.Circle.prototype, "diameter", {
                    get: function() {
                        return this._diameter
                    },
                    set: function(t) {
                        t > 0 && (this._diameter = t, this._radius = .5 * t)
                    }
                }), Object.defineProperty(i.Circle.prototype, "radius", {
                    get: function() {
                        return this._radius
                    },
                    set: function(t) {
                        t > 0 && (this._radius = t, this._diameter = 2 * t)
                    }
                }), Object.defineProperty(i.Circle.prototype, "left", {
                    get: function() {
                        return this.x - this._radius
                    },
                    set: function(t) {
                        t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                    }
                }), Object.defineProperty(i.Circle.prototype, "right", {
                    get: function() {
                        return this.x + this._radius
                    },
                    set: function(t) {
                        t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                    }
                }), Object.defineProperty(i.Circle.prototype, "top", {
                    get: function() {
                        return this.y - this._radius
                    },
                    set: function(t) {
                        t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                    }
                }), Object.defineProperty(i.Circle.prototype, "bottom", {
                    get: function() {
                        return this.y + this._radius
                    },
                    set: function(t) {
                        t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                    }
                }), Object.defineProperty(i.Circle.prototype, "area", {
                    get: function() {
                        return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                    }
                }), Object.defineProperty(i.Circle.prototype, "empty", {
                    get: function() {
                        return 0 === this._diameter
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0)
                    }
                }), i.Circle.contains = function(t, e, i) {
                    return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
                }, i.Circle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.diameter === e.diameter
                }, i.Circle.intersects = function(t, e) {
                    return i.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
                }, i.Circle.circumferencePoint = function(t, e, s, n) {
                    return void 0 === s && (s = !1), void 0 === n && (n = new i.Point), !0 === s && (e = i.Math.degToRad(e)), n.x = t.x + t.radius * Math.cos(e), n.y = t.y + t.radius * Math.sin(e), n
                }, i.Circle.intersectsRectangle = function(t, e) {
                    var i = Math.abs(t.x - e.x - e.halfWidth);
                    if (i > e.halfWidth + t.radius) return !1;
                    var s = Math.abs(t.y - e.y - e.halfHeight);
                    if (s > e.halfHeight + t.radius) return !1;
                    if (i <= e.halfWidth || s <= e.halfHeight) return !0;
                    var n = i - e.halfWidth,
                        r = s - e.halfHeight;
                    return n * n + r * r <= t.radius * t.radius
                }, i.Circle.intersectsLine = function(t, e, s) {
                    var n = t.x,
                        r = t.y,
                        o = (e.end.y - e.start.y) / (e.end.x - e.start.x),
                        a = e.end.y - o * e.end.x,
                        h = t.radius,
                        u = t.radius,
                        l = a + o * n,
                        c = (n * (u * u) - o * (h * h) * (a - r) + h * u * Math.sqrt(h * h * (o * o) + u * u - l * l - r * r + 2 * l * r)) / (h * h * (o * o) + u * u),
                        d = (n * (u * u) - o * (h * h) * (a - r) - h * u * Math.sqrt(h * h * (o * o) + u * u - l * l - r * r + 2 * l * r)) / (h * h * (o * o) + u * u),
                        p = o * c + a,
                        f = o * d + a,
                        g = new i.Point(c, p),
                        m = new i.Point(d, f),
                        y = e.pointOnSegment(g.x, g.y, .01),
                        v = e.pointOnSegment(m.x, m.y, .01);
                    return y && v ? !s || [g, m] : y ? !s || [g] : v ? !s || [m] : !!s && []
                }, PIXI.Circle = i.Circle, i.Ellipse = function(t, e, s, n) {
                    t = t || 0, e = e || 0, s = s || 0, n = n || 0, this.x = t, this.y = e, this.width = s, this.height = n, this.type = i.ELLIPSE
                }, i.Ellipse.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    getBounds: function() {
                        return new i.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new i.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                    },
                    contains: function(t, e) {
                        return i.Ellipse.contains(this, t, e)
                    },
                    random: function(t) {
                        void 0 === t && (t = new i.Point);
                        var e = Math.random() * Math.PI * 2,
                            s = Math.random();
                        return t.x = Math.sqrt(s) * Math.cos(e), t.y = Math.sqrt(s) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
                    },
                    toString: function() {
                        return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                    }
                }, i.Ellipse.prototype.constructor = i.Ellipse, Object.defineProperty(i.Ellipse.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                }), Object.defineProperty(i.Ellipse.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t < this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(i.Ellipse.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }), Object.defineProperty(i.Ellipse.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t < this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(i.Ellipse.prototype, "empty", {
                    get: function() {
                        return 0 === this.width || 0 === this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), i.Ellipse.contains = function(t, e, i) {
                    if (t.width <= 0 || t.height <= 0) return !1;
                    var s = (e - t.x) / t.width - .5,
                        n = (i - t.y) / t.height - .5;
                    return s *= s, n *= n, s + n < .25
                }, i.Ellipse.intersectsLine = function(t, e, s) {
                    var n = t.x,
                        r = t.y,
                        o = (e.end.y - e.start.y) / (e.end.x - e.start.x),
                        a = e.end.y - o * e.end.x,
                        h = t.width / 2,
                        u = t.height / 2,
                        l = a + o * n,
                        c = (n * (u * u) - o * (h * h) * (a - r) + h * u * Math.sqrt(h * h * (o * o) + u * u - l * l - r * r + 2 * l * r)) / (h * h * (o * o) + u * u),
                        d = (n * (u * u) - o * (h * h) * (a - r) - h * u * Math.sqrt(h * h * (o * o) + u * u - l * l - r * r + 2 * l * r)) / (h * h * (o * o) + u * u),
                        p = o * c + a,
                        f = o * d + a,
                        g = new i.Point(c, p),
                        m = new i.Point(d, f),
                        y = e.pointOnSegment(g.x, g.y, .01),
                        v = e.pointOnSegment(m.x, m.y, .01);
                    return y && v ? !s || [g, m] : y ? !s || [g] : v ? !s || [m] : !!s && []
                }, PIXI.Ellipse = i.Ellipse, i.Line = function(t, e, s, n) {
                    t = t || 0, e = e || 0, s = s || 0, n = n || 0, this.start = new i.Point(t, e), this.end = new i.Point(s, n), this.type = i.LINE
                }, i.Line.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(i, s), this
                    },
                    fromPoints: function(t, e) {
                        return this.setTo(t.x, t.y, e.x, e.y), this
                    },
                    fromSprite: function(t, e, i) {
                        return void 0 === i && (i = !1), i ? this.setTo(t.centerX, t.centerY, e.centerX, e.centerY) : this.fromPoints(t, e)
                    },
                    fromAngle: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
                    },
                    rotate: function(t, e) {
                        var i = (this.start.x + this.end.x) / 2,
                            s = (this.start.y + this.end.y) / 2;
                        return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
                    },
                    rotateAround: function(t, e, i, s) {
                        return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
                    },
                    intersects: function(t, e, s) {
                        return i.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, s)
                    },
                    reflect: function(t) {
                        return i.Line.reflect(this, t)
                    },
                    midPoint: function(t) {
                        return void 0 === t && (t = new i.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
                    },
                    centerOn: function(t, e) {
                        var i = t - (this.start.x + this.end.x) / 2,
                            s = e - (this.start.y + this.end.y) / 2;
                        this.start.add(i, s), this.end.add(i, s)
                    },
                    pointOnLine: function(t, e, s) {
                        return i.Math.fuzzyEqual((t - this.start.x) * (this.end.y - this.start.y), (this.end.x - this.start.x) * (e - this.start.y), s || 0)
                    },
                    pointOnSegment: function(t, e, i) {
                        var s = Math.min(this.start.x, this.end.x),
                            n = Math.max(this.start.x, this.end.x),
                            r = Math.min(this.start.y, this.end.y),
                            o = Math.max(this.start.y, this.end.y);
                        return this.pointOnLine(t, e, i) && t >= s && t <= n && e >= r && e <= o
                    },
                    random: function(t) {
                        void 0 === t && (t = new i.Point);
                        var e = Math.random();
                        return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
                    },
                    coordinatesOnLine: function(t, e) {
                        void 0 === t && (t = 1), void 0 === e && (e = []);
                        var i = Math.round(this.start.x),
                            s = Math.round(this.start.y),
                            n = Math.round(this.end.x),
                            r = Math.round(this.end.y),
                            o = Math.abs(n - i),
                            a = Math.abs(r - s),
                            h = i < n ? 1 : -1,
                            u = s < r ? 1 : -1,
                            l = o - a;
                        e.push([i, s]);
                        for (var c = 1; i !== n || s !== r;) {
                            var d = l << 1;
                            d > -a && (l -= a, i += h), d < o && (l += o, s += u), c % t == 0 && e.push([i, s]), c++
                        }
                        return e
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new i.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
                    }
                }, Object.defineProperty(i.Line.prototype, "length", {
                    get: function() {
                        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                    }
                }), Object.defineProperty(i.Line.prototype, "angle", {
                    get: function() {
                        return i.Point.angle(this.end, this.start)
                    }
                }), Object.defineProperty(i.Line.prototype, "slope", {
                    get: function() {
                        return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                    }
                }), Object.defineProperty(i.Line.prototype, "perpSlope", {
                    get: function() {
                        return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                    }
                }), Object.defineProperty(i.Line.prototype, "x", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(i.Line.prototype, "y", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(i.Line.prototype, "left", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(i.Line.prototype, "right", {
                    get: function() {
                        return Math.max(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(i.Line.prototype, "top", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(i.Line.prototype, "bottom", {
                    get: function() {
                        return Math.max(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(i.Line.prototype, "width", {
                    get: function() {
                        return Math.abs(this.start.x - this.end.x)
                    }
                }), Object.defineProperty(i.Line.prototype, "height", {
                    get: function() {
                        return Math.abs(this.start.y - this.end.y)
                    }
                }), Object.defineProperty(i.Line.prototype, "normalX", {
                    get: function() {
                        return Math.cos(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(i.Line.prototype, "normalY", {
                    get: function() {
                        return Math.sin(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(i.Line.prototype, "normalAngle", {
                    get: function() {
                        return i.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                    }
                }), i.Line.intersectsPoints = function(t, e, s, n, r, o) {
                    void 0 === r && (r = !0), void 0 === o && (o = new i.Point);
                    var a = e.y - t.y,
                        h = n.y - s.y,
                        u = t.x - e.x,
                        l = s.x - n.x,
                        c = e.x * t.y - t.x * e.y,
                        d = n.x * s.y - s.x * n.y,
                        p = a * l - h * u;
                    if (0 === p) return null;
                    if (o.x = (u * d - l * c) / p, o.y = (h * c - a * d) / p, r) {
                        var f = (n.y - s.y) * (e.x - t.x) - (n.x - s.x) * (e.y - t.y),
                            g = ((n.x - s.x) * (t.y - s.y) - (n.y - s.y) * (t.x - s.x)) / f,
                            m = ((e.x - t.x) * (t.y - s.y) - (e.y - t.y) * (t.x - s.x)) / f;
                        return g >= 0 && g <= 1 && m >= 0 && m <= 1 ? o : null
                    }
                    return o
                }, i.Line.intersects = function(t, e, s, n) {
                    return i.Line.intersectsPoints(t.start, t.end, e.start, e.end, s, n)
                }, i.Line.intersectsRectangle = function(t, e) {
                    if (0 === t.length || e.empty) return !1;
                    var i = t.start.x,
                        s = t.start.y,
                        n = t.end.x,
                        r = t.end.y,
                        o = e.x,
                        a = e.y,
                        h = e.right,
                        u = e.bottom,
                        l = 0;
                    if (i >= o && i <= h && s >= a && s <= u || n >= o && n <= h && r >= a && r <= u) return !0;
                    if (i < o && n >= o) {
                        if ((l = s + (r - s) * (o - i) / (n - i)) > a && l <= u) return !0
                    } else if (i > h && n <= h && (l = s + (r - s) * (h - i) / (n - i)) >= a && l <= u) return !0;
                    if (s < a && r >= a) {
                        if ((l = i + (n - i) * (a - s) / (r - s)) >= o && l <= h) return !0
                    } else if (s > u && r <= u && (l = i + (n - i) * (u - s) / (r - s)) >= o && l <= h) return !0;
                    return !1
                }, i.Line.intersectionWithRectangle = function(t, e, s) {
                    var n = i.Line.intersectionWithRectangle;
                    s || (s = new i.Point), n.edges || (n.edges = [new i.Line, new i.Line, new i.Line, new i.Line]), n.edgeIntersection || (n.edgeIntersection = new i.Point);
                    var r = n.edges,
                        o = n.edgeIntersection.set(0),
                        a = e.x,
                        h = e.y,
                        u = e.right,
                        l = e.bottom,
                        c = 1 / 0;
                    r[0].setTo(a, h, u, h), r[1].setTo(a, l, u, l), r[2].setTo(a, h, a, l), r[3].setTo(u, h, u, l);
                    for (var d, p = 0; d = r[p]; p++)
                        if (t.intersects(d, !0, o)) {
                            var f = t.start.distance(o);
                            f < c && (c = f, s.copyFrom(o))
                        }
                    return null != f ? s : null
                }, i.Line.reflect = function(t, e) {
                    return 2 * e.normalAngle - 3.141592653589793 - t.angle
                }, i.Matrix = function(t, e, s, n, r, o) {
                    void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== s && null !== s || (s = 0), void 0 !== n && null !== n || (n = 1), void 0 !== r && null !== r || (r = 0), void 0 !== o && null !== o || (o = 0), this.a = t, this.b = e, this.c = s, this.d = n, this.tx = r, this.ty = o, this.type = i.MATRIX
                }, i.Matrix.prototype = {
                    fromArray: function(t) {
                        return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                    },
                    setTo: function(t, e, i, s, n, r) {
                        return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = r, this
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new i.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
                    },
                    copyTo: function(t) {
                        return t.copyFrom(this), t
                    },
                    copyFrom: function(t) {
                        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                    },
                    toArray: function(t, e) {
                        return void 0 === e && (e = new Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
                    },
                    apply: function(t, e) {
                        return void 0 === e && (e = new i.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
                    },
                    applyInverse: function(t, e) {
                        void 0 === e && (e = new i.Point);
                        var s = 1 / (this.a * this.d + this.c * -this.b),
                            n = t.x,
                            r = t.y;
                        return e.x = this.d * s * n + -this.c * s * r + (this.ty * this.c - this.tx * this.d) * s, e.y = this.a * s * r + -this.b * s * n + (-this.ty * this.a + this.tx * this.b) * s, e
                    },
                    translate: function(t, e) {
                        return this.tx += t, this.ty += e, this
                    },
                    scale: function(t, e) {
                        return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                    },
                    rotate: function(t) {
                        var e = Math.cos(t),
                            i = Math.sin(t),
                            s = this.a,
                            n = this.c,
                            r = this.tx;
                        return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = r * e - this.ty * i, this.ty = r * i + this.ty * e, this
                    },
                    append: function(t) {
                        var e = this.a,
                            i = this.b,
                            s = this.c,
                            n = this.d;
                        return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
                    },
                    identity: function() {
                        return this.setTo(1, 0, 0, 1, 0, 0)
                    }
                }, i.identityMatrix = new i.Matrix, i.Point = function(t, e) {
                    t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = i.POINT
                }, i.Point.prototype = {
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y)
                    },
                    invert: function() {
                        return this.setTo(this.y, this.x)
                    },
                    setTo: function(t, e) {
                        return i.Point.set(this, t, e)
                    },
                    set: function(t, e) {
                        return i.Point.set(this, t, e)
                    },
                    setToPolar: function(t, e, s) {
                        return null == e && (e = 1), s && (t = i.Math.degToRad(t)), this.setTo(Math.cos(t) * e, Math.sin(t) * e)
                    },
                    add: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    subtract: function(t, e) {
                        return this.x -= t, this.y -= e, this
                    },
                    multiply: function(t, e) {
                        return this.x *= t, this.y *= e, this
                    },
                    divide: function(t, e) {
                        return this.x /= t, this.y /= e, this
                    },
                    clampX: function(t, e) {
                        return this.x = i.Math.clamp(this.x, t, e), this
                    },
                    clampY: function(t, e) {
                        return this.y = i.Math.clamp(this.y, t, e), this
                    },
                    clamp: function(t, e) {
                        return this.x = i.Math.clamp(this.x, t, e), this.y = i.Math.clamp(this.y, t, e), this
                    },
                    clip: function(t) {
                        var e = t.left,
                            i = t.top,
                            s = t.right,
                            n = t.bottom;
                        return this.x < e ? this.x = e : this.x > s && (this.x = s), this.y < i ? this.y = i : this.y > n && (this.y = n), this
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new i.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t
                    },
                    distance: function(t, e) {
                        return i.Point.distance(this, t, e)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y
                    },
                    equalsXY: function(t, e) {
                        return this.x === t && this.y === e
                    },
                    fuzzyEquals: function(t, e) {
                        return i.Point.fuzzyEquals(this, t, e)
                    },
                    fuzzyEqualsXY: function(t, e, s) {
                        return i.Point.fuzzyEqualsXY(this, t, e, s)
                    },
                    angle: function(t, e) {
                        return this.angleXY(t.x, t.y, e)
                    },
                    angleXY: function(t, e, s) {
                        var n = Math.atan2(e - this.y, t - this.x);
                        return s ? i.Math.radToDeg(n) : n
                    },
                    atan: function(t) {
                        var e = Math.atan2(this.y, this.x);
                        return t ? i.Math.radToDeg(e) : e
                    },
                    rotate: function(t, e, s, n, r) {
                        return i.Point.rotate(this, t, e, s, n, r)
                    },
                    getMagnitude: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    getMagnitudeSq: function() {
                        return this.x * this.x + this.y * this.y
                    },
                    setMagnitude: function(t) {
                        return this.normalize().multiply(t, t)
                    },
                    normalize: function() {
                        if (!this.isZero()) {
                            var t = this.getMagnitude();
                            this.x /= t, this.y /= t
                        }
                        return this
                    },
                    limit: function(t) {
                        return this.getMagnitudeSq() > t * t && this.setMagnitude(t), this
                    },
                    expand: function(t) {
                        return this.getMagnitudeSq() < t * t && this.setMagnitude(t), this
                    },
                    isZero: function() {
                        return 0 === this.x && 0 === this.y
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y
                    },
                    cross: function(t) {
                        return this.x * t.y - this.y * t.x
                    },
                    perp: function() {
                        return this.setTo(-this.y, this.x)
                    },
                    rperp: function() {
                        return this.setTo(this.y, -this.x)
                    },
                    normalRightHand: function() {
                        return this.setTo(-1 * this.y, this.x)
                    },
                    floor: function() {
                        return this.setTo(Math.floor(this.x), Math.floor(this.y))
                    },
                    ceil: function() {
                        return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                    },
                    round: function() {
                        return this.setTo(Math.round(this.x), Math.round(this.y))
                    },
                    toString: function() {
                        return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                    }
                }, i.Point.prototype.constructor = i.Point, i.Point.add = function(t, e, s) {
                    return void 0 === s && (s = new i.Point), s.x = t.x + e.x, s.y = t.y + e.y, s
                }, i.Point.subtract = function(t, e, s) {
                    return void 0 === s && (s = new i.Point), s.x = t.x - e.x, s.y = t.y - e.y, s
                }, i.Point.multiply = function(t, e, s) {
                    return void 0 === s && (s = new i.Point), s.x = t.x * e.x, s.y = t.y * e.y, s
                }, i.Point.divide = function(t, e, s) {
                    return void 0 === s && (s = new i.Point), s.x = t.x / e.x, s.y = t.y / e.y, s
                }, i.Point.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, i.Point.equalsXY = function(t, e, i) {
                    return t.x === e && t.y === i
                }, i.Point.fuzzyEquals = function(t, e, s) {
                    return i.Math.fuzzyEquals(t.x, e.x, s) && i.Math.fuzzyEquals(t.y, e.y, s)
                }, i.Point.fuzzyEqualsXY = function(t, e, s, n) {
                    return i.Math.fuzzyEquals(t.x, e, n) && i.Math.fuzzyEquals(t.y, s, n)
                }, i.Point.angle = function(t, e) {
                    return Math.atan2(t.y - e.y, t.x - e.x)
                }, i.Point.negative = function(t, e) {
                    return void 0 === e && (e = new i.Point), e.setTo(-t.x, -t.y)
                }, i.Point.multiplyAdd = function(t, e, s, n) {
                    return void 0 === n && (n = new i.Point), n.setTo(t.x + e.x * s, t.y + e.y * s)
                }, i.Point.interpolate = function(t, e, s, n) {
                    return void 0 === n && (n = new i.Point), n.setTo(t.x + (e.x - t.x) * s, t.y + (e.y - t.y) * s)
                }, i.Point.perp = function(t, e) {
                    return void 0 === e && (e = new i.Point), e.setTo(-t.y, t.x)
                }, i.Point.rperp = function(t, e) {
                    return void 0 === e && (e = new i.Point), e.setTo(t.y, -t.x)
                }, i.Point.distance = function(t, e, s) {
                    var n = i.Math.distance(t.x, t.y, e.x, e.y);
                    return s ? Math.round(n) : n
                }, i.Point.project = function(t, e, s) {
                    void 0 === s && (s = new i.Point);
                    var n = t.dot(e) / e.getMagnitudeSq();
                    return 0 !== n && s.setTo(n * e.x, n * e.y), s
                }, i.Point.projectUnit = function(t, e, s) {
                    void 0 === s && (s = new i.Point);
                    var n = t.dot(e);
                    return 0 !== n && s.setTo(n * e.x, n * e.y), s
                }, i.Point.normalRightHand = function(t, e) {
                    return void 0 === e && (e = new i.Point), e.setTo(-1 * t.y, t.x)
                }, i.Point.normalize = function(t, e) {
                    void 0 === e && (e = new i.Point);
                    var s = t.getMagnitude();
                    return 0 !== s && e.setTo(t.x / s, t.y / s), e
                }, i.Point.rotate = function(t, e, s, n, r, o) {
                    if (r && (n = i.Math.degToRad(n)), void 0 === o) {
                        t.subtract(e, s);
                        var a = Math.sin(n),
                            h = Math.cos(n),
                            u = h * t.x - a * t.y,
                            l = a * t.x + h * t.y;
                        t.x = u + e, t.y = l + s
                    } else {
                        var c = n + Math.atan2(t.y - s, t.x - e);
                        t.x = e + o * Math.cos(c), t.y = s + o * Math.sin(c)
                    }
                    return t
                }, i.Point.centroid = function(t, e) {
                    if (void 0 === e && (e = new i.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                    var s = t.length;
                    if (s < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                    if (1 === s) return e.copyFrom(t[0]), e;
                    for (var n = 0; n < s; n++) i.Point.add(e, t[n], e);
                    return e.divide(s, s), e
                }, i.Point.parse = function(t, e, s) {
                    e = e || "x", s = s || "y";
                    var n = new i.Point;
                    return t[e] && (n.x = parseInt(t[e], 10)), t[s] && (n.y = parseInt(t[s], 10)), n
                }, i.Point.isPoint = function(t) {
                    return null != t && "number" == typeof t.x && "number" == typeof t.y
                }, i.Point.set = function(t, e, i) {
                    return t.x = e || 0, t.y = i || (0 !== i ? t.x : 0), t
                }, i.Point.sortClockwise = function(t, e) {
                    e || (e = this.centroid(t));
                    var i = e.x,
                        s = e.y;
                    return t.sort(function(t, e) {
                        if (t.x - i >= 0 && e.x - i < 0) return -1;
                        if (t.x - i < 0 && e.x - i >= 0) return 1;
                        if (t.x - i == 0 && e.x - i == 0) return t.y - s >= 0 || e.y - s >= 0 ? t.y > e.y ? 1 : -1 : e.y > t.y ? 1 : -1;
                        var n = (t.x - i) * -(e.y - s) - (e.x - i) * -(t.y - s);
                        return n < 0 ? -1 : n > 0 ? 1 : (t.x - i) * (t.x - i) + (t.y - s) * (t.y - s) > (e.x - i) * (e.x - i) + (e.y - s) * (e.y - s) ? -1 : 1
                    })
                }, PIXI.Point = i.Point, i.Polygon = function() {
                    this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = i.POLYGON
                }, i.Polygon.prototype = {
                    toNumberArray: function(t) {
                        void 0 === t && (t = []);
                        for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                        return t
                    },
                    flatten: function() {
                        return this._points = this.toNumberArray(), this.flattened = !0, this
                    },
                    clone: function(t) {
                        var e = this._points.slice();
                        return void 0 === t || null === t ? t = new i.Polygon(e) : t.setTo(e), t
                    },
                    contains: function(t, e) {
                        var i = !1;
                        if (this.flattened)
                            for (var s = -2, n = this._points.length - 2;
                                (s += 2) < this._points.length; n = s) {
                                var r = this._points[s],
                                    o = this._points[s + 1],
                                    a = this._points[n],
                                    h = this._points[n + 1];
                                (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                            } else
                                for (var s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                                    var r = this._points[s].x,
                                        o = this._points[s].y,
                                        a = this._points[n].x,
                                        h = this._points[n].y;
                                    (o <= e && e < h || h <= e && e < o) && t < (a - r) * (e - o) / (h - o) + r && (i = !i)
                                }
                        return i
                    },
                    setTo: function(t) {
                        if (this.area = 0, this._points = [], arguments.length > 0) {
                            Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                            for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                                if ("number" == typeof t[i]) {
                                    n = new PIXI.Point(t[i], t[i + 1]);
                                    i++
                                } else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]);
                                else var n = new PIXI.Point(t[i].x, t[i].y);
                                this._points.push(n), n.y < e && (e = n.y)
                            }
                            this.calculateArea(e)
                        }
                        return this
                    },
                    calculateArea: function(t) {
                        for (var e, i, s, n, r = 0, o = this._points.length; r < o; r++) e = this._points[r], i = r === o - 1 ? this._points[0] : this._points[r + 1], s = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += s * n;
                        return this.area
                    }
                }, i.Polygon.prototype.constructor = i.Polygon, Object.defineProperty(i.Polygon.prototype, "points", {
                    get: function() {
                        return this._points
                    }
                }), PIXI.Polygon = i.Polygon, i.Rectangle = function(t, e, s, n) {
                    t = t || 0, e = e || 0, s = s || 0, n = n || 0, this.x = t, this.y = e, this.width = s, this.height = n, this.type = i.RECTANGLE
                }, i.Rectangle.prototype = {
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    scale: function(t, e) {
                        return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                    },
                    centerOn: function(t, e) {
                        return this.centerX = t, this.centerY = e, this
                    },
                    floor: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                    },
                    floorAll: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                    },
                    ceil: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                    },
                    ceilAll: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyFromBounds: function(t) {
                        return this.setTo(t.left, t.top, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    inflate: function(t, e) {
                        return i.Rectangle.inflate(this, t, e)
                    },
                    size: function(t) {
                        return i.Rectangle.size(this, t)
                    },
                    resize: function(t, e) {
                        return this.width = t, this.height = e, this
                    },
                    clone: function(t) {
                        return i.Rectangle.clone(this, t)
                    },
                    contains: function(t, e) {
                        return i.Rectangle.contains(this, t, e)
                    },
                    containsRect: function(t) {
                        return i.Rectangle.containsRect(t, this)
                    },
                    equals: function(t) {
                        return i.Rectangle.equals(this, t)
                    },
                    intersection: function(t, e) {
                        return i.Rectangle.intersection(this, t, e)
                    },
                    intersects: function(t) {
                        return i.Rectangle.intersects(this, t)
                    },
                    intersectsRaw: function(t, e, s, n, r) {
                        return i.Rectangle.intersectsRaw(this, t, e, s, n, r)
                    },
                    union: function(t, e) {
                        return i.Rectangle.union(this, t, e)
                    },
                    random: function(t) {
                        return void 0 === t && (t = new i.Point), t.x = this.randomX, t.y = this.randomY, t
                    },
                    getPoint: function(t, e) {
                        switch (void 0 === e && (e = new i.Point), t) {
                            default:
                                case i.TOP_LEFT:
                                return e.set(this.x, this.y);
                            case i.TOP_CENTER:
                                    return e.set(this.centerX, this.y);
                            case i.TOP_RIGHT:
                                    return e.set(this.right, this.y);
                            case i.LEFT_CENTER:
                                    return e.set(this.x, this.centerY);
                            case i.CENTER:
                                    return e.set(this.centerX, this.centerY);
                            case i.RIGHT_CENTER:
                                    return e.set(this.right, this.centerY);
                            case i.BOTTOM_LEFT:
                                    return e.set(this.x, this.bottom);
                            case i.BOTTOM_CENTER:
                                    return e.set(this.centerX, this.bottom);
                            case i.BOTTOM_RIGHT:
                                    return e.set(this.right, this.bottom)
                        }
                    },
                    sides: function(t, e, s, n) {
                        arguments.length || (t = new i.Line, e = new i.Line, s = new i.Line, n = new i.Line);
                        var r = this.x,
                            o = this.y,
                            a = this.right,
                            h = this.bottom;
                        return t.setTo(r, o, a, o), e.setTo(a, o, a, h), s.setTo(r, h, a, h), n.setTo(r, o, r, h), arguments.length ? null : [t, e, s, n]
                    },
                    toString: function() {
                        return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                    }
                }, Object.defineProperty(i.Rectangle.prototype, "halfWidth", {
                    get: function() {
                        return Math.round(this.width / 2)
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "halfHeight", {
                    get: function() {
                        return Math.round(this.height / 2)
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t <= this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "bottomLeft", {
                    get: function() {
                        return new i.Point(this.x, this.bottom)
                    },
                    set: function(t) {
                        this.x = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "bottomRight", {
                    get: function() {
                        return new i.Point(this.right, this.bottom)
                    },
                    set: function(t) {
                        this.right = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t <= this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "volume", {
                    get: function() {
                        return this.width * this.height
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "perimeter", {
                    get: function() {
                        return 2 * this.width + 2 * this.height
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "centerX", {
                    get: function() {
                        return this.x + this.halfWidth
                    },
                    set: function(t) {
                        this.x = t - this.halfWidth
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "centerY", {
                    get: function() {
                        return this.y + this.halfHeight
                    },
                    set: function(t) {
                        this.y = t - this.halfHeight
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "randomX", {
                    get: function() {
                        return this.x + Math.random() * this.width
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "randomY", {
                    get: function() {
                        return this.y + Math.random() * this.height
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "topLeft", {
                    get: function() {
                        return new i.Point(this.x, this.y)
                    },
                    set: function(t) {
                        this.x = t.x, this.y = t.y
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "topRight", {
                    get: function() {
                        return new i.Point(this.x + this.width, this.y)
                    },
                    set: function(t) {
                        this.right = t.x, this.y = t.y
                    }
                }), Object.defineProperty(i.Rectangle.prototype, "empty", {
                    get: function() {
                        return !this.width || !this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), i.Rectangle.prototype.constructor = i.Rectangle, i.Rectangle.inflate = function(t, e, i) {
                    return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
                }, i.Rectangle.inflatePoint = function(t, e) {
                    return i.Rectangle.inflate(t, e.x, e.y)
                }, i.Rectangle.size = function(t, e) {
                    return void 0 === e || null === e ? e = new i.Point(t.width, t.height) : e.setTo(t.width, t.height), e
                }, i.Rectangle.clone = function(t, e) {
                    return void 0 === e || null === e ? e = new i.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
                }, i.Rectangle.createFromBounds = function(t, e) {
                    return void 0 !== e && null !== e || (e = new i.Rectangle(t.x, t.y, t.width, t.height)), e.copyFromBounds(t)
                }, i.Rectangle.contains = function(t, e, i) {
                    return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
                }, i.Rectangle.containsRaw = function(t, e, i, s, n, r) {
                    return n >= t && n < t + i && r >= e && r < e + s
                }, i.Rectangle.containsPoint = function(t, e) {
                    return i.Rectangle.contains(t, e.x, e.y)
                }, i.Rectangle.containsRect = function(t, e) {
                    return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
                }, i.Rectangle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
                }, i.Rectangle.sameDimensions = function(t, e) {
                    return t.width === e.width && t.height === e.height
                }, i.Rectangle.intersection = function(t, e, s) {
                    return void 0 === s && (s = new i.Rectangle), i.Rectangle.intersects(t, e) && (s.x = Math.max(t.x, e.x), s.y = Math.max(t.y, e.y), s.width = Math.min(t.right, e.right) - s.x, s.height = Math.min(t.bottom, e.bottom) - s.y), s
                }, i.Rectangle.intersects = function(t, e) {
                    return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
                }, i.Rectangle.intersectsRaw = function(t, e, i, s, n, r) {
                    return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r)
                }, i.Rectangle.union = function(t, e, s) {
                    return void 0 === s && (s = new i.Rectangle), s.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
                }, i.Rectangle.aabb = function(t, e) {
                    void 0 === e && (e = new i.Rectangle);
                    var s = Number.NEGATIVE_INFINITY,
                        n = Number.POSITIVE_INFINITY,
                        r = Number.NEGATIVE_INFINITY,
                        o = Number.POSITIVE_INFINITY;
                    return t.forEach(function(t) {
                        t.x > s && (s = t.x), t.x < n && (n = t.x), t.y > r && (r = t.y), t.y < o && (o = t.y)
                    }), e.setTo(n, o, s - n, r - o), e
                }, PIXI.Rectangle = i.Rectangle, PIXI.EmptyRectangle = new i.Rectangle(0, 0, 0, 0), i.RoundedRectangle = function(t, e, s, n, r) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 20), this.x = t, this.y = e, this.width = s, this.height = n, this.radius = r || 20, this.type = i.ROUNDEDRECTANGLE
                }, i.RoundedRectangle.prototype = {
                    clone: function() {
                        return new i.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                    },
                    contains: function(t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = this.x;
                        if (t >= i && t <= i + this.width) {
                            var s = this.y;
                            if (e >= s && e <= s + this.height) return !0
                        }
                        return !1
                    }
                }, i.RoundedRectangle.prototype.constructor = i.RoundedRectangle, PIXI.RoundedRectangle = i.RoundedRectangle, i.Camera = function(t, e, s, n, r, o) {
                    this.game = t, this.world = t.world, this.id = 0, this.view = new i.Rectangle(s, n, r, o), this.bounds = new i.Rectangle(s, n, r, o), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                        x: !1,
                        y: !1
                    }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new i.Point(1, 1), this.onShakeComplete = new i.Signal, this.onFlashComplete = new i.Signal, this.onFadeComplete = new i.Signal, this.fx = null, this._targetPosition = new i.Point, this._edge = 0, this._position = new i.Point, this._shake = {
                        intensity: 0,
                        duration: 0,
                        horizontal: !1,
                        vertical: !1,
                        shakeBounds: !0,
                        x: 0,
                        y: 0
                    }, this._fxDuration = 0, this._fxType = 0, this._fixedView = new i.Rectangle
                }, i.Camera.FOLLOW_LOCKON = 0, i.Camera.FOLLOW_PLATFORMER = 1, i.Camera.FOLLOW_TOPDOWN = 2, i.Camera.FOLLOW_TOPDOWN_TIGHT = 3, i.Camera.SHAKE_BOTH = 4, i.Camera.SHAKE_HORIZONTAL = 5, i.Camera.SHAKE_VERTICAL = 6, i.Camera.ENABLE_FX = !0, i.Camera.prototype = {
                    boot: function() {
                        this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, i.Graphics && i.Camera.ENABLE_FX && (this.fx = new i.Graphics(this.game), this.game.stage.addChild(this.fx))
                    },
                    preUpdate: function() {
                        this.totalInView = 0
                    },
                    follow: function(t, e, s, n) {
                        void 0 === e && (e = i.Camera.FOLLOW_LOCKON), void 0 === s && (s = 1), void 0 === n && (n = 1), this.target = t, this.lerp.set(s, n);
                        var r;
                        switch (e) {
                            case i.Camera.FOLLOW_PLATFORMER:
                                var o = this.width / 8,
                                    a = this.height / 3;
                                this.deadzone = new i.Rectangle((this.width - o) / 2, (this.height - a) / 2 - .25 * a, o, a);
                                break;
                            case i.Camera.FOLLOW_TOPDOWN:
                                r = Math.max(this.width, this.height) / 4, this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                                break;
                            case i.Camera.FOLLOW_TOPDOWN_TIGHT:
                                r = Math.max(this.width, this.height) / 8, this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - r) / 2, r, r);
                                break;
                            case i.Camera.FOLLOW_LOCKON:
                            default:
                                this.deadzone = null
                        }
                    },
                    unfollow: function() {
                        this.target = null
                    },
                    focusOn: function(t) {
                        this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                    },
                    focusOnXY: function(t, e) {
                        this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                    },
                    shake: function(t, e, s, n, r) {
                        return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === s && (s = !0), void 0 === n && (n = i.Camera.SHAKE_BOTH), void 0 === r && (r = !0), !(!s && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = r, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = n === i.Camera.SHAKE_BOTH || n === i.Camera.SHAKE_HORIZONTAL, this._shake.vertical = n === i.Camera.SHAKE_BOTH || n === i.Camera.SHAKE_VERTICAL, !0)
                    },
                    flash: function(t, e, i, s) {
                        return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
                    },
                    fade: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), void 0 === s && (s = 1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t, s), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
                    },
                    update: function() {
                        this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    updateFX: function() {
                        0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                    },
                    updateShake: function() {
                        this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                    },
                    updateTarget: function() {
                        this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    setBoundsToWorld: function() {
                        this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                    },
                    checkBounds: function() {
                        this.atLimit.x = !1, this.atLimit.y = !1;
                        var t = this.view.x + this._shake.x,
                            e = this.view.right + this._shake.x,
                            i = this.view.y + this._shake.y,
                            s = this.view.bottom + this._shake.y;
                        t <= this.bounds.x * this.scale.x ? (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)) : e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y ? (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)) : s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                    },
                    setPosition: function(t, e) {
                        this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                    },
                    setSize: function(t, e) {
                        this.view.width = t, this.view.height = e
                    },
                    reset: function() {
                        this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.resetFX()
                    },
                    resetFX: function() {
                        this.fx && (this.fx.clear(), this.fx.alpha = 0), this._fxDuration = 0
                    }
                }, i.Camera.prototype.constructor = i.Camera, Object.defineProperty(i.Camera.prototype, "x", {
                    get: function() {
                        return this.view.x
                    },
                    set: function(t) {
                        this.view.x = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(i.Camera.prototype, "y", {
                    get: function() {
                        return this.view.y
                    },
                    set: function(t) {
                        this.view.y = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(i.Camera.prototype, "position", {
                    get: function() {
                        return this._position.set(this.view.x, this.view.y), this._position
                    },
                    set: function(t) {
                        void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(i.Camera.prototype, "width", {
                    get: function() {
                        return this.view.width
                    },
                    set: function(t) {
                        this.view.width = t
                    }
                }), Object.defineProperty(i.Camera.prototype, "height", {
                    get: function() {
                        return this.view.height
                    },
                    set: function(t) {
                        this.view.height = t
                    }
                }), Object.defineProperty(i.Camera.prototype, "shakeIntensity", {
                    get: function() {
                        return this._shake.intensity
                    },
                    set: function(t) {
                        this._shake.intensity = t
                    }
                }), Object.defineProperty(i.Camera.prototype, "fixedView", {
                    get: function() {
                        return this._fixedView.setTo(0, 0, this.view.width, this.view.height), this._fixedView
                    }
                }), i.State = function() {
                    this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
                }, i.State.prototype = {
                    init: function() {},
                    preload: function() {},
                    loadUpdate: function() {},
                    loadRender: function() {},
                    create: function() {},
                    update: function() {},
                    preRender: function() {},
                    render: function() {},
                    resize: function() {},
                    paused: function() {},
                    resumed: function() {},
                    pauseUpdate: function() {},
                    shutdown: function() {}
                }, i.State.prototype.constructor = i.State, i.StateManager = function(t, e) {
                    this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new i.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
                }, i.StateManager.prototype = {
                    boot: function() {
                        this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                    },
                    add: function(t, e, s) {
                        void 0 === s && (s = !1);
                        var n;
                        return e instanceof i.State ? n = e : "object" == typeof e ? (n = e).game = this.game : "function" == typeof e && (n = new e(this.game)), this.states[t] = n, s && (this.game.isBooted ? this.start(t) : this._pendingState = t), n
                    },
                    remove: function(t) {
                        this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                    },
                    start: function(t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                    },
                    restart: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
                    },
                    dummy: function() {},
                    preUpdate: function() {
                        if (this._pendingState && this.game.isBooted) {
                            var t = this.current;
                            if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                            this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                        }
                    },
                    clearCurrentState: function() {
                        this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                    },
                    checkState: function(t) {
                        var e = this.states[t];
                        return e ? !!(e.preload || e.create || e.update || e.render) || (console.warn("Invalid Phaser State object given. Must contain at least one of the required functions: preload, create, update or render"), !1) : (console.warn("Phaser.StateManager - No state found with the key: " + t), !1)
                    },
                    link: function(t) {
                        var e = this.states[t];
                        e.game = this.game, e.add = this.game.add, e.make = this.game.make, e.camera = this.game.camera, e.cache = this.game.cache, e.input = this.game.input, e.load = this.game.load, e.math = this.game.math, e.sound = this.game.sound, e.scale = this.game.scale, e.state = this, e.stage = this.game.stage, e.time = this.game.time, e.tweens = this.game.tweens, e.world = this.game.world, e.particles = this.game.particles, e.rnd = this.game.rnd, e.physics = this.game.physics, e.key = t
                    },
                    unlink: function(t) {
                        var e = this.states[t];
                        e && (e.game = null, e.add = null, e.make = null, e.camera = null, e.cache = null, e.input = null, e.load = null, e.math = null, e.sound = null, e.scale = null, e.state = null, e.stage = null, e.time = null, e.tweens = null, e.world = null, e.particles = null, e.rnd = null, e.physics = null)
                    },
                    setCurrentState: function(t) {
                        var e = this.states[t];
                        this.callbackContext = e, this.link(t), this.onInitCallback = e.init || this.dummy, this.onPreloadCallback = e.preload || null, this.onLoadRenderCallback = e.loadRender || null, this.onLoadUpdateCallback = e.loadUpdate || null, this.onCreateCallback = e.create || null, this.onUpdateCallback = e.update || null, this.onPreRenderCallback = e.preRender || null, this.onRenderCallback = e.render || null, this.onResizeCallback = e.resize || null, this.onPausedCallback = e.paused || null, this.onResumedCallback = e.resumed || null, this.onPauseUpdateCallback = e.pauseUpdate || null, this.onShutDownCallback = e.shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                    },
                    getCurrentState: function() {
                        return this.states[this.current]
                    },
                    loadComplete: function() {
                        !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                    },
                    pause: function() {
                        this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                    },
                    resume: function() {
                        this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                    },
                    update: function() {
                        this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    pauseUpdate: function() {
                        this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    preRender: function(t) {
                        this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                    },
                    resize: function(t, e) {
                        this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                    },
                    render: function() {
                        this._created ? this.onRenderCallback && (this.game.renderType === i.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                    },
                    destroy: function() {
                        this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                    }
                }, i.StateManager.prototype.constructor = i.StateManager, Object.defineProperty(i.StateManager.prototype, "created", {
                    get: function() {
                        return this._created
                    }
                }), i.Signal = function() {}, i.Signal.prototype = {
                    _bindings: null,
                    _prevParams: null,
                    memorize: !1,
                    _shouldPropagate: !0,
                    active: !0,
                    _boundDispatch: !1,
                    validateListener: function(t, e) {
                        if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                    },
                    _registerListener: function(t, e, s, n, r) {
                        var o, a = this._indexOfListener(t, s);
                        if (-1 !== a) {
                            if ((o = this._bindings[a]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                        } else o = new i.SignalBinding(this, t, e, s, n, r), this._addBinding(o);
                        return this.memorize && this._prevParams && o.execute(this._prevParams), o
                    },
                    _addBinding: function(t) {
                        this._bindings || (this._bindings = []);
                        var e = this._bindings.length;
                        do {
                            e--
                        } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                        this._bindings.splice(e + 1, 0, t)
                    },
                    _indexOfListener: function(t, e) {
                        if (!this._bindings) return -1;
                        void 0 === e && (e = null);
                        for (var i, s = this._bindings.length; s--;)
                            if ((i = this._bindings[s])._listener === t && i.context === e) return s;
                        return -1
                    },
                    has: function(t, e) {
                        return -1 !== this._indexOfListener(t, e)
                    },
                    add: function(t, e, i) {
                        this.validateListener(t, "add");
                        var s = [];
                        if (arguments.length > 3)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !1, e, i, s)
                    },
                    addOnce: function(t, e, i) {
                        this.validateListener(t, "addOnce");
                        var s = [];
                        if (arguments.length > 3)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !0, e, i, s)
                    },
                    remove: function(t, e) {
                        this.validateListener(t, "remove");
                        var i = this._indexOfListener(t, e);
                        return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                    },
                    removeAll: function(t) {
                        if (void 0 === t && (t = null), this._bindings) {
                            for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                            t || (this._bindings.length = 0)
                        }
                    },
                    getNumListeners: function() {
                        return this._bindings ? this._bindings.length : 0
                    },
                    halt: function() {
                        this._shouldPropagate = !1
                    },
                    dispatch: function() {
                        if (this.active && this._bindings) {
                            var t, e = Array.prototype.slice.call(arguments),
                                i = this._bindings.length;
                            if (this.memorize && (this._prevParams = e), i) {
                                t = this._bindings.slice(), this._shouldPropagate = !0;
                                do {
                                    i--
                                } while (t[i] && this._shouldPropagate && !1 !== t[i].execute(e))
                            }
                        }
                    },
                    forget: function() {
                        this._prevParams && (this._prevParams = null)
                    },
                    dispose: function() {
                        this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                    },
                    toString: function() {
                        return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                    }
                }, Object.defineProperty(i.Signal.prototype, "boundDispatch", {
                    get: function() {
                        var t = this;
                        return this._boundDispatch || (this._boundDispatch = function() {
                            return t.dispatch.apply(t, arguments)
                        })
                    }
                }), i.Signal.prototype.constructor = i.Signal, i.SignalBinding = function(t, e, i, s, n, r) {
                    this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), r && r.length && (this._args = r)
                }, i.SignalBinding.prototype = {
                    context: null,
                    _isOnce: !1,
                    _priority: 0,
                    _args: null,
                    callCount: 0,
                    active: !0,
                    params: null,
                    execute: function(t) {
                        var e, i;
                        return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
                    },
                    detach: function() {
                        return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                    },
                    isBound: function() {
                        return !!this._signal && !!this._listener
                    },
                    isOnce: function() {
                        return this._isOnce
                    },
                    getListener: function() {
                        return this._listener
                    },
                    getSignal: function() {
                        return this._signal
                    },
                    _destroy: function() {
                        delete this._signal, delete this._listener, delete this.context
                    },
                    toString: function() {
                        return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                    }
                }, i.SignalBinding.prototype.constructor = i.SignalBinding, i.Filter = function(t, e, s) {
                    this.game = t, this.type = i.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new i.Point;
                    var n = new Date;
                    if (this.uniforms = {
                            resolution: {
                                type: "2f",
                                value: {
                                    x: 256,
                                    y: 256
                                }
                            },
                            time: {
                                type: "1f",
                                value: 0
                            },
                            mouse: {
                                type: "2f",
                                value: {
                                    x: 0,
                                    y: 0
                                }
                            },
                            date: {
                                type: "4fv",
                                value: [n.getFullYear(), n.getMonth(), n.getDate(), 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds()]
                            },
                            sampleRate: {
                                type: "1f",
                                value: 44100
                            },
                            iChannel0: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel1: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel2: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel3: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            }
                        }, e)
                        for (var r in e) this.uniforms[r] = e[r];
                    "string" == typeof s && (s = s.split("\n")), this.fragmentSrc = s || []
                }, i.Filter.prototype = {
                    init: function() {},
                    setResolution: function(t, e) {
                        this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                    },
                    update: function(t) {
                        if (t) {
                            var e = t.x / this.game.width,
                                i = 1 - t.y / this.game.height;
                            e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                        }
                        this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                    },
                    addToWorld: function(t, e, s, n, r, o) {
                        void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 !== s && null !== s ? this.width = s : s = this.width, void 0 !== n && null !== n ? this.height = n : n = this.height;
                        var a = this.game.add.image(t, e, i.Cache.DEFAULT);
                        return a.width = s, a.height = n, a.anchor.set(r, o), a.filters = [this], a
                    },
                    syncUniforms: function() {
                        for (var t = 0; t < this.shaders.length; t++) this.shaders[t].dirty = !0
                    },
                    destroy: function() {
                        this.passes.length = 0, this.shaders.length = 0, this.fragmentSrc.length = 0, this.game = null, this.uniforms = null, this.prevPoint = null
                    }
                }, i.Filter.prototype.constructor = i.Filter, Object.defineProperty(i.Filter.prototype, "width", {
                    get: function() {
                        return this.uniforms.resolution.value.x
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.x = t
                    }
                }), Object.defineProperty(i.Filter.prototype, "height", {
                    get: function() {
                        return this.uniforms.resolution.value.y
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.y = t
                    }
                }), i.Plugin = function(t, e) {
                    void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
                }, i.Plugin.prototype = {
                    preUpdate: function() {},
                    update: function() {},
                    render: function() {},
                    postRender: function() {},
                    destroy: function() {
                        this.game = null, this.parent = null, this.active = !1, this.visible = !1
                    }
                }, i.Plugin.prototype.constructor = i.Plugin, i.PluginManager = function(t) {
                    this.game = t, this.plugins = [], this._len = 0, this._i = 0
                }, i.PluginManager.prototype = {
                    add: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            i = !1;
                        return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                    },
                    remove: function(t, e) {
                        for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                            if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                    },
                    removeAll: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                        this.plugins.length = 0, this._len = 0
                    },
                    preUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                    },
                    update: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                    },
                    postUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                    },
                    render: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                    },
                    postRender: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                    },
                    destroy: function() {
                        this.removeAll(), this.game = null
                    }
                }, i.PluginManager.prototype.constructor = i.PluginManager, i.Stage = function(t) {
                    this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new i.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                        color: 0,
                        rgba: "#000000"
                    }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
                }, i.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Stage.prototype.constructor = i.Stage, i.Stage.prototype.parseConfig = function(t) {
                    t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
                }, i.Stage.prototype.boot = function() {
                    i.DOM.getOffset(this.game.canvas, this.offset), i.Canvas.setUserSelect(this.game.canvas, "none"), i.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
                }, i.Stage.prototype.preUpdate = function() {
                    this.currentRenderOrderID = 0;
                    for (var t = 0; t < this.children.length;) {
                        var e = this.children[t];
                        e.preUpdate(), this === e.parent && t++
                    }
                }, i.Stage.prototype.update = function() {
                    for (var t = this.children.length; t--;) this.children[t].update()
                }, i.Stage.prototype.postUpdate = function() {
                    this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                    this.updateTransform()
                }, i.Stage.prototype.updateTransform = function() {
                    this.worldAlpha = 1;
                    for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
                }, i.Stage.prototype.checkVisibility = function() {
                    void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                    var t = this;
                    this._onChange = function(e) {
                        return t.visibilityChange(e)
                    }, this._onClick = function(e) {
                        void 0 === document.hasFocus || document.hasFocus() || t.visibilityChange(e)
                    }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, window.addEventListener("click", this._onClick), this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                        i.Stage.prototype.visibilityChange.call(t, {
                            type: "pause"
                        })
                    }), CocoonJS.App.onActivated.addEventListener(function() {
                        i.Stage.prototype.visibilityChange.call(t, {
                            type: "resume"
                        })
                    }))
                }, i.Stage.prototype.visibilityChange = function(t) {
                    switch (t.type) {
                        case "blur":
                        case "pagehide":
                            return void this.game.focusLoss(t);
                        case "click":
                        case "focus":
                        case "pageshow":
                            return void this.game.focusGain(t)
                    }
                    this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
                }, i.Stage.prototype.setBackgroundColor = function(t) {
                    this.game.transparent || (i.Color.valueToColor(t, this._bgColor), i.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
                }, i.Stage.prototype.destroy = function() {
                    this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null, window.removeEventListener("click", this._onClick)
                }, i.Stage.prototype.add = function(t, e, i) {
                    return t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? this.addChild(t) : this.addChildAt(t, i), t)
                }, Object.defineProperty(i.Stage.prototype, "backgroundColor", {
                    get: function() {
                        return this._bgColor.color
                    },
                    set: function(t) {
                        this.setBackgroundColor(t)
                    }
                }), Object.defineProperty(i.Stage.prototype, "smoothed", {
                    get: function() {
                        return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                    },
                    set: function(t) {
                        PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                    }
                }), i.Group = function(t, e, s, n, r, o) {
                    void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = i.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = s || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), n ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = i.GROUP, this.physicsType = i.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = i.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.updateOnlyExistingChildren = !1, this.onChildInputDown = new i.Signal, this.onChildInputUp = new i.Signal, this.onChildInputOver = new i.Signal, this.onChildInputOut = new i.Signal, this.enableBody = r, this.enableBodyDebug = !1, this.physicsBodyType = o, this.physicsSortDirection = null, this.onDestroy = new i.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new i.Point, this.hash = [], this._sortProperty = "z"
                }, i.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Group.prototype.constructor = i.Group, i.Group.RETURN_NONE = 0, i.Group.RETURN_TOTAL = 1, i.Group.RETURN_CHILD = 2, i.Group.RETURN_ALL = 3, i.Group.SORT_ASCENDING = -1, i.Group.SORT_DESCENDING = 1, i.Group.prototype.add = function(t, e, i) {
                    return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
                }, i.Group.prototype.addAt = function(t, e, i) {
                    return this.add(t, i, e)
                }, i.Group.prototype.addToHash = function(t) {
                    return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0)
                }, i.Group.prototype.removeFromHash = function(t) {
                    if (t) {
                        var e = this.hash.indexOf(t);
                        if (-1 !== e) return this.hash.splice(e, 1), !0
                    }
                    return !1
                }, i.Group.prototype.addMultiple = function(t, e) {
                    if (t instanceof i.Group) t.moveAll(this, e);
                    else if (Array.isArray(t))
                        for (var s = 0; s < t.length; s++) this.add(t[s], e);
                    return t
                }, i.Group.prototype.getAt = function(t) {
                    return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
                }, i.Group.prototype.create = function(t, e, i, s, n, r) {
                    void 0 === n && (n = !0);
                    var o = new this.classType(this.game, t, e, i, s);
                    return o.exists = n, o.visible = n, o.alive = n, this.add(o, !1, r)
                }, i.Group.prototype.createMultiple = function(t, e, i, s, n, r) {
                    void 0 === i && (i = 0), void 0 === s && (s = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
                    var o = this,
                        a = [];
                    return e.forEach(function(e) {
                        i.forEach(function(i) {
                            for (var h = 0; h < t; h++) {
                                var u = o.create(0, 0, e, i, s);
                                n && n.call(r || u, u, h), a.push(u)
                            }
                        })
                    }), a
                }, i.Group.prototype.updateZ = function() {
                    for (var t = this.children.length; t--;) this.children[t].z = t
                }, i.Group.prototype.align = function(t, e, s, n, r, o) {
                    if (void 0 === r && (r = i.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || -1 === t && -1 === e) return !1;
                    for (var a = new i.Rectangle(0, 0, s, n), h = t * s, u = e * n, l = o; l < this.children.length; l++) {
                        var c = this.children[l];
                        if (c.alignIn)
                            if (c.alignIn(a, r), -1 === t) a.y += n, a.y === u && (a.x += s, a.y = 0);
                            else if (-1 === e) a.x += s, a.x === h && (a.x = 0, a.y += n);
                        else if (a.x += s, a.x === h && (a.x = 0, a.y += n, a.y === u)) return !0
                    }
                    return !0
                }, i.Group.prototype.resetCursor = function(t) {
                    if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
                }, i.Group.prototype.next = function() {
                    if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
                }, i.Group.prototype.previous = function() {
                    if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
                }, i.Group.prototype.swap = function(t, e) {
                    this.swapChildren(t, e), this.updateZ()
                }, i.Group.prototype.bringToTop = function(t) {
                    return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
                }, i.Group.prototype.sendToBack = function(t) {
                    return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
                }, i.Group.prototype.moveUp = function(t) {
                    if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                        var e = this.getIndex(t),
                            i = this.getAt(e + 1);
                        i && this.swap(t, i)
                    }
                    return t
                }, i.Group.prototype.moveDown = function(t) {
                    if (t.parent === this && this.getIndex(t) > 0) {
                        var e = this.getIndex(t),
                            i = this.getAt(e - 1);
                        i && this.swap(t, i)
                    }
                    return t
                }, i.Group.prototype.xy = function(t, e, i) {
                    if (t < 0 || t > this.children.length) return -1;
                    this.getChildAt(t).x = e, this.getChildAt(t).y = i
                }, i.Group.prototype.reverse = function() {
                    this.children.reverse(), this.updateZ()
                }, i.Group.prototype.getIndex = function(t) {
                    return this.children.indexOf(t)
                }, i.Group.prototype.getByName = function(t) {
                    for (var e = 0; e < this.children.length; e++)
                        if (this.children[e].name === t) return this.children[e];
                    return null
                }, i.Group.prototype.replace = function(t, e) {
                    var s = this.getIndex(t);
                    if (-1 !== s) return e.parent && (e.parent instanceof i.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, s), t
                }, i.Group.prototype.hasProperty = function(t, e) {
                    var i = e.length;
                    return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
                }, i.Group.prototype.setProperty = function(t, e, i, s, n) {
                    if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return !1;
                    var r = e.length;
                    return 1 === r ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === r ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === r ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === r && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
                }, i.Group.prototype.checkProperty = function(t, e, s, n) {
                    if (void 0 === n && (n = !1), this !== t.parent) return !1;
                    var r = i.Utils.getProperty(t, e);
                    return !(void 0 === r && n || r !== s)
                }, i.Group.prototype.set = function(t, e, i, s, n, r, o) {
                    if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, r, o)
                }, i.Group.prototype.setAll = function(t, e, i, s, n, r) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === r && (r = !1), t = t.split("."), n = n || 0;
                    for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, r)
                }, i.Group.prototype.setAllChildren = function(t, e, s, n, r, o) {
                    void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === o && (o = !1), r = r || 0;
                    for (var a = 0; a < this.children.length; a++)(!s || s && this.children[a].alive) && (!n || n && this.children[a].visible) && (this.children[a] instanceof i.Group ? this.children[a].setAllChildren(t, e, s, n, r, o) : this.setProperty(this.children[a], t.split("."), e, r, o))
                }, i.Group.prototype.checkAll = function(t, e, i, s, n) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
                    for (var r = 0; r < this.children.length; r++) {
                        var o = this.children[r];
                        if ((!i || i && o.alive) && (!s || s && o.visible) && !this.checkProperty(o, t, e, n)) return !1
                    }
                    return !0
                }, i.Group.prototype.checkAny = function(t, e, i, s) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1);
                    for (var n = 0; n < this.children.length; n++) {
                        var r = this.children[n];
                        if ((!i || i && r.alive) && (!s || s && r.visible) && this.checkProperty(r, t, e)) return !0
                    }
                    return !1
                }, i.Group.prototype.addAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 1)
                }, i.Group.prototype.subAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 2)
                }, i.Group.prototype.multiplyAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 3)
                }, i.Group.prototype.divideAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 4)
                }, i.Group.prototype.kill = function() {
                    this.alive = !1, this.exists = !1, this.visible = !1
                }, i.Group.prototype.killAll = function() {
                    this.callAllExists("kill", !0)
                }, i.Group.prototype.revive = function() {
                    this.alive = !0, this.exists = !0, this.visible = !0
                }, i.Group.prototype.reviveAll = function() {
                    this.callAllExists("revive", !1)
                }, i.Group.prototype.resetAll = function(t, e, i, s, n) {
                    this.forEach(this.resetChild, this, n, t, e, i, s)
                }, i.Group.prototype.callAllExists = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [];
                        for (s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    for (var s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
                }, i.Group.prototype.callbackFromArray = function(t, e, i) {
                    if (1 === i) {
                        if (t[e[0]]) return t[e[0]]
                    } else if (2 === i) {
                        if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                    } else if (3 === i) {
                        if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                    } else if (4 === i) {
                        if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                    } else if (t[e]) return t[e];
                    return !1
                }, i.Group.prototype.callAll = function(t, e) {
                    if (void 0 !== t) {
                        var i = (t = t.split(".")).length;
                        if (void 0 === e || null === e || "" === e) e = null;
                        else if ("string" == typeof e) var s = (e = e.split(".")).length;
                        var n;
                        if (arguments.length > 2) {
                            n = [];
                            for (a = 2; a < arguments.length; a++) n.push(arguments[a])
                        }
                        for (var r = null, o = null, a = 0; a < this.children.length; a++) r = this.callbackFromArray(this.children[a], t, i), e && r ? (o = this.callbackFromArray(this.children[a], e, s), r && r.apply(o, n)) : r && r.apply(this.children[a], n)
                    }
                }, i.Group.prototype.preUpdate = function() {
                    if (this.pendingDestroy) return this.destroy(), !1;
                    if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                    for (var t = 0; t < this.children.length;) {
                        var e = this.children[t];
                        e.preUpdate(), this === e.parent && t++
                    }
                    return !0
                }, i.Group.prototype.update = function() {
                    for (var t = this.children.length; t--;) {
                        var e = this.children.length;
                        t >= e && (t = e - 1);
                        var i = this.children[t];
                        this.updateOnlyExistingChildren && !i.exists || i.update()
                    }
                }, i.Group.prototype.postUpdate = function() {
                    this.fixedToCamera && (this.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, i.Group.prototype.filter = function(t, e) {
                    for (var s = -1, n = this.children.length, r = []; ++s < n;) {
                        var o = this.children[s];
                        (!e || e && o.exists) && t(o, s, this.children) && r.push(o)
                    }
                    return new i.ArraySet(r)
                }, i.Group.prototype.forEach = function(t, e, i) {
                    if (void 0 === i && (i = !1), arguments.length <= 3)
                        for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && t.call(e, this.children[n]);
                    else {
                        for (var s = [null], n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && (s[0] = this.children[n], t.apply(e, s))
                    }
                }, i.Group.prototype.forEachExists = function(t, e) {
                    var s;
                    if (arguments.length > 2) {
                        s = [null];
                        for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                    }
                    this.iterate("exists", !0, i.Group.RETURN_TOTAL, t, e, s)
                }, i.Group.prototype.forEachAlive = function(t, e) {
                    var s;
                    if (arguments.length > 2) {
                        s = [null];
                        for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                    }
                    this.iterate("alive", !0, i.Group.RETURN_TOTAL, t, e, s)
                }, i.Group.prototype.forEachDead = function(t, e) {
                    var s;
                    if (arguments.length > 2) {
                        s = [null];
                        for (var n = 2; n < arguments.length; n++) s.push(arguments[n])
                    }
                    this.iterate("alive", !1, i.Group.RETURN_TOTAL, t, e, s)
                }, i.Group.prototype.sort = function(t, e) {
                    this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = i.Group.SORT_ASCENDING), this._sortProperty = t, e === i.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
                }, i.Group.prototype.customSort = function(t, e) {
                    this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
                }, i.Group.prototype.ascendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
                }, i.Group.prototype.descendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
                }, i.Group.prototype.iterate = function(t, e, s, n, r, o) {
                    if (0 === this.children.length) {
                        if (s === i.Group.RETURN_TOTAL) return 0;
                        if (s === i.Group.RETURN_ALL) return []
                    }
                    var a = 0;
                    if (s === i.Group.RETURN_ALL) var h = [];
                    for (var u = 0; u < this.children.length; u++)
                        if (this.children[u][t] === e) {
                            if (a++, n && (o ? (o[0] = this.children[u], n.apply(r, o)) : n.call(r, this.children[u])), s === i.Group.RETURN_CHILD) return this.children[u];
                            s === i.Group.RETURN_ALL && h.push(this.children[u])
                        }
                    return s === i.Group.RETURN_TOTAL ? a : s === i.Group.RETURN_ALL ? h : null
                }, i.Group.prototype.getFirst = function(t, e) {
                    return this.iterate(t, e, i.Group.RETURN_CHILD)
                }, i.Group.prototype.getFirstExists = function(t, e, i, s, n, r) {
                    void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                    var o = this.getFirst("exists", t);
                    return null === o && e ? this.create(i, s, n, r) : this.resetChild(o, i, s, n, r)
                }, i.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var r = this.getFirst("alive", !0);
                    return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
                }, i.Group.prototype.getFirstDead = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var r = this.getFirst("alive", !1);
                    return null === r && t ? this.create(e, i, s, n) : this.resetChild(r, e, i, s, n)
                }, i.Group.prototype.resetChild = function(t, e, i, s, n) {
                    return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
                }, i.Group.prototype.getTop = function() {
                    if (this.children.length > 0) return this.children[this.children.length - 1]
                }, i.Group.prototype.getBottom = function() {
                    if (this.children.length > 0) return this.children[0]
                }, i.Group.prototype.getClosestTo = function(t, e, s) {
                    for (var n = Number.MAX_VALUE, r = 0, o = null, a = 0; a < this.children.length; a++) {
                        var h = this.children[a];
                        h.exists && (r = Math.abs(i.Point.distance(t, h))) < n && (!e || e.call(s, h, r)) && (n = r, o = h)
                    }
                    return o
                }, i.Group.prototype.getFurthestFrom = function(t, e, s) {
                    for (var n = 0, r = 0, o = null, a = 0; a < this.children.length; a++) {
                        var h = this.children[a];
                        h.exists && (r = Math.abs(i.Point.distance(t, h))) > n && (!e || e.call(s, h, r)) && (n = r, o = h)
                    }
                    return o
                }, i.Group.prototype.count = function(t, e) {
                    return this.iterate(t, e, i.Group.RETURN_TOTAL)
                }, i.Group.prototype.countLiving = function() {
                    return this.count("alive", !0)
                }, i.Group.prototype.countDead = function() {
                    return this.count("alive", !1)
                }, i.Group.prototype.getRandom = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : i.ArrayUtils.getRandomItem(this.children, t, e)
                }, i.Group.prototype.getRandomExists = function(t, e) {
                    var i = this.getAll("exists", !0, t, e);
                    return this.game.rnd.pick(i)
                }, i.Group.prototype.getAll = function(t, e, i, s) {
                    void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
                    for (var n = [], r = i; r < s; r++) {
                        var o = this.children[r];
                        t ? o[t] === e && n.push(o) : n.push(o)
                    }
                    return n
                }, i.Group.prototype.remove = function(t, e, i) {
                    if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                    i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                    var s = this.removeChild(t);
                    return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
                }, i.Group.prototype.moveAll = function(t, e) {
                    if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof i.Group) {
                        do {
                            t.add(this.children[0], e)
                        } while (this.children.length > 0);
                        this.hash = [], this.cursor = null
                    }
                    return t
                }, i.Group.prototype.removeAll = function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                        do {
                            !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                            var s = this.removeChild(this.children[0]);
                            this.removeFromHash(s), t && s && s.destroy(!0, i)
                        } while (this.children.length > 0);
                        this.hash = [], this.cursor = null
                    }
                }, i.Group.prototype.removeBetween = function(t, e, i, s) {
                    if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                        if (t > e || t < 0 || e > this.children.length) return !1;
                        for (var n = e; n >= t;) {
                            !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                            var r = this.removeChild(this.children[n]);
                            this.removeFromHash(r), i && r && r.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                        }
                        this.updateZ()
                    }
                }, i.Group.prototype.scatter = function(t, e) {
                    null == t && (t = this.game.world.bounds), this.forEach(function(e) {
                        e.position.set(t.randomX, t.randomY)
                    }, null, e)
                }, i.Group.prototype.shuffle = function() {
                    i.ArrayUtils.shuffle(this.children), this.updateZ()
                }, i.Group.prototype.destroy = function(t, e) {
                    null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
                }, Object.defineProperty(i.Group.prototype, "total", {
                    get: function() {
                        return this.iterate("exists", !0, i.Group.RETURN_TOTAL)
                    }
                }), Object.defineProperty(i.Group.prototype, "length", {
                    get: function() {
                        return this.children.length
                    }
                }), Object.defineProperty(i.Group.prototype, "angle", {
                    get: function() {
                        return i.Math.radToDeg(this.rotation)
                    },
                    set: function(t) {
                        this.rotation = i.Math.degToRad(t)
                    }
                }), Object.defineProperty(i.Group.prototype, "centerX", {
                    get: function() {
                        return this.getBounds(this.parent).centerX
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.halfWidth
                    }
                }), Object.defineProperty(i.Group.prototype, "centerY", {
                    get: function() {
                        return this.getBounds(this.parent).centerY
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.halfHeight
                    }
                }), Object.defineProperty(i.Group.prototype, "left", {
                    get: function() {
                        return this.getBounds(this.parent).left
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i
                    }
                }), Object.defineProperty(i.Group.prototype, "right", {
                    get: function() {
                        return this.getBounds(this.parent).right
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.width
                    }
                }), Object.defineProperty(i.Group.prototype, "top", {
                    get: function() {
                        return this.getBounds(this.parent).top
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i
                    }
                }), Object.defineProperty(i.Group.prototype, "bottom", {
                    get: function() {
                        return this.getBounds(this.parent).bottom
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.height
                    }
                }), i.World = function(t) {
                    i.Group.call(this, t, null, "__world", !1), this.bounds = new i.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
                }, i.World.prototype = Object.create(i.Group.prototype), i.World.prototype.constructor = i.World, i.World.prototype.boot = function() {
                    this.camera = new i.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
                }, i.World.prototype.stateChange = function() {
                    this.x = 0, this.y = 0, this.camera.reset()
                }, i.World.prototype.setBounds = function(t, e, i, s) {
                    this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
                }, i.World.prototype.resize = function(t, e) {
                    this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
                }, i.World.prototype.shutdown = function() {
                    this.destroy(!0, !0)
                }, i.World.prototype.wrap = function(t, e, i, s, n) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
                }, i.World.prototype.wrapAll = function(t, e, i, s, n, r) {
                    t.forEach(this.wrap, this, e, i, s, n, r)
                }, Object.defineProperty(i.World.prototype, "width", {
                    get: function() {
                        return this.bounds.width
                    },
                    set: function(t) {
                        t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                    }
                }), Object.defineProperty(i.World.prototype, "height", {
                    get: function() {
                        return this.bounds.height
                    },
                    set: function(t) {
                        t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                    }
                }), Object.defineProperty(i.World.prototype, "centerX", {
                    get: function() {
                        return this.bounds.halfWidth + this.bounds.x
                    }
                }), Object.defineProperty(i.World.prototype, "centerY", {
                    get: function() {
                        return this.bounds.halfHeight + this.bounds.y
                    }
                }), Object.defineProperty(i.World.prototype, "randomX", {
                    get: function() {
                        return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                    }
                }), Object.defineProperty(i.World.prototype, "randomY", {
                    get: function() {
                        return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                    }
                }), i.Game = function(t, e, s, n, r, o, a, h) {
                    return this.id = i.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.multiTexture = !1, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = i.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = i.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.pendingDestroy = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this.rendersThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new i.Signal, this.forceSingleUpdate = !0, this.forceSingleRender = !0, this.dropFrames = !1, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                        enableDebug: !0
                    }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== s && (this.renderType = s), void 0 !== n && (this.parent = n), void 0 !== o && (this.transparent = o), void 0 !== a && (this.antialias = a), this.rnd = new i.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new i.StateManager(this, r)), this.device.whenReady(this.boot, this), this
                }, i.Game.prototype = {
                    parseConfig: function(t) {
                        this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), void 0 !== t.multiTexture && (this.multiTexture = t.multiTexture), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                        var e = [(Date.now() * Math.random()).toString()];
                        t.seed && (e = t.seed), this.rnd = new i.RandomDataGenerator(e);
                        var s = null;
                        t.state && (s = t.state), this.state = new i.StateManager(this, s)
                    },
                    boot: function() {
                        this.isBooted || (this.onPause = new i.Signal, this.onResume = new i.Signal, this.onBlur = new i.Signal, this.onFocus = new i.Signal, this.isBooted = !0, PIXI.game = this, this.math = i.Math, this.scale = new i.ScaleManager(this, this._width, this._height), this.stage = new i.Stage(this), this.setUpRenderer(), this.world = new i.World(this), this.add = new i.GameObjectFactory(this), this.make = new i.GameObjectCreator(this), this.cache = new i.Cache(this), this.load = new i.Loader(this), this.time = new i.Time(this), this.tweens = new i.TweenManager(this), this.input = new i.Input(this), this.sound = new i.SoundManager(this), this.physics = new i.Physics(this, this.physicsConfig), this.particles = new i.Particles(this), this.create = new i.Create(this), this.plugins = new i.PluginManager(this), this.net = new i.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new i.Utils.Debug(this), this.debug.boot()) : this.debug = {
                            preUpdate: function() {},
                            update: function() {},
                            reset: function() {},
                            isDisabled: !0
                        }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new i.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new i.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.config.disableStart || (this.cache.isReady ? this.raf.start() : this.cache.onReady.addOnce(function() {
                            this.raf.start()
                        }, this)))
                    },
                    showDebugHeader: function() {
                        if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                            var t = i.VERSION,
                                e = "Canvas",
                                s = "HTML Audio",
                                n = 1;
                            if (this.renderType === i.WEBGL ? (e = "WebGL", n++) : this.renderType === i.HEADLESS && (e = "Headless"), this.device.webAudio && (s = "WebAudio", n++), this.device.ie) window.console && console.log("Phaser v" + t + " | Pixi.js | " + e + " | " + s + " | http://phaser.io");
                            else {
                                for (var r = ["%c %c %c Phaser CE v" + t + " | Pixi.js | " + e + " | " + s + "  %c %c %c http://phaser.io %c%c%c", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], o = 0; o < 3; o++) o < n ? r.push("color: #ff2424; background: #fff") : r.push("color: #959595; background: #fff");
                                console.log.apply(console, r)
                            }
                        }
                    },
                    setUpRenderer: function() {
                        if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas 2d context, aborting.");
                        if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = i.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.config.crisp && i.Canvas.setImageRenderingCrisp(this.canvas), this.renderType === i.WEBGL || this.renderType === i.WEBGL_MULTI || this.renderType === i.AUTO && this.device.webGL) {
                            (this.multiTexture || this.renderType === i.WEBGL_MULTI) && (PIXI.enableMultiTexture(), this.multiTexture = !0);
                            try {
                                this.renderer = new PIXI.WebGLRenderer(this, this.config), this.renderType = i.WEBGL, this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1)
                            } catch (t) {
                                if (this.renderer = null, this.multiTexture = !1, PIXI._enableMultiTextureToggle = !1, this.renderType === i.WEBGL) throw t
                            }
                        }
                        this.renderer || (this.renderer = new PIXI.CanvasRenderer(this, this.config), this.context = this.renderer.context, this.renderType === i.AUTO && (this.renderType = i.CANVAS)), this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === i.CANVAS), this.renderType !== i.HEADLESS && (this.stage.smoothed = this.antialias, i.Canvas.addToDOM(this.canvas, this.parent, !1), i.Canvas.setTouchAction(this.canvas))
                    },
                    contextLost: function(t) {
                        t.preventDefault(), this.renderer.contextLost = !0
                    },
                    contextRestored: function() {
                        this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                    },
                    update: function(t) {
                        if (this.pendingDestroy) this.destroy();
                        else {
                            if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                            if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.dropFrames ? this.rendersThisFrame = 0 : (this.updateRender(this.time.slowMotion * this.time.desiredFps), this.rendersThisFrame = 1);
                            else {
                                var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                                this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                                var i = 0;
                                for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)), this.forceSingleRender ? this.rendersThisFrame = 1 : this.rendersThisFrame = Math.min(1, this.updatesThisFrame); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                                i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.rendersThisFrame > 0 && this.updateRender(this._deltaTime / e)
                            }
                        }
                    },
                    updateLogic: function(t) {
                        this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(t), this.debug.preUpdate(), this.input.pauseUpdate()) : (this.stepping && (this.pendingStep = !0), this.time.countUpdate(), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                    },
                    updateRender: function(t) {
                        this.lockRender || (this.time.countRender(), this.state.preRender(t), this.renderType !== i.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
                    },
                    enableStep: function() {
                        this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                    },
                    disableStep: function() {
                        this.stepping = !1, this.pendingStep = !1
                    },
                    step: function() {
                        this.pendingStep = !1, this.stepCount++
                    },
                    destroy: function() {
                        this.raf.stop(), this.debug.destroy && this.debug.destroy(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.debug = null, this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), i.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, i.GAMES[this.id] = null
                    },
                    gamePaused: function(t) {
                        this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                    },
                    gameResumed: function(t) {
                        this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                    },
                    focusLoss: function(t) {
                        this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                    },
                    focusGain: function(t) {
                        this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                    }
                }, i.Game.prototype.constructor = i.Game, Object.defineProperty(i.Game.prototype, "paused", {
                    get: function() {
                        return this._paused
                    },
                    set: function(t) {
                        !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                    }
                }), i.Input = function(t) {
                    this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = i.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.touchLockCallbacks = [], this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new i.ArraySet, this._localPoint = new i.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
                }, i.Input.MOUSE_OVERRIDES_TOUCH = 0, i.Input.TOUCH_OVERRIDES_MOUSE = 1, i.Input.MOUSE_TOUCH_COMBINE = 2, i.Input.MAX_POINTERS = 10, i.Input.prototype = {
                    boot: function() {
                        this.mousePointer = new i.Pointer(this.game, 0, i.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new i.Mouse(this.game), this.touch = new i.Touch(this.game), this.mspointer = new i.MSPointer(this.game), i.Keyboard && (this.keyboard = new i.Keyboard(this.game)), i.Gamepad && (this.gamepad = new i.Gamepad(this.game)), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.scale = new i.Point(1, 1), this.speed = new i.Point, this.position = new i.Point, this._oldPosition = new i.Point, this.circle = new i.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = i.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.game.device.mspointer || this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                        var t = this;
                        this._onClickTrampoline = function(e) {
                            t.onClickTrampoline(e)
                        }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                    },
                    destroy: function() {
                        this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], i.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                    },
                    setInteractiveCandidateHandler: function(t, e) {
                        this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                    },
                    addMoveCallback: function(t, e) {
                        this.moveCallbacks.push({
                            callback: t,
                            context: e
                        })
                    },
                    addTouchLockCallback: function(t, e, i) {
                        void 0 === i && (i = !1), this.touchLockCallbacks.push({
                            callback: t,
                            context: e,
                            onEnd: i
                        })
                    },
                    removeTouchLockCallback: function(t, e) {
                        for (var i = this.touchLockCallbacks.length; i--;)
                            if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                        return !1
                    },
                    executeTouchLockCallbacks: function(t, e) {
                        for (var i = this.touchLockCallbacks.length; i--;) {
                            var s = this.touchLockCallbacks[i];
                            s.onEnd === t && s.callback.call(s.context, this, e) && this.touchLockCallbacks.splice(i, 1)
                        }
                    },
                    deleteMoveCallback: function(t, e) {
                        for (var i = this.moveCallbacks.length; i--;)
                            if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                    },
                    addPointer: function() {
                        if (this.pointers.length >= i.Input.MAX_POINTERS) return console.warn("Phaser.Input.addPointer: Maximum limit of " + i.Input.MAX_POINTERS + " pointers reached."), null;
                        var t = this.pointers.length + 1,
                            e = new i.Pointer(this.game, t, i.PointerMode.CONTACT);
                        return this.pointers.push(e), this["pointer" + t] = e, e
                    },
                    update: function() {
                        if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                        else {
                            this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                            for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                            this._pollCounter = 0
                        }
                    },
                    pauseUpdate: function() {
                        this.gamepad && this.gamepad.active && this.gamepad.update()
                    },
                    reset: function(t) {
                        if (this.game.isBooted && !this.resetLocked) {
                            void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t);
                            for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                            "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = ""), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.moveCallbacks = []), this._pollCounter = 0
                        }
                    },
                    resetSpeed: function(t, e) {
                        this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                    },
                    startPointer: function(t) {
                        if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                        if (!this.pointer1.active) return this.pointer1.start(t);
                        if (!this.pointer2.active) return this.pointer2.start(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (!i.active) return i.start(t)
                        }
                        return null
                    },
                    updatePointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.move(t)
                        }
                        return null
                    },
                    stopPointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.stop(t)
                        }
                        return null
                    },
                    countActivePointers: function(t) {
                        void 0 === t && (t = this.pointers.length);
                        for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) this.pointers[i].active && e--;
                        return t - e
                    },
                    getPointer: function(t) {
                        void 0 === t && (t = !1);
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active === t) return i
                        }
                        return null
                    },
                    getPointerFromIdentifier: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.identifier === t) return i
                        }
                        return null
                    },
                    getPointerFromId: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.pointerId === t) return i
                        }
                        return null
                    },
                    getLocalPosition: function(t, e, s) {
                        void 0 === s && (s = new i.Point);
                        var n = t.worldTransform,
                            r = 1 / (n.a * n.d + n.c * -n.b);
                        return s.setTo(n.d * r * e.x + -n.c * r * e.y + (n.ty * n.c - n.tx * n.d) * r, n.a * r * e.y + -n.b * r * e.x + (-n.ty * n.a + n.tx * n.b) * r)
                    },
                    hitTest: function(t, e, s) {
                        if (!t.worldVisible) return !1;
                        if (this.getLocalPosition(t, e, this._localPoint), s.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                        if (i.Creature && t instanceof i.Creature) {
                            var n = Math.abs(t.width),
                                r = Math.abs(t.height),
                                o = t.x - n * t.anchorX;
                            if (this.game.camera.x + e.x >= o && this.game.camera.x + e.x < o + n) {
                                a = t.y - r * t.anchorY;
                                if (this.game.camera.y + e.y >= a && this.game.camera.y + e.y < a + r) return !0
                            }
                        } else if (t instanceof i.TileSprite) {
                            var n = t.width,
                                r = t.height,
                                o = -n * t.anchor.x;
                            if (this._localPoint.x >= o && this._localPoint.x < o + n) {
                                a = -r * t.anchor.y;
                                if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                            }
                        } else if (t instanceof PIXI.Sprite) {
                            var n = t.texture.frame.width / t.texture.baseTexture.resolution,
                                r = t.texture.frame.height / t.texture.baseTexture.resolution,
                                o = -n * t.anchor.x;
                            if (this._localPoint.x >= o && this._localPoint.x < o + n) {
                                var a = -r * t.anchor.y;
                                if (this._localPoint.y >= a && this._localPoint.y < a + r) return !0
                            }
                        } else if (t instanceof i.Graphics)
                            for (u = 0; u < t.graphicsData.length; u++) {
                                var h = t.graphicsData[u];
                                if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                            }
                        for (var u = 0; u < t.children.length; u++)
                            if (this.hitTest(t.children[u], e, s)) return !0;
                        return !1
                    },
                    onClickTrampoline: function() {
                        this.activePointer.processClickTrampolines()
                    }
                }, i.Input.prototype.constructor = i.Input, Object.defineProperty(i.Input.prototype, "x", {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = Math.floor(t)
                    }
                }), Object.defineProperty(i.Input.prototype, "y", {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = Math.floor(t)
                    }
                }), Object.defineProperty(i.Input.prototype, "pollLocked", {
                    get: function() {
                        return this.pollRate > 0 && this._pollCounter < this.pollRate
                    }
                }), Object.defineProperty(i.Input.prototype, "totalInactivePointers", {
                    get: function() {
                        return this.pointers.length - this.countActivePointers()
                    }
                }), Object.defineProperty(i.Input.prototype, "totalActivePointers", {
                    get: function() {
                        return this.countActivePointers()
                    }
                }), Object.defineProperty(i.Input.prototype, "worldX", {
                    get: function() {
                        return this.game.camera.view.x + this.x
                    }
                }), Object.defineProperty(i.Input.prototype, "worldY", {
                    get: function() {
                        return this.game.camera.view.y + this.y
                    }
                }), i.Mouse = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new i.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
                }, i.Mouse.NO_BUTTON = -1, i.Mouse.LEFT_BUTTON = 0, i.Mouse.MIDDLE_BUTTON = 1, i.Mouse.RIGHT_BUTTON = 2, i.Mouse.BACK_BUTTON = 3, i.Mouse.FORWARD_BUTTON = 4, i.Mouse.WHEEL_UP = 1, i.Mouse.WHEEL_DOWN = -1, i.Mouse.prototype = {
                    start: function() {
                        if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                            var e = this;
                            this._onMouseDown = function(t) {
                                return e.onMouseDown(t)
                            }, this._onMouseMove = function(t) {
                                return e.onMouseMove(t)
                            }, this._onMouseUp = function(t) {
                                return e.onMouseUp(t)
                            }, this._onMouseUpGlobal = function(t) {
                                return e.onMouseUpGlobal(t)
                            }, this._onMouseOutGlobal = function(t) {
                                return e.onMouseOutGlobal(t)
                            }, this._onMouseOut = function(t) {
                                return e.onMouseOut(t)
                            }, this._onMouseOver = function(t) {
                                return e.onMouseOver(t)
                            }, this._onMouseWheel = function(t) {
                                return e.onMouseWheel(t)
                            };
                            var i = this.game.canvas;
                            i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0));
                            var s = this.game.device.wheelEvent;
                            s && (i.addEventListener(s, this._onMouseWheel, !0), "mousewheel" === s ? this._wheelEvent = new t(-.025, 1) : "DOMMouseScroll" === s && (this._wheelEvent = new t(1, 1)))
                        }
                    },
                    onMouseDown: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                    },
                    onMouseMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                    },
                    onMouseUp: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseUpGlobal: function(t) {
                        this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseOutGlobal: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.resetButtons())
                    },
                    onMouseOut: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t)), this.input.interactiveItems.callAll("_pointerOutHandler", this.input.mousePointer))
                    },
                    onMouseOver: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
                    },
                    onMouseWheel: function(t) {
                        this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = i.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
                    },
                    requestPointerLock: function() {
                        if (this.game.device.pointerLock) {
                            var t = this.game.canvas;
                            t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                            var e = this;
                            this._pointerLockChange = function(t) {
                                return e.pointerLockChange(t)
                            }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                        }
                    },
                    pointerLockChange: function(t) {
                        var e = this.game.canvas;
                        document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                    },
                    releasePointerLock: function() {
                        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                        var e = this.game.device.wheelEvent;
                        e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                }, i.Mouse.prototype.constructor = i.Mouse, (t.prototype = {}).constructor = t, t.prototype.bindEvent = function(e) {
                    if (!t._stubsGenerated && e) {
                        for (var i in e) i in t.prototype || Object.defineProperty(t.prototype, i, {
                            get: function(t) {
                                return function() {
                                    var e = this.originalEvent[t];
                                    return "function" != typeof e ? e : e.bind(this.originalEvent)
                                }
                            }(i)
                        });
                        t._stubsGenerated = !0
                    }
                    return this.originalEvent = e, this
                }, Object.defineProperties(t.prototype, {
                    type: {
                        value: "wheel"
                    },
                    deltaMode: {
                        get: function() {
                            return this._deltaMode
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                        }
                    },
                    deltaX: {
                        get: function() {
                            return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                        }
                    },
                    deltaZ: {
                        value: 0
                    }
                }), i.MSPointer = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
                }, i.MSPointer.prototype = {
                    start: function() {
                        if (null === this._onMSPointerDown) {
                            var t = this;
                            if (this.game.device.mspointer) {
                                this._onMSPointerDown = function(e) {
                                    return t.onPointerDown(e)
                                }, this._onMSPointerMove = function(e) {
                                    return t.onPointerMove(e)
                                }, this._onMSPointerUp = function(e) {
                                    return t.onPointerUp(e)
                                }, this._onMSPointerUpGlobal = function(e) {
                                    return t.onPointerUpGlobal(e)
                                }, this._onMSPointerOut = function(e) {
                                    return t.onPointerOut(e)
                                }, this._onMSPointerOver = function(e) {
                                    return t.onPointerOver(e)
                                };
                                var e = this.game.canvas;
                                e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0))
                            }
                        }
                    },
                    onPointerDown: function(t) {
                        this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                    },
                    onPointerMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                    },
                    onPointerUp: function(t) {
                        this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                    },
                    onPointerUpGlobal: function(t) {
                        if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && e.withinGame && this.onPointerUp(t)
                        } else this.onPointerUp(t)
                    },
                    onPointerOut: function(t) {
                        if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                        else {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && (e.withinGame = !1)
                        }
                        this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
                    },
                    onPointerOver: function(t) {
                        if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                        else {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && (e.withinGame = !0)
                        }
                        this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
                    }
                }, i.MSPointer.prototype.constructor = i.MSPointer, i.DeviceButton = function(t, e) {
                    this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new i.Signal, this.onUp = new i.Signal, this.onFloat = new i.Signal
                }, i.DeviceButton.prototype = {
                    start: function(t, e) {
                        this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                    },
                    stop: function(t, e) {
                        this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                    },
                    startStop: function(t, e, i) {
                        t ? this.start(e, i) : this.stop(e, i)
                    },
                    padFloat: function(t) {
                        this.isDown = !1, this.isUp = !1, this.value = t, this.onFloat.dispatch(this, t)
                    },
                    justPressed: function(t) {
                        return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    reset: function() {
                        this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                    },
                    destroy: function() {
                        this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                    }
                }, i.DeviceButton.prototype.constructor = i.DeviceButton, Object.defineProperty(i.DeviceButton.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), i.Pointer = function(t, e, s) {
                    this.game = t, this.id = e, this.type = i.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = s || i.PointerMode.CURSOR | i.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new i.DeviceButton(this, i.Pointer.LEFT_BUTTON), this.middleButton = new i.DeviceButton(this, i.Pointer.MIDDLE_BUTTON), this.rightButton = new i.DeviceButton(this, i.Pointer.RIGHT_BUTTON), this.backButton = new i.DeviceButton(this, i.Pointer.BACK_BUTTON), this.forwardButton = new i.DeviceButton(this, i.Pointer.FORWARD_BUTTON), this.eraserButton = new i.DeviceButton(this, i.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new i.Point, this.positionDown = new i.Point, this.positionUp = new i.Point, this.circle = new i.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
                }, i.Pointer.NO_BUTTON = 0, i.Pointer.LEFT_BUTTON = 1, i.Pointer.RIGHT_BUTTON = 2, i.Pointer.MIDDLE_BUTTON = 4, i.Pointer.BACK_BUTTON = 8, i.Pointer.FORWARD_BUTTON = 16, i.Pointer.ERASER_BUTTON = 32, i.Pointer.prototype = {
                    resetButtons: function() {
                        this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                    },
                    processButtonsDown: function(t, e) {
                        t === i.Mouse.LEFT_BUTTON && this.leftButton.start(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.start(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.start(e), t === i.Mouse.BACK_BUTTON && this.backButton.start(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.start(e)
                    },
                    processButtonsUp: function(t, e) {
                        t === i.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === i.Mouse.BACK_BUTTON && this.backButton.stop(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e)
                    },
                    processButtonsUpDown: function(t, e) {
                        var s = "down" === e.type.toLowerCase().substr(-4),
                            n = "move" === e.type.toLowerCase().substr(-4);
                        void 0 !== t ? (s && 1 === t && e.ctrlKey && (t = 2), this.leftButton.startStop(i.Pointer.LEFT_BUTTON & t, e), this.rightButton.startStop(i.Pointer.RIGHT_BUTTON & t, e), this.middleButton.startStop(i.Pointer.MIDDLE_BUTTON & t, e), this.backButton.startStop(i.Pointer.BACK_BUTTON & t, e), this.forwardButton.startStop(i.Pointer.FORWARD_BUTTON & t, e), this.eraserButton.startStop(i.Pointer.ERASER_BUTTON & t, e)) : void 0 !== e.button ? s && e.ctrlKey && 0 === e.button ? this.rightButton.start(e) : s ? this.processButtonsDown(e.button, e) : n || this.processButtonsUp(e.button, e) : s ? e.ctrlKey ? this.rightButton.start(e) : this.leftButton.start(e) : (this.leftButton.stop(e), this.rightButton.stop(e))
                    },
                    updateButtons: function(t) {
                        this.button = t.button, this.processButtonsUpDown(t.buttons, t), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                    },
                    start: function(t) {
                        var e = this.game.input;
                        return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                    },
                    update: function() {
                        var t = this.game.input;
                        this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                            x: this.position.x,
                            y: this.position.y
                        }), this._history.length > t.recordLimit && this._history.shift()))
                    },
                    move: function(t, e) {
                        var s = this.game.input;
                        if (!s.pollLocked) {
                            void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && s.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * s.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * s.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (s.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || s.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || s.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === s.totalActivePointers) && (s.activePointer = this, s.x = this.x, s.y = this.y, s.position.setTo(s.x, s.y), s.circle.x = s.x, s.circle.y = s.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY);
                            for (var n = s.moveCallbacks.length; n--;) s.moveCallbacks[n].callback.call(s.moveCallbacks[n].context, this, this.x, this.y, e);
                            return null === this.targetObject || this.game.paused && !this.targetObject.noPause || !0 !== this.targetObject.isDragged ? s.interactiveItems.total > 0 && this.processInteractiveObjects(e) : !1 === this.targetObject.update(this) && (this.targetObject = null), this
                        }
                    },
                    processInteractiveObjects: function(t) {
                        var e = 0,
                            i = -1,
                            s = null,
                            n = this.game.input.interactiveItems.first;
                        for (this.interactiveCandidates = []; n;) n.checked = !1, !n.validForInput(i, e, !1) || this.game.paused && !n.sprite.noPause || (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
                        for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
                        return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
                    },
                    swapTarget: function(t, e) {
                        void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                    },
                    leave: function(t) {
                        this.withinGame = !1, this.move(t, !1)
                    },
                    stop: function(t) {
                        var e = this.game.input; {
                            if (!this._stateReset || !this.withinGame) return this.timeUp = this.game.time.time, (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
                            t.preventDefault()
                        }
                    },
                    justPressed: function(t) {
                        return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    addClickTrampoline: function(t, e, i, s) {
                        if (this.isDown) {
                            for (var n = this._clickTrampolines = this._clickTrampolines || [], r = 0; r < n.length; r++)
                                if (n[r].name === t) {
                                    n.splice(r, 1);
                                    break
                                }
                            n.push({
                                name: t,
                                targetObject: this.targetObject,
                                callback: e,
                                callbackContext: i,
                                callbackArgs: s
                            })
                        }
                    },
                    processClickTrampolines: function() {
                        var t = this._clickTrampolines;
                        if (t) {
                            for (var e = 0; e < t.length; e++) {
                                var i = t[e];
                                i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                            }
                            this._clickTrampolines = null, this._trampolineTargetObject = null
                        }
                    },
                    reset: function() {
                        !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                    },
                    resetMovement: function() {
                        this.movementX = 0, this.movementY = 0
                    }
                }, i.Pointer.prototype.constructor = i.Pointer, Object.defineProperty(i.Pointer.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), Object.defineProperty(i.Pointer.prototype, "worldX", {
                    get: function() {
                        return this.game.world.camera.x + this.x
                    }
                }), Object.defineProperty(i.Pointer.prototype, "worldY", {
                    get: function() {
                        return this.game.world.camera.y + this.y
                    }
                }), i.PointerMode = {
                    CURSOR: 1,
                    CONTACT: 2
                }, i.Touch = function(t) {
                    this.game = t, this.enabled = !0, this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
                }, i.Touch.prototype = {
                    start: function() {
                        if (null === this._onTouchStart) {
                            var t = this;
                            this.game.device.touch && (this._onTouchStart = function(e) {
                                return t.onTouchStart(e)
                            }, this._onTouchMove = function(e) {
                                return t.onTouchMove(e)
                            }, this._onTouchEnd = function(e) {
                                return t.onTouchEnd(e)
                            }, this._onTouchEnter = function(e) {
                                return t.onTouchEnter(e)
                            }, this._onTouchLeave = function(e) {
                                return t.onTouchLeave(e)
                            }, this._onTouchCancel = function(e) {
                                return t.onTouchCancel(e)
                            }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                        }
                    },
                    consumeDocumentTouches: function() {
                        this._documentTouchMove = function(t) {
                            t.preventDefault()
                        }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                    },
                    onTouchStart: function(t) {
                        if (this.game.input.executeTouchLockCallbacks(!1, t), this.event = t, this.game.input.enabled && this.enabled) {
                            this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                        }
                    },
                    onTouchCancel: function(t) {
                        if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                            this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                        }
                    },
                    onTouchEnter: function(t) {
                        this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                    },
                    onTouchLeave: function(t) {
                        this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                    },
                    onTouchMove: function(t) {
                        this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                    },
                    onTouchEnd: function(t) {
                        this.game.input.executeTouchLockCallbacks(!0, t), this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    },
                    stop: function() {
                        this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                    }
                }, i.Touch.prototype.constructor = i.Touch, i.InputHandler = function(t) {
                    this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new i.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new i.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new i.Point, this.snapPoint = new i.Point, this._dragPoint = new i.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new i.Point, this._pointerData = [], this._pointerData.push({
                        id: 0,
                        x: 0,
                        y: 0,
                        camX: 0,
                        camY: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    })
                }, i.InputHandler.prototype = {
                    start: function(t, e) {
                        if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                            this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                            for (var s = 0; s < 10; s++) this._pointerData[s] = {
                                id: s,
                                x: 0,
                                y: 0,
                                isDown: !1,
                                isUp: !1,
                                isOver: !1,
                                isOut: !1,
                                timeOver: 0,
                                timeOut: 0,
                                timeDown: 0,
                                timeUp: 0,
                                downDuration: 0,
                                isDragged: !1
                            };
                            this.snapOffset = new i.Point, this.enabled = !0, this._wasEnabled = !0
                        }
                        return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                    },
                    addedToGroup: function() {
                        this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                    },
                    removedFromGroup: function() {
                        this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                    },
                    reset: function() {
                        this.enabled = !1;
                        for (var t = 0; t < 10; t++) this._pointerData[t] = {
                            id: t,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        }
                    },
                    stop: function() {
                        !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                    },
                    destroy: function() {
                        this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                    },
                    validForInput: function(t, e, i) {
                        return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                    },
                    isPixelPerfect: function() {
                        return this.pixelPerfectClick || this.pixelPerfectOver
                    },
                    pointerX: function(t) {
                        return t = t || 0, this._pointerData[t].x
                    },
                    pointerY: function(t) {
                        return t = t || 0, this._pointerData[t].y
                    },
                    pointerDown: function(t) {
                        return t = t || 0, this._pointerData[t].isDown
                    },
                    pointerUp: function(t) {
                        return t = t || 0, this._pointerData[t].isUp
                    },
                    pointerTimeDown: function(t) {
                        return t = t || 0, this._pointerData[t].timeDown
                    },
                    pointerTimeUp: function(t) {
                        return t = t || 0, this._pointerData[t].timeUp
                    },
                    pointerOver: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 === t) {
                            for (var e = 0; e < 10; e++)
                                if (this._pointerData[e].isOver) return !0;
                            return !1
                        }
                        return this._pointerData[t].isOver
                    },
                    pointerOut: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 !== t) return this._pointerData[t].isOut;
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOut) return !0
                    },
                    pointerTimeOver: function(t) {
                        return t = t || 0, this._pointerData[t].timeOver
                    },
                    pointerTimeOut: function(t) {
                        return t = t || 0, this._pointerData[t].timeOut
                    },
                    pointerDragged: function(t) {
                        return t = t || 0, this._pointerData[t].isDragged
                    },
                    checkPointerDown: function(t, e) {
                        return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                    },
                    checkPointerOver: function(t, e) {
                        return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                    },
                    checkPixel: function(t, e, i) {
                        if (this.sprite.texture.baseTexture.source) {
                            if (null === t && null === e) {
                                this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                                var t = this._tempPoint.x,
                                    e = this._tempPoint.y
                            }
                            if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                            if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0
                        }
                        return !1
                    },
                    update: function(t) {
                        if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = i.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
                    },
                    _pointerOverHandler: function(t, e) {
                        if (null !== this.sprite) {
                            var i = this._pointerData[t.id];
                            if (!1 === i.isOver || t.dirty) {
                                var s = !1 === i.isOver;
                                i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.onChildInputOver && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                            }
                        }
                    },
                    _pointerOutHandler: function(t, e) {
                        if (null !== this.sprite) {
                            var i = this._pointerData[t.id];
                            i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputOut && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                        }
                    },
                    _touchedHandler: function(t) {
                        if (null !== this.sprite) {
                            var e = this._pointerData[t.id];
                            if (!e.isDown && e.isOver) {
                                if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                                if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputDown && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                                this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                            }
                        }
                    },
                    dragTimeElapsed: function(t) {
                        this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                    },
                    _releasedHandler: function(t) {
                        if (null !== this.sprite) {
                            var e = this._pointerData[t.id];
                            if (e.isDown && t.isUp) {
                                e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                                var i = this.checkPointerOver(t);
                                this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.onChildInputUp && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), e.isOver = i, !i && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                            }
                        }
                    },
                    updateDrag: function(t, e) {
                        if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                        var i = this.globalToLocal(t);
                        if (this.sprite.fixedToCamera) var s = this.game.camera.scale.x * i.x + this._dragPoint.x + this.dragOffset.x,
                            n = this.game.camera.scale.y * i.y + this._dragPoint.y + this.dragOffset.y;
                        else var s = i.x + this._dragPoint.x + this.dragOffset.x,
                            n = i.y + this._dragPoint.y + this.dragOffset.y;
                        if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = s - this.game.camera.x), this.allowVerticalDrag && (this.sprite.cameraOffset.y = n - this.game.camera.y), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                        else {
                            var r = this.game.camera.x - this._pointerData[t.id].camX,
                                o = this.game.camera.y - this._pointerData[t.id].camY;
                            this.allowHorizontalDrag && (this.sprite.x = s + r), this.allowVerticalDrag && (this.sprite.y = n + o), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                        }
                        return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, s, n, this.snapPoint, e), !0
                    },
                    justOver: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                    },
                    justOut: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                    },
                    justPressed: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                    },
                    justReleased: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                    },
                    overDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                    },
                    downDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                    },
                    enableDrag: function(t, e, s, n, r, o) {
                        void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === s && (s = !1), void 0 === n && (n = 255), void 0 === r && (r = null), void 0 === o && (o = null), this._dragPoint = new i.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new i.Point, this.dragFromCenter = t, this.pixelPerfectClick = s, this.pixelPerfectAlpha = n, r && (this.boundsRect = r), o && (this.boundsSprite = o)
                    },
                    disableDrag: function() {
                        if (this._pointerData)
                            for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                        this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                    },
                    startDrag: function(t) {
                        var e = this.sprite.x,
                            s = this.sprite.y,
                            n = this.globalToLocal(t);
                        if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                            if (this.dragFromCenter) {
                                var r = this.sprite.getBounds(),
                                    o = this.globalToLocal(new i.Point(r.centerX, r.centerY));
                                this.sprite.cameraOffset.x = n.x + (this.sprite.cameraOffset.x - o.x), this.sprite.cameraOffset.y = n.y + (this.sprite.cameraOffset.y - o.y)
                            }
                            this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                        } else {
                            if (this.dragFromCenter) {
                                var r = this.sprite.getBounds(),
                                    o = this.globalToLocal(new i.Point(r.centerX, r.centerY));
                                this.sprite.x = n.x + (this.sprite.x - o.x), this.sprite.y = n.y + (this.sprite.y - o.y)
                            }
                            this._dragPoint.setTo(this.sprite.x - n.x, this.sprite.y - n.y)
                        }
                        this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, s), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, s), this._pendingDrag = !1
                    },
                    globalToLocalX: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                    },
                    globalToLocalY: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                    },
                    globalToLocal: function(t) {
                        return this.sprite.parent ? this.game.input.getLocalPosition(this.sprite.parent, {
                            x: t.x,
                            y: t.y
                        }) : t
                    },
                    stopDrag: function(t) {
                        this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                    },
                    setDragLock: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                    },
                    enableSnap: function(t, e, i, s, n, r) {
                        void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = r, this.snapOnDrag = i, this.snapOnRelease = s
                    },
                    disableSnap: function() {
                        this.snapOnDrag = !1, this.snapOnRelease = !1
                    },
                    checkBoundsRect: function() {
                        this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                    },
                    checkBoundsSprite: function() {
                        this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                    }
                }, i.InputHandler.prototype.constructor = i.InputHandler, i.Key = function(t, e) {
                    this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.durationUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new i.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new i.Signal, this._justDown = !1, this._justUp = !1
                }, i.Key.prototype = {
                    update: function() {
                        this._enabled && (this.isDown ? (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) : this.durationUp = this.game.time.time - this.timeUp)
                    },
                    processKeyDown: function(t) {
                        this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.durationUp = this.game.time.time - this.timeUp, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                    },
                    processKeyUp: function(t) {
                        this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this.durationUp = 0, this._justUp = !0, this.onUp.dispatch(this)))
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this.durationUp = -2500, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                    },
                    downDuration: function(t) {
                        return void 0 === t && (t = 50), this.isDown && this.duration < t
                    },
                    upDuration: function(t) {
                        return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                    },
                    justPressed: function() {
                        return this.isDown && 0 === this.duration
                    },
                    justReleased: function() {
                        return !this.isDown && 0 === this.durationUp
                    }
                }, Object.defineProperty(i.Key.prototype, "justDown", {
                    get: function() {
                        var t = this._justDown;
                        return this._justDown = !1, t
                    }
                }), Object.defineProperty(i.Key.prototype, "justUp", {
                    get: function() {
                        var t = this._justUp;
                        return this._justUp = !1, t
                    }
                }), Object.defineProperty(i.Key.prototype, "enabled", {
                    get: function() {
                        return this._enabled
                    },
                    set: function(t) {
                        (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                    }
                }), i.Key.prototype.constructor = i.Key, i.Keyboard = function(t) {
                    this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
                }, i.Keyboard.prototype = {
                    addCallbacks: function(t, e, i, s) {
                        this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== s && null !== s && (this.onPressCallback = s)
                    },
                    removeCallbacks: function() {
                        this.callbackContext = this, this.onDownCallback = null, this.onUpCallback = null, this.onPressCallback = null
                    },
                    addKey: function(t) {
                        return this._keys[t] || (this._keys[t] = new i.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                    },
                    addKeys: function(t) {
                        var e = {};
                        for (var i in t) e[i] = this.addKey(t[i]);
                        return e
                    },
                    removeKey: function(t) {
                        this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                    },
                    createCursorKeys: function() {
                        return this.addKeys({
                            up: i.KeyCode.UP,
                            down: i.KeyCode.DOWN,
                            left: i.KeyCode.LEFT,
                            right: i.KeyCode.RIGHT
                        })
                    },
                    start: function() {
                        if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                            var t = this;
                            this._onKeyDown = function(e) {
                                return t.processKeyDown(e)
                            }, this._onKeyUp = function(e) {
                                return t.processKeyUp(e)
                            }, this._onKeyPress = function(e) {
                                return t.processKeyPress(e)
                            }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                        }
                    },
                    stop: function() {
                        window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                    },
                    destroy: function() {
                        this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                    },
                    addKeyCapture: function(t) {
                        if ("object" == typeof t)
                            for (var e in t) this._capture[t[e]] = !0;
                        else this._capture[t] = !0
                    },
                    removeKeyCapture: function(t) {
                        delete this._capture[t]
                    },
                    clearCaptures: function() {
                        this._capture = {}
                    },
                    update: function() {
                        for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                    },
                    processKeyDown: function(t) {
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            var e = t.keyCode;
                            this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                        }
                    },
                    processKeyPress: function(t) {
                        this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                    },
                    processKeyUp: function(t) {
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            var e = t.keyCode;
                            this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                        }
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.event = null;
                        for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                    },
                    downDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].downDuration(e) : null
                    },
                    upDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].upDuration(e) : null
                    },
                    justPressed: function(t) {
                        return this._keys[t] ? this._keys[t].justPressed() : null
                    },
                    justReleased: function(t) {
                        return this._keys[t] ? this._keys[t].justReleased() : null
                    },
                    isDown: function(t) {
                        return this._keys[t] ? this._keys[t].isDown : null
                    }
                }, Object.defineProperty(i.Keyboard.prototype, "lastChar", {
                    get: function() {
                        return this.event && 32 === this.event.charCode ? "" : this.pressEvent ? String.fromCharCode(this.pressEvent.charCode) : null
                    }
                }), Object.defineProperty(i.Keyboard.prototype, "lastKey", {
                    get: function() {
                        return this._keys[this._k]
                    }
                }), i.Keyboard.prototype.constructor = i.Keyboard, i.KeyCode = {
                    A: "A".charCodeAt(0),
                    B: "B".charCodeAt(0),
                    C: "C".charCodeAt(0),
                    D: "D".charCodeAt(0),
                    E: "E".charCodeAt(0),
                    F: "F".charCodeAt(0),
                    G: "G".charCodeAt(0),
                    H: "H".charCodeAt(0),
                    I: "I".charCodeAt(0),
                    J: "J".charCodeAt(0),
                    K: "K".charCodeAt(0),
                    L: "L".charCodeAt(0),
                    M: "M".charCodeAt(0),
                    N: "N".charCodeAt(0),
                    O: "O".charCodeAt(0),
                    P: "P".charCodeAt(0),
                    Q: "Q".charCodeAt(0),
                    R: "R".charCodeAt(0),
                    S: "S".charCodeAt(0),
                    T: "T".charCodeAt(0),
                    U: "U".charCodeAt(0),
                    V: "V".charCodeAt(0),
                    W: "W".charCodeAt(0),
                    X: "X".charCodeAt(0),
                    Y: "Y".charCodeAt(0),
                    Z: "Z".charCodeAt(0),
                    ZERO: "0".charCodeAt(0),
                    ONE: "1".charCodeAt(0),
                    TWO: "2".charCodeAt(0),
                    THREE: "3".charCodeAt(0),
                    FOUR: "4".charCodeAt(0),
                    FIVE: "5".charCodeAt(0),
                    SIX: "6".charCodeAt(0),
                    SEVEN: "7".charCodeAt(0),
                    EIGHT: "8".charCodeAt(0),
                    NINE: "9".charCodeAt(0),
                    NUMPAD_0: 96,
                    NUMPAD_1: 97,
                    NUMPAD_2: 98,
                    NUMPAD_3: 99,
                    NUMPAD_4: 100,
                    NUMPAD_5: 101,
                    NUMPAD_6: 102,
                    NUMPAD_7: 103,
                    NUMPAD_8: 104,
                    NUMPAD_9: 105,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_ADD: 107,
                    NUMPAD_ENTER: 108,
                    NUMPAD_SUBTRACT: 109,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    F1: 112,
                    F2: 113,
                    F3: 114,
                    F4: 115,
                    F5: 116,
                    F6: 117,
                    F7: 118,
                    F8: 119,
                    F9: 120,
                    F10: 121,
                    F11: 122,
                    F12: 123,
                    F13: 124,
                    F14: 125,
                    F15: 126,
                    COLON: 186,
                    EQUALS: 187,
                    COMMA: 188,
                    UNDERSCORE: 189,
                    PERIOD: 190,
                    QUESTION_MARK: 191,
                    TILDE: 192,
                    OPEN_BRACKET: 219,
                    BACKWARD_SLASH: 220,
                    CLOSED_BRACKET: 221,
                    QUOTES: 222,
                    BACKSPACE: 8,
                    TAB: 9,
                    CLEAR: 12,
                    ENTER: 13,
                    SHIFT: 16,
                    CONTROL: 17,
                    ALT: 18,
                    CAPS_LOCK: 20,
                    ESC: 27,
                    SPACEBAR: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    PLUS: 43,
                    MINUS: 44,
                    INSERT: 45,
                    DELETE: 46,
                    HELP: 47,
                    NUM_LOCK: 144
                };
                for (var n in i.KeyCode) i.KeyCode.hasOwnProperty(n) && !n.match(/[a-z]/) && (i.Keyboard[n] = i.KeyCode[n]);
                i.Component = function() {}, i.Component.Angle = function() {}, i.Component.Angle.prototype = {
                    angle: {
                        get: function() {
                            return i.Math.wrapAngle(i.Math.radToDeg(this.rotation))
                        },
                        set: function(t) {
                            this.rotation = i.Math.degToRad(i.Math.wrapAngle(t))
                        }
                    }
                }, i.Component.Animation = function() {}, i.Component.Animation.prototype = {
                    play: function(t, e, i, s) {
                        if (this.animations) return this.animations.play(t, e, i, s)
                    }
                }, i.Component.AutoCull = function() {}, i.Component.AutoCull.prototype = {
                    autoCull: !1,
                    inCamera: {
                        get: function() {
                            return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                }, i.Component.Bounds = function() {}, i.Component.Bounds.prototype = {
                    offsetX: {
                        get: function() {
                            return this.anchor.x * this.width
                        }
                    },
                    offsetY: {
                        get: function() {
                            return this.anchor.y * this.height
                        }
                    },
                    centerX: {
                        get: function() {
                            return this.x - this.offsetX + .5 * this.width
                        },
                        set: function(t) {
                            this.x = t + this.offsetX - .5 * this.width
                        }
                    },
                    centerY: {
                        get: function() {
                            return this.y - this.offsetY + .5 * this.height
                        },
                        set: function(t) {
                            this.y = t + this.offsetY - .5 * this.height
                        }
                    },
                    left: {
                        get: function() {
                            return this.x - this.offsetX
                        },
                        set: function(t) {
                            this.x = t + this.offsetX
                        }
                    },
                    right: {
                        get: function() {
                            return this.x + this.width - this.offsetX
                        },
                        set: function(t) {
                            this.x = t - this.width + this.offsetX
                        }
                    },
                    top: {
                        get: function() {
                            return this.y - this.offsetY
                        },
                        set: function(t) {
                            this.y = t + this.offsetY
                        }
                    },
                    bottom: {
                        get: function() {
                            return this.y + this.height - this.offsetY
                        },
                        set: function(t) {
                            this.y = t - this.height + this.offsetY
                        }
                    },
                    alignIn: function(t, e, s, n) {
                        switch (void 0 === s && (s = 0), void 0 === n && (n = 0), e) {
                            default:
                                case i.TOP_LEFT:
                                this.left = t.left - s,
                            this.top = t.top - n;
                            break;
                            case i.TOP_CENTER:
                                    this.centerX = t.centerX + s,
                                this.top = t.top - n;
                                break;
                            case i.TOP_RIGHT:
                                    this.right = t.right + s,
                                this.top = t.top - n;
                                break;
                            case i.LEFT_CENTER:
                                    this.left = t.left - s,
                                this.centerY = t.centerY + n;
                                break;
                            case i.CENTER:
                                    this.centerX = t.centerX + s,
                                this.centerY = t.centerY + n;
                                break;
                            case i.RIGHT_CENTER:
                                    this.right = t.right + s,
                                this.centerY = t.centerY + n;
                                break;
                            case i.BOTTOM_LEFT:
                                    this.left = t.left - s,
                                this.bottom = t.bottom + n;
                                break;
                            case i.BOTTOM_CENTER:
                                    this.centerX = t.centerX + s,
                                this.bottom = t.bottom + n;
                                break;
                            case i.BOTTOM_RIGHT:
                                    this.right = t.right + s,
                                this.bottom = t.bottom + n
                        }
                        return this
                    },
                    alignTo: function(t, e, s, n) {
                        switch (void 0 === s && (s = 0), void 0 === n && (n = 0), e) {
                            default:
                                case i.TOP_LEFT:
                                this.left = t.left - s,
                            this.bottom = t.top - n;
                            break;
                            case i.TOP_CENTER:
                                    this.centerX = t.centerX + s,
                                this.bottom = t.top - n;
                                break;
                            case i.TOP_RIGHT:
                                    this.right = t.right + s,
                                this.bottom = t.top - n;
                                break;
                            case i.LEFT_TOP:
                                    this.right = t.left - s,
                                this.top = t.top - n;
                                break;
                            case i.LEFT_CENTER:
                                    this.right = t.left - s,
                                this.centerY = t.centerY + n;
                                break;
                            case i.LEFT_BOTTOM:
                                    this.right = t.left - s,
                                this.bottom = t.bottom + n;
                                break;
                            case i.RIGHT_TOP:
                                    this.left = t.right + s,
                                this.top = t.top - n;
                                break;
                            case i.RIGHT_CENTER:
                                    this.left = t.right + s,
                                this.centerY = t.centerY + n;
                                break;
                            case i.RIGHT_BOTTOM:
                                    this.left = t.right + s,
                                this.bottom = t.bottom + n;
                                break;
                            case i.BOTTOM_LEFT:
                                    this.left = t.left - s,
                                this.top = t.bottom + n;
                                break;
                            case i.BOTTOM_CENTER:
                                    this.centerX = t.centerX + s,
                                this.top = t.bottom + n;
                                break;
                            case i.BOTTOM_RIGHT:
                                    this.right = t.right + s,
                                this.top = t.bottom + n
                        }
                        return this
                    }
                }, i.Group.prototype.alignIn = i.Component.Bounds.prototype.alignIn, i.Group.prototype.alignTo = i.Component.Bounds.prototype.alignTo, i.Component.BringToTop = function() {}, i.Component.BringToTop.prototype.bringToTop = function() {
                    return this.parent && this.parent.bringToTop(this), this
                }, i.Component.BringToTop.prototype.sendToBack = function() {
                    return this.parent && this.parent.sendToBack(this), this
                }, i.Component.BringToTop.prototype.moveUp = function() {
                    return this.parent && this.parent.moveUp(this), this
                }, i.Component.BringToTop.prototype.moveDown = function() {
                    return this.parent && this.parent.moveDown(this), this
                }, i.Component.Core = function() {}, i.Component.Core.skipTypeChecks = !1, i.Component.Core.install = function(t) {
                    i.Utils.mixinPrototype(this, i.Component.Core.prototype), this.components = {};
                    for (var e = 0; e < t.length; e++) {
                        var s = t[e],
                            n = !1;
                        "Destroy" === s && (n = !0), i.Utils.mixinPrototype(this, i.Component[s].prototype, n), this.components[s] = !0
                    }
                }, i.Component.Core.init = function(t, e, s, n, r) {
                    if (!i.Component.Core.skipTypeChecks) {
                        if (!(t instanceof i.Game)) throw new Error("The value passed as the `game` argument (" + t + ") is not an instance of Phaser.Game.");
                        "number" != typeof e && (console.warn("The `x` argument value (%s) should be a number.", e), e = 0), "number" != typeof s && (console.warn("The `y` argument value (%s) should be a number.", s), s = 0)
                    }
                    this.game = t, this.key = n, this.data = {}, this.position.set(e, s), this.world = new i.Point(e, s), this.previousPosition = new i.Point(e, s), this.events = new i.Events(this), this._bounds = new i.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new i.AnimationManager(this)), this.components.LoadTexture && null !== n && this.loadTexture(n, r), this.components.FixedToCamera && (this.cameraOffset = new i.Point(e, s))
                }, i.Component.Core.preUpdate = function() {
                    return this.pendingDestroy ? (this.destroy(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.exists && this.parent.exists ? (this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(), this.preUpdateChildren(), !0) : (this.renderOrderID = -1, !1))
                }, i.Component.Core.prototype = {
                    game: null,
                    name: "",
                    data: {},
                    components: {},
                    z: 0,
                    events: void 0,
                    animations: void 0,
                    key: "",
                    world: null,
                    debug: !1,
                    previousPosition: null,
                    previousRotation: 0,
                    renderOrderID: 0,
                    fresh: !0,
                    pendingDestroy: !1,
                    _bounds: null,
                    _exists: !0,
                    exists: {
                        get: function() {
                            return this._exists
                        },
                        set: function(t) {
                            t ? (this._exists = !0, this.body && this.body.type === i.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === i.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                        }
                    },
                    preUpdateChildren: function() {
                        for (var t = 0; t < this.children.length;) {
                            var e = this.children[t];
                            e.preUpdate(), this === e.parent && t++
                        }
                    },
                    update: function() {},
                    postUpdate: function() {
                        this.customRender && this.key.render(), this.components.PhysicsBody && i.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && i.Component.FixedToCamera.postUpdate.call(this);
                        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                    }
                }, i.Component.Crop = function() {}, i.Component.Crop.prototype = {
                    cropRect: null,
                    _crop: null,
                    crop: function(t, e) {
                        void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new i.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                    },
                    updateCrop: function() {
                        if (this.cropRect) {
                            var t = this.texture.crop.x,
                                e = this.texture.crop.y,
                                s = this.texture.crop.width,
                                n = this.texture.crop.height;
                            this._crop = i.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                            var r = Math.max(this._frame.x, this._crop.x),
                                o = Math.max(this._frame.y, this._crop.y),
                                a = Math.min(this._frame.right, this._crop.right) - r,
                                h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                            this.texture.crop.x = r, this.texture.crop.y = o, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === r && e === o && s === a && n === h || (this.texture.requiresReTint = !0)
                        }
                    }
                }, i.Component.Delta = function() {}, i.Component.Delta.prototype = {
                    deltaX: {
                        get: function() {
                            return this.world.x - this.previousPosition.x
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this.world.y - this.previousPosition.y
                        }
                    },
                    deltaZ: {
                        get: function() {
                            return this.rotation - this.previousRotation
                        }
                    }
                }, i.Component.Destroy = function() {}, i.Component.Destroy.prototype = {
                    destroyPhase: !1,
                    destroy: function(t, e) {
                        if (null !== this.game && !this.destroyPhase) {
                            void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof i.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                            var s = this.children.length;
                            if (t)
                                for (; s--;) this.children[s].destroy(t);
                            else
                                for (; s--;) this.removeChild(this.children[s]);
                            this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), i.Video && this.key instanceof i.Video && this.key.onChangeSource.remove(this.resizeFrame, this), i.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                        }
                    }
                }, i.Events = function(t) {
                    this.parent = t
                }, i.Events.prototype = {
                    destroy: function() {
                        this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                    },
                    onAddedToGroup: null,
                    onRemovedFromGroup: null,
                    onDestroy: null,
                    onKilled: null,
                    onRevived: null,
                    onOutOfBounds: null,
                    onEnterBounds: null,
                    onInputOver: null,
                    onInputOut: null,
                    onInputDown: null,
                    onInputUp: null,
                    onDragStart: null,
                    onDragUpdate: null,
                    onDragStop: null,
                    onAnimationStart: null,
                    onAnimationComplete: null,
                    onAnimationLoop: null
                }, i.Events.prototype.constructor = i.Events;
                for (var r in i.Events.prototype) i.Events.prototype.hasOwnProperty(r) && 0 === r.indexOf("on") && null === i.Events.prototype[r] && function(t, e) {
                    "use strict";
                    Object.defineProperty(i.Events.prototype, t, {
                        get: function() {
                            return this[e] || (this[e] = new i.Signal)
                        }
                    }), i.Events.prototype[t + "$dispatch"] = function() {
                        return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
                    }
                }(r, "_" + r);
                i.Component.FixedToCamera = function() {}, i.Component.FixedToCamera.postUpdate = function() {
                    this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
                }, i.Component.FixedToCamera.prototype = {
                    _fixedToCamera: !1,
                    fixedToCamera: {
                        get: function() {
                            return this._fixedToCamera
                        },
                        set: function(t) {
                            t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                        }
                    },
                    cameraOffset: new i.Point
                }, i.Component.Health = function() {}, i.Component.Health.prototype = {
                    health: 1,
                    maxHealth: 100,
                    damage: function(t) {
                        return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
                    },
                    setHealth: function(t) {
                        return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
                    },
                    heal: function(t) {
                        return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
                    }
                }, i.Component.InCamera = function() {}, i.Component.InCamera.prototype = {
                    inCamera: {
                        get: function() {
                            return this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                }, i.Component.InputEnabled = function() {}, i.Component.InputEnabled.prototype = {
                    input: null,
                    inputEnabled: {
                        get: function() {
                            return this.input && this.input.enabled
                        },
                        set: function(t) {
                            t ? null === this.input ? (this.input = new i.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                        }
                    }
                }, i.Component.InWorld = function() {}, i.Component.InWorld.preUpdate = function() {
                    if (this.pendingDestroy) return this.destroy(), !1;
                    if (this.autoCull || this.checkWorldBounds) {
                        if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                            if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                            else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                        if (this.checkWorldBounds)
                            if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                            else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
                    }
                    return !0
                }, i.Component.InWorld.prototype = {
                    checkWorldBounds: !1,
                    outOfBoundsKill: !1,
                    outOfCameraBoundsKill: !1,
                    _outOfBoundsFired: !1,
                    inWorld: {
                        get: function() {
                            return this.game.world.bounds.intersects(this.getBounds())
                        }
                    }
                }, i.Component.LifeSpan = function() {}, i.Component.LifeSpan.preUpdate = function() {
                    return this.pendingDestroy ? (this.destroy(), !1) : !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
                }, i.Component.LifeSpan.prototype = {
                    alive: !0,
                    lifespan: 0,
                    revive: function(t) {
                        return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
                    },
                    kill: function() {
                        return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
                    }
                }, i.Component.LoadTexture = function() {}, i.Component.LoadTexture.prototype = {
                    customRender: !1,
                    _frame: null,
                    loadTexture: function(t, e, s) {
                        t === i.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (s || void 0 === s) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                        var n = this.game.cache,
                            r = !0,
                            o = !this.texture.baseTexture.scaleMode;
                        if (i.RenderTexture && t instanceof i.RenderTexture) this.key = t.key, this.setTexture(t);
                        else if (i.BitmapData && t instanceof i.BitmapData) this.customRender = !0, this.setTexture(t.texture), r = n.hasFrameData(t.key, i.Cache.BITMAPDATA) ? !this.animations.loadFrameData(n.getFrameData(t.key, i.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                        else if (i.Video && t instanceof i.Video) {
                            this.customRender = !0;
                            var a = t.texture.valid;
                            this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a
                        } else if (i.Tilemap && t instanceof i.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                        else if (t instanceof PIXI.Texture) this.setTexture(t);
                        else {
                            var h = n.getImage(t, !0);
                            this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, r = !this.animations.loadFrameData(h.frameData, e)
                        }
                        r && (this._frame = i.Rectangle.clone(this.texture.frame)), o || (this.texture.baseTexture.scaleMode = 1)
                    },
                    setFrame: function(t) {
                        this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                            x: t.spriteSourceSizeX,
                            y: t.spriteSourceSizeY,
                            width: t.sourceSizeW,
                            height: t.sourceSizeH
                        }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), t.rotated && (this.texture.rotated = !0), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
                    },
                    resizeFrame: function(t, e, i) {
                        this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
                    },
                    resetFrame: function() {
                        this._frame && this.setFrame(this._frame)
                    },
                    frame: {
                        get: function() {
                            return this.animations.frame
                        },
                        set: function(t) {
                            this.animations.frame = t
                        }
                    },
                    frameName: {
                        get: function() {
                            return this.animations.frameName
                        },
                        set: function(t) {
                            this.animations.frameName = t
                        }
                    }
                }, i.Component.Overlap = function() {}, i.Component.Overlap.prototype = {
                    overlap: function(t) {
                        return i.Rectangle.intersects(this.getBounds(), t.getBounds())
                    }
                }, i.Component.PhysicsBody = function() {}, i.Component.PhysicsBody.preUpdate = function() {
                    return this.pendingDestroy ? (this.destroy(), !1) : this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, this.preUpdateChildren(), !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
                }, i.Component.PhysicsBody.postUpdate = function() {
                    this.exists && this.body && this.body.postUpdate()
                }, i.Component.PhysicsBody.prototype = {
                    body: null,
                    x: {
                        get: function() {
                            return this.position.x
                        },
                        set: function(t) {
                            this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                        }
                    },
                    y: {
                        get: function() {
                            return this.position.y
                        },
                        set: function(t) {
                            this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                        }
                    }
                }, i.Component.Reset = function() {}, i.Component.Reset.prototype.reset = function(t, e, i) {
                    return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
                }, i.Component.ScaleMinMax = function() {}, i.Component.ScaleMinMax.prototype = {
                    transformCallback: null,
                    transformCallbackContext: this,
                    scaleMin: null,
                    scaleMax: null,
                    checkTransform: function(t) {
                        this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
                    },
                    setScaleMinMax: function(t, e, s, n) {
                        void 0 === e ? e = s = n = t : void 0 === s && (s = n = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new i.Point(t, e), null === s ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(s, n) : this.scaleMax = new i.Point(s, n), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
                    }
                }, i.Component.Smoothed = function() {}, i.Component.Smoothed.prototype = {
                    smoothed: {
                        get: function() {
                            return !this.texture.baseTexture.scaleMode
                        },
                        set: function(t) {
                            t ? this.texture && (this.texture.baseTexture.scaleMode = 0, this.texture.baseTexture.dirty()) : this.texture && (this.texture.baseTexture.scaleMode = 1, this.texture.baseTexture.dirty())
                        }
                    }
                }, i.GameObjectFactory = function(t) {
                    this.game = t, this.world = this.game.world
                }, i.GameObjectFactory.prototype = {
                    existing: function(t) {
                        return this.world.add(t)
                    },
                    weapon: function(t, e, s, n, r) {
                        var o = this.game.plugins.add(i.Weapon);
                        return r && (o.bulletClass = r), o.createBullets(t, e, s, n), o
                    },
                    image: function(t, e, s, n, r) {
                        return void 0 === r && (r = this.world), r.add(new i.Image(this.game, t, e, s, n))
                    },
                    sprite: function(t, e, s, n, r) {
                        return void 0 === r && (r = this.world), r.add(new i.Sprite(this.game, t, e, s, n))
                    },
                    creature: function(t, e, s, n, r) {
                        void 0 === r && (r = this.world);
                        var o = new i.Creature(this.game, t, e, s, n);
                        return r.add(o), o
                    },
                    tween: function(t) {
                        return this.game.tweens.create(t)
                    },
                    group: function(t, e, s, n, r) {
                        return new i.Group(this.game, t, e, s, n, r)
                    },
                    physicsGroup: function(t, e, s, n) {
                        return new i.Group(this.game, e, s, n, !0, t)
                    },
                    spriteBatch: function(t, e, s) {
                        return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === s && (s = !1), new i.SpriteBatch(this.game, t, e, s)
                    },
                    audio: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    sound: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    audioSprite: function(t) {
                        return this.game.sound.addSprite(t)
                    },
                    tileSprite: function(t, e, s, n, r, o, a) {
                        return void 0 === a && (a = this.world), a.add(new i.TileSprite(this.game, t, e, s, n, r, o))
                    },
                    rope: function(t, e, s, n, r, o) {
                        return void 0 === o && (o = this.world), o.add(new i.Rope(this.game, t, e, s, n, r))
                    },
                    text: function(t, e, s, n, r) {
                        return void 0 === r && (r = this.world), r.add(new i.Text(this.game, t, e, s, n))
                    },
                    button: function(t, e, s, n, r, o, a, h, u, l) {
                        return void 0 === l && (l = this.world), l.add(new i.Button(this.game, t, e, s, n, r, o, a, h, u))
                    },
                    graphics: function(t, e, s) {
                        return void 0 === s && (s = this.world), s.add(new i.Graphics(this.game, t, e))
                    },
                    emitter: function(t, e, s) {
                        return this.game.particles.add(new i.Particles.Arcade.Emitter(this.game, t, e, s))
                    },
                    retroFont: function(t, e, s, n, r, o, a, h, u) {
                        return new i.RetroFont(this.game, t, e, s, n, r, o, a, h, u)
                    },
                    bitmapText: function(t, e, s, n, r, o) {
                        return void 0 === o && (o = this.world), o.add(new i.BitmapText(this.game, t, e, s, n, r))
                    },
                    tilemap: function(t, e, s, n, r) {
                        return new i.Tilemap(this.game, t, e, s, n, r)
                    },
                    renderTexture: function(t, e, s, n) {
                        void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === n && (n = !1);
                        var r = new i.RenderTexture(this.game, t, e, s);
                        return n && this.game.cache.addRenderTexture(s, r), r
                    },
                    video: function(t, e) {
                        return new i.Video(this.game, t, e)
                    },
                    bitmapData: function(t, e, s, n) {
                        void 0 === n && (n = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                        var r = new i.BitmapData(this.game, s, t, e);
                        return n && this.game.cache.addBitmapData(s, r), r
                    },
                    filter: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1);
                        return (t = new i.Filter[t](this.game)).init.apply(t, e), t
                    },
                    plugin: function(t) {
                        return this.game.plugins.add(t)
                    }
                }, i.GameObjectFactory.prototype.constructor = i.GameObjectFactory, i.GameObjectCreator = function(t) {
                    this.game = t, this.world = this.game.world
                }, i.GameObjectCreator.prototype = {
                    image: function(t, e, s, n) {
                        return new i.Image(this.game, t, e, s, n)
                    },
                    sprite: function(t, e, s, n) {
                        return new i.Sprite(this.game, t, e, s, n)
                    },
                    tween: function(t) {
                        return new i.Tween(t, this.game, this.game.tweens)
                    },
                    group: function(t, e, s, n, r) {
                        return new i.Group(this.game, t, e, s, n, r)
                    },
                    spriteBatch: function(t, e, s) {
                        return void 0 === e && (e = "group"), void 0 === s && (s = !1), new i.SpriteBatch(this.game, t, e, s)
                    },
                    audio: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    audioSprite: function(t) {
                        return this.game.sound.addSprite(t)
                    },
                    sound: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    tileSprite: function(t, e, s, n, r, o) {
                        return new i.TileSprite(this.game, t, e, s, n, r, o)
                    },
                    rope: function(t, e, s, n, r) {
                        return new i.Rope(this.game, t, e, s, n, r)
                    },
                    text: function(t, e, s, n) {
                        return new i.Text(this.game, t, e, s, n)
                    },
                    button: function(t, e, s, n, r, o, a, h, u) {
                        return new i.Button(this.game, t, e, s, n, r, o, a, h, u)
                    },
                    graphics: function(t, e) {
                        return new i.Graphics(this.game, t, e)
                    },
                    emitter: function(t, e, s) {
                        return new i.Particles.Arcade.Emitter(this.game, t, e, s)
                    },
                    retroFont: function(t, e, s, n, r, o, a, h, u) {
                        return new i.RetroFont(this.game, t, e, s, n, r, o, a, h, u)
                    },
                    bitmapText: function(t, e, s, n, r, o) {
                        return new i.BitmapText(this.game, t, e, s, n, r, o)
                    },
                    tilemap: function(t, e, s, n, r) {
                        return new i.Tilemap(this.game, t, e, s, n, r)
                    },
                    renderTexture: function(t, e, s, n) {
                        void 0 !== s && "" !== s || (s = this.game.rnd.uuid()), void 0 === n && (n = !1);
                        var r = new i.RenderTexture(this.game, t, e, s);
                        return n && this.game.cache.addRenderTexture(s, r), r
                    },
                    bitmapData: function(t, e, s, n) {
                        void 0 === n && (n = !1), void 0 !== s && "" !== s || (s = this.game.rnd.uuid());
                        var r = new i.BitmapData(this.game, s, t, e);
                        return n && this.game.cache.addBitmapData(s, r), r
                    },
                    filter: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1);
                        return (t = new i.Filter[t](this.game)).init.apply(t, e), t
                    }
                }, i.GameObjectCreator.prototype.constructor = i.GameObjectCreator, i.Sprite = function(t, e, s, n, r) {
                    e = e || 0, s = s || 0, n = n || null, r = r || null, this.type = i.SPRITE, this.physicsType = i.SPRITE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, s, n, r)
                }, i.Sprite.prototype = Object.create(PIXI.Sprite.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Component.Core.install.call(i.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Sprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Sprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Sprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Sprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Sprite.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, i.Image = function(t, e, s, n, r) {
                    e = e || 0, s = s || 0, n = n || null, r = r || null, this.type = i.IMAGE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, s, n, r)
                }, i.Image.prototype = Object.create(PIXI.Sprite.prototype), i.Image.prototype.constructor = i.Image, i.Component.Core.install.call(i.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), i.Image.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Image.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Image.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Image.prototype.preUpdate = function() {
                    return !(!this.preUpdateInWorld() || !this.preUpdateLifeSpan()) && this.preUpdateCore()
                }, i.Button = function(t, e, s, n, r, o, a, h, u, l) {
                    e = e || 0, s = s || 0, n = n || null, r = r || null, o = o || this, i.Image.call(this, t, e, s, n, h), this.type = i.BUTTON, this.physicsType = i.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new i.Signal, this.onInputOut = new i.Signal, this.onInputDown = new i.Signal, this.onInputUp = new i.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = i.PointerMode.CONTACT, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, u, l), null !== r && this.onInputUp.add(r, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this)
                }, i.Button.prototype = Object.create(i.Image.prototype), i.Button.prototype.constructor = i.Button;
                return i.Button.prototype.clearFrames = function() {
                    this.setFrames(null, null, null, null)
                }, i.Button.prototype.setStateFrame = function(t, e, i) {
                    var s = "_on" + t + "Frame";
                    null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
                }, i.Button.prototype.changeStateFrame = function(t) {
                    if (this.freezeFrames) return !1;
                    var e = this["_on" + t + "Frame"];
                    return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0)
                }, i.Button.prototype.setFrames = function(t, e, i, s) {
                    this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", s, this.input.pointerUp())
                }, i.Button.prototype.setStateSound = function(t, e, s) {
                    var n = "on" + t + "Sound",
                        r = "on" + t + "SoundMarker";
                    e instanceof i.Sound || e instanceof i.AudioSprite ? (this[n] = e, this[r] = "string" == typeof s ? s : "") : (this[n] = null, this[r] = "")
                }, i.Button.prototype.playStateSound = function(t) {
                    var e = this["on" + t + "Sound"];
                    if (e) {
                        var i = this["on" + t + "SoundMarker"];
                        return e.play(i), !0
                    }
                    return !1
                }, i.Button.prototype.setSounds = function(t, e, i, s, n, r, o, a) {
                    this.setStateSound("Over", t, e), this.setStateSound("Out", n, r), this.setStateSound("Down", i, s), this.setStateSound("Up", o, a)
                }, i.Button.prototype.setOverSound = function(t, e) {
                    this.setStateSound("Over", t, e)
                }, i.Button.prototype.setOutSound = function(t, e) {
                    this.setStateSound("Out", t, e)
                }, i.Button.prototype.setDownSound = function(t, e) {
                    this.setStateSound("Down", t, e)
                }, i.Button.prototype.setUpSound = function(t, e) {
                    this.setStateSound("Up", t, e)
                }, i.Button.prototype.onInputOverHandler = function(t, e) {
                    e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
                }, i.Button.prototype.onInputOutHandler = function(t, e) {
                    this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
                }, i.Button.prototype.onInputDownHandler = function(t, e) {
                    this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
                }, i.Button.prototype.onInputUpHandler = function(t, e, i) {
                    this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out")))
                }, i.SpriteBatch = function(t, e, s, n) {
                    void 0 !== e && null !== e || (e = t.world), i.Group.call(this, t, e, s, n), this.type = i.SPRITEBATCH, this.fastSpriteBatch = null, this.ready = !1
                }, i.SpriteBatch.prototype = Object.create(i.Group.prototype), i.SpriteBatch.prototype.constructor = i.SpriteBatch, i.SpriteBatch.prototype._renderWebGL = function(t) {
                    !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || (this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(t.gl), this.ready = !0), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
                }, i.SpriteBatch.prototype._renderCanvas = function(t) {
                    if (this.visible && !(this.alpha <= 0) && this.children.length) {
                        var e = t.context;
                        e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                        for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                            var r = this.children[n];
                            if (r.visible) {
                                var o = r.texture,
                                    a = o.frame;
                                if (e.globalAlpha = this.worldAlpha * r.alpha, r.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * (-a.width * r.scale.x) + r.position.x + .5 + t.shakeX | 0, r.anchor.y * (-a.height * r.scale.y) + r.position.y + .5 + t.shakeY | 0, a.width * r.scale.x, a.height * r.scale.y);
                                else {
                                    s || (s = !0), r.displayObjectUpdateTransform();
                                    var h = r.worldTransform,
                                        u = h.tx * t.resolution + t.shakeX,
                                        l = h.ty * t.resolution + t.shakeY;
                                    t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | u, 0 | l) : e.setTransform(h.a, h.b, h.c, h.d, u, l), e.drawImage(o.baseTexture.source, a.x, a.y, a.width, a.height, r.anchor.x * -a.width + .5 | 0, r.anchor.y * -a.height + .5 | 0, a.width, a.height)
                                }
                            }
                        }
                    }
                }, i.BitmapData = function(t, e, s, n, r) {
                    void 0 !== s && 0 !== s || (s = 256), void 0 !== n && 0 !== n || (n = 256), void 0 === r && (r = !1), this.game = t, this.key = e, this.width = s, this.height = n, this.canvas = i.Canvas.create(this, s, n, null, r), this.context = this.canvas.getContext("2d", {
                        alpha: !0
                    }), this.ctx = this.context, this.smoothProperty = t.renderType === i.CANVAS ? t.renderer.renderSession.smoothProperty : i.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, s, n), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas, null, this.game.resolution), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new i.FrameData, this.textureFrame = this.frameData.addFrame(new i.Frame(0, 0, 0, s, n, "bitmapData")), this.texture.frame = this.textureFrame, this.type = i.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new i.Point, this._size = new i.Point, this._scale = new i.Point, this._rotate = 0, this._alpha = {
                        prev: 1,
                        current: 1
                    }, this._anchor = new i.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new i.Circle, this._swapCanvas = void 0
                }, i.BitmapData.prototype = {
                    move: function(t, e, i) {
                        return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
                    },
                    moveH: function(t, e) {
                        void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = i.CanvasPool.create(this, this.width, this.height));
                        var s = this._swapCanvas.getContext("2d"),
                            n = this.height,
                            r = this.canvas;
                        if (s.clearRect(0, 0, this.width, this.height), t < 0) {
                            t = Math.abs(t);
                            o = this.width - t;
                            e && s.drawImage(r, 0, 0, t, n, o, 0, t, n), s.drawImage(r, t, 0, o, n, 0, 0, o, n)
                        } else {
                            var o = this.width - t;
                            e && s.drawImage(r, o, 0, t, n, 0, 0, t, n), s.drawImage(r, 0, 0, o, n, t, 0, o, n)
                        }
                        return this.clear(), this.copy(this._swapCanvas)
                    },
                    moveV: function(t, e) {
                        void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = i.CanvasPool.create(this, this.width, this.height));
                        var s = this._swapCanvas.getContext("2d"),
                            n = this.width,
                            r = this.canvas;
                        if (s.clearRect(0, 0, this.width, this.height), t < 0) {
                            t = Math.abs(t);
                            o = this.height - t;
                            e && s.drawImage(r, 0, 0, n, t, 0, o, n, t), s.drawImage(r, 0, t, n, o, 0, 0, n, o)
                        } else {
                            var o = this.height - t;
                            e && s.drawImage(r, 0, o, n, t, 0, 0, n, t), s.drawImage(r, 0, 0, n, o, 0, t, n, o)
                        }
                        return this.clear(), this.copy(this._swapCanvas)
                    },
                    add: function(t) {
                        if (Array.isArray(t))
                            for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                        else t.loadTexture(this);
                        return this
                    },
                    load: function(t) {
                        if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
                    },
                    clear: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
                    },
                    fill: function(t, e, i, s) {
                        return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
                    },
                    generateTexture: function(t, e, i) {
                        var s = this.game.cache,
                            n = new Image; n.crossOrigin="anonymous";
                        if (e && (n.onload = function() {
                                var r = s.addImage(t, "", n),
                                    o = new PIXI.Texture(r.base);
                                e.call(i || null, o), n.onload = null
                            }), n.src = this.canvas.toDataURL("image/png"), !e) {
                            var r = s.addImage(t, "", n);
                            return new PIXI.Texture(r.base)
                        }
                        return null
                    },
                    resize: function(t, e) {
                        return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
                    },
                    update: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
                    },
                    processPixelRGB: function(t, e, s, n, r, o) {
                        void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = this.width), void 0 === o && (o = this.height);
                        for (var a = s + r, h = n + o, u = i.Color.createColor(), l = {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }, c = !1, d = n; d < h; d++)
                            for (var p = s; p < a; p++) i.Color.unpackPixel(this.getPixel32(p, d), u), !1 !== (l = t.call(e, u, p, d)) && null !== l && void 0 !== l && (this.setPixel32(p, d, l.r, l.g, l.b, l.a, !1), c = !0);
                        return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                    },
                    processPixel: function(t, e, i, s, n, r) {
                        void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height);
                        for (var o = i + n, a = s + r, h = 0, u = 0, l = !1, c = s; c < a; c++)
                            for (var d = i; d < o; d++) h = this.getPixel32(d, c), (u = t.call(e, h, d, c)) !== h && (this.pixels[c * this.width + d] = u, l = !0);
                        return l && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                    },
                    replaceRGB: function(t, e, s, n, r, o, a, h, u) {
                        var l = 0,
                            c = 0,
                            d = this.width,
                            p = this.height,
                            f = i.Color.packPixel(t, e, s, n);
                        void 0 !== u && u instanceof i.Rectangle && (l = u.x, c = u.y, d = u.width, p = u.height);
                        for (var g = 0; g < p; g++)
                            for (var m = 0; m < d; m++) this.getPixel32(l + m, c + g) === f && this.setPixel32(l + m, c + g, r, o, a, h, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    },
                    setHSL: function(t, e, s, n) {
                        var r = t || 0 === t,
                            o = e || 0 === e,
                            a = s || 0 === s;
                        if (r || o || a) {
                            void 0 === n && (n = new i.Rectangle(0, 0, this.width, this.height));
                            for (var h = i.Color.createColor(), u = n.y; u < n.bottom; u++)
                                for (var l = n.x; l < n.right; l++) i.Color.unpackPixel(this.getPixel32(l, u), h, !0), r && (h.h = t), o && (h.s = e), a && (h.l = s), i.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(l, u, h.r, h.g, h.b, h.a, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                        }
                    },
                    shiftHSL: function(t, e, s, n) {
                        if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== s && null !== s || (s = !1), t || e || s) {
                            void 0 === n && (n = new i.Rectangle(0, 0, this.width, this.height));
                            for (var r = i.Color.createColor(), o = n.y; o < n.bottom; o++)
                                for (var a = n.x; a < n.right; a++) i.Color.unpackPixel(this.getPixel32(a, o), r, !0), t && (r.h = this.game.math.wrap(r.h + t, 0, 1)), e && (r.s = this.game.math.clamp(r.s + e, 0, 1)), s && (r.l = this.game.math.clamp(r.l + s, 0, 1)), i.Color.HSLtoRGB(r.h, r.s, r.l, r), this.setPixel32(a, o, r.r, r.g, r.b, r.a, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                        }
                    },
                    setPixel32: function(t, e, s, n, r, o, a) {
                        return void 0 === a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (i.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = o << 24 | r << 16 | n << 8 | s : this.pixels[e * this.width + t] = s << 24 | n << 16 | r << 8 | o, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
                    },
                    setPixel: function(t, e, i, s, n, r) {
                        return this.setPixel32(t, e, i, s, n, 255, r)
                    },
                    getPixel: function(t, e, s) {
                        s || (s = i.Color.createColor());
                        var n = ~~(t + e * this.width);
                        return n *= 4, s.r = this.data[n], s.g = this.data[++n], s.b = this.data[++n], s.a = this.data[++n], s
                    },
                    getPixel32: function(t, e) {
                        if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
                    },
                    getPixelRGB: function(t, e, s, n, r) {
                        return i.Color.unpackPixel(this.getPixel32(t, e), s, n, r)
                    },
                    getPixels: function(t) {
                        return this.context.getImageData(t.x, t.y, t.width, t.height)
                    },
                    getFirstPixel: function(t) {
                        void 0 === t && (t = 0);
                        var e = i.Color.createColor(),
                            s = 0,
                            n = 0,
                            r = 1,
                            o = !1;
                        1 === t ? (r = -1, n = this.height) : 3 === t && (r = -1, s = this.width);
                        do {
                            i.Color.unpackPixel(this.getPixel32(s, n), e), 0 === t || 1 === t ? ++s === this.width && (s = 0, ((n += r) >= this.height || n <= 0) && (o = !0)) : 2 !== t && 3 !== t || ++n === this.height && (n = 0, ((s += r) >= this.width || s <= 0) && (o = !0))
                        } while (0 === e.a && !o);
                        return e.x = s, e.y = n, e
                    },
                    getBounds: function(t) {
                        return void 0 === t && (t = new i.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t)
                    },
                    addToWorld: function(t, e, i, s, n, r) {
                        n = n || 1, r = r || 1;
                        var o = this.game.add.image(t, e, this);
                        return o.anchor.set(i, s), o.scale.set(n, r), o
                    },
                    copy: function(t, e, s, n, r, o, a, h, u, l, c, d, p, f, g, m, y) {
                        if (void 0 !== t && null !== t || (t = this), t instanceof i.RenderTexture && (t = t.getCanvas()), this._image = t, t instanceof i.Sprite || t instanceof i.Image || t instanceof i.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof i.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== o && null !== o || (o = t.x), void 0 !== a && null !== a || (a = t.y), t.texture.trim && (o += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                        else {
                            if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof i.BitmapData) this._image = t.canvas;
                            else if ("string" == typeof t) {
                                if (null === (t = this.game.cache.getImage(t))) return;
                                this._image = t
                            }
                            this._size.set(this._image.width, this._image.height)
                        }
                        if (void 0 !== e && null !== e || (e = 0), void 0 !== s && null !== s || (s = 0), n && (this._size.x = n), r && (this._size.y = r), void 0 !== o && null !== o || (o = e), void 0 !== a && null !== a || (a = s), void 0 !== h && null !== h || (h = this._size.x), void 0 !== u && null !== u || (u = this._size.y), "number" == typeof l && (this._rotate = l), "number" == typeof c && (this._anchor.x = c), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === m && (m = null), void 0 === y && (y = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                            var v = this.context;
                            return this._alpha.prev = v.globalAlpha, v.save(), v.globalAlpha = this._alpha.current, m && (this.op = m), y && (o |= 0, a |= 0), v.translate(o, a), v.scale(this._scale.x, this._scale.y), v.rotate(this._rotate), v.drawImage(this._image, this._pos.x + e, this._pos.y + s, this._size.x, this._size.y, -h * this._anchor.x, -u * this._anchor.y, h, u), v.restore(), v.globalAlpha = this._alpha.prev, this.dirty = !0, this
                        }
                    },
                    copyTransform: function(t, e, s) {
                        if (void 0 === e && (e = null), void 0 === s && (s = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                        var n = t.worldTransform;
                        if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === n.a || 0 === n.d || 0 === this._size.x || 0 === this._size.y) return this;
                        t.texture instanceof i.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                        var r = n.tx,
                            o = n.ty;
                        t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), s && (r |= 0, o |= 0);
                        var a = this.context;
                        return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, e && (this.op = e), a[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(n.a, n.b, n.c, n.d, r, o), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this
                    },
                    copyRect: function(t, e, i, s, n, r, o) {
                        return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, r, o)
                    },
                    draw: function(t, e, i, s, n, r, o) {
                        return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, r, o)
                    },
                    drawGroup: function(t, e, i) {
                        return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
                    },
                    drawGroupProxy: function(t, e, s) {
                        if (t.hasOwnProperty("texture") && this.copyTransform(t, e, s), t.type === i.GROUP && t.exists) this.drawGroup(t, e, s);
                        else if (t.hasOwnProperty("children") && t.children.length > 0)
                            for (var n = 0; n < t.children.length; n++) t.children[n].exists && this.copyTransform(t.children[n], e, s)
                    },
                    drawFull: function(t, e, s) {
                        if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                        if (t.type !== i.GROUP && t.type !== i.EMITTER && t.type !== i.BITMAPTEXT)
                            if (t.type === i.GRAPHICS) {
                                var n = t.getBounds();
                                this.ctx.save(), this.ctx.translate(n.x, n.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                            } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, s);
                        if (t.children)
                            for (var r = 0; r < t.children.length; r++) this.drawFull(t.children[r], e, s);
                        return this
                    },
                    shadow: function(t, e, i, s) {
                        var n = this.context;
                        return void 0 === t || null === t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = e || 5, n.shadowOffsetX = i || 10, n.shadowOffsetY = s || 10), this
                    },
                    alphaMask: function(t, e, i, s) {
                        return void 0 === s || null === s ? this.draw(e).blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this
                    },
                    extract: function(t, e, i, s, n, r, o, a, h) {
                        return void 0 === n && (n = 255), void 0 === r && (r = !1), void 0 === o && (o = e), void 0 === a && (a = i), void 0 === h && (h = s), r && t.resize(this.width, this.height), this.processPixelRGB(function(r, u, l) {
                            return r.r === e && r.g === i && r.b === s && t.setPixel32(u, l, o, a, h, n, !1), !1
                        }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
                    },
                    rect: function(t, e, i, s, n) {
                        return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s), this
                    },
                    text: function(t, e, i, s, n, r) {
                        void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === r && (r = !0);
                        var o = this.context,
                            a = o.font;
                        return o.font = s, r && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = n, o.fillText(t, e, i), o.font = a, this
                    },
                    circle: function(t, e, i, s) {
                        var n = this.context;
                        return void 0 !== s && (n.fillStyle = s), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this
                    },
                    line: function(t, e, i, s, n, r) {
                        void 0 === n && (n = "#fff"), void 0 === r && (r = 1);
                        var o = this.context;
                        return o.beginPath(), o.moveTo(t, e), o.lineTo(i, s), o.lineWidth = r, o.strokeStyle = n, o.stroke(), o.closePath(), this
                    },
                    polygon: function(t, e, i, s) {
                        void 0 === s && (s = "#fff"), void 0 === i && (i = 0);
                        var n = this.context;
                        e && (n.fillStyle = e), i && (n.lineWidth = i, n.strokeStyle = s), n.beginPath(), n.moveTo(t[0].x, t[0].y);
                        for (var r = 1, o = t.length; r < o; r++) {
                            var a = t[r];
                            n.lineTo(a.x, a.y)
                        }
                        return n.closePath(), e && n.fill(), i && n.stroke(), this
                    },
                    textureLine: function(t, e, s) {
                        if (void 0 === s && (s = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                            var n = t.length;
                            "no-repeat" === s && n > e.width && (n = e.width);
                            var r = this.context;
                            return r.fillStyle = r.createPattern(e, s), this._circle = new i.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), r.save(), r.translate(this._pos.x, this._pos.y), r.rotate(t.angle), r.fillRect(0, 0, n, e.height), r.restore(), this.dirty = !0, this
                        }
                    },
                    render: function() {
                        return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
                    },
                    destroy: function() {
                        this.frameData.destroy(), this.texture.destroy(!0), i.CanvasPool.remove(this)
                    },
                    blendReset: function() {
                        return this.op = "source-over", this
                    },
                    blendSourceOver: function() {
                        return this.op = "source-over", this
                    },
                    blendSourceIn: function() {
                        return this.op = "source-in", this
                    },
                    blendSourceOut: function() {
                        return this.op = "source-out", this
                    },
                    blendSourceAtop: function() {
                        return this.op = "source-atop", this
                    },
                    blendDestinationOver: function() {
                        return this.op = "destination-over", this
                    },
                    blendDestinationIn: function() {
                        return this.op = "destination-in", this
                    },
                    blendDestinationOut: function() {
                        return this.op = "destination-out", this
                    },
                    blendDestinationAtop: function() {
                        return this.op = "destination-atop", this
                    },
                    blendXor: function() {
                        return this.op = "xor", this
                    },
                    blendAdd: function() {
                        return this.op = "lighter", this
                    },
                    blendMultiply: function() {
                        return this.op = "multiply", this
                    },
                    blendScreen: function() {
                        return this.op = "screen", this
                    },
                    blendOverlay: function() {
                        return this.op = "overlay", this
                    },
                    blendDarken: function() {
                        return this.op = "darken", this
                    },
                    blendLighten: function() {
                        return this.op = "lighten", this
                    },
                    blendColorDodge: function() {
                        return this.op = "color-dodge", this
                    },
                    blendColorBurn: function() {
                        return this.op = "color-burn", this
                    },
                    blendHardLight: function() {
                        return this.op = "hard-light", this
                    },
                    blendSoftLight: function() {
                        return this.op = "soft-light", this
                    },
                    blendDifference: function() {
                        return this.op = "difference", this
                    },
                    blendExclusion: function() {
                        return this.op = "exclusion", this
                    },
                    blendHue: function() {
                        return this.op = "hue", this
                    },
                    blendSaturation: function() {
                        return this.op = "saturation", this
                    },
                    blendColor: function() {
                        return this.op = "color", this
                    },
                    blendLuminosity: function() {
                        return this.op = "luminosity", this
                    },
                    copyBitmapData: function(t, e, i) {
                        t.update();
                        for (var s, n = 0; n < t.height; n++) {
                            s = (i + n) * this.width + e;
                            for (var r = 0; r < t.width; r++) this.pixels[s + r] = t.pixels[n * t.width + r]
                        }
                        return this
                    }
                }, Object.defineProperty(i.BitmapData.prototype, "smoothed", {
                    get: function() {
                        i.Canvas.getSmoothingEnabled(this.context)
                    },
                    set: function(t) {
                        i.Canvas.setSmoothingEnabled(this.context, t)
                    }
                }), Object.defineProperty(i.BitmapData.prototype, "op", {
                    get: function() {
                        return this.context.globalCompositeOperation
                    },
                    set: function(t) {
                        this.context.globalCompositeOperation = t
                    }
                }), i.BitmapData.getTransform = function(t, e, i, s, n, r) {
                    return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof n && (n = 0), "number" != typeof r && (r = 0), {
                        sx: i,
                        sy: s,
                        scaleX: i,
                        scaleY: s,
                        skewX: n,
                        skewY: r,
                        translateX: t,
                        translateY: e,
                        tx: t,
                        ty: e
                    }
                }, i.BitmapData.prototype.constructor = i.BitmapData, i.EarCut = {}, i.EarCut.Triangulate = function(t, e, s) {
                    s = s || 2;
                    var n = e && e.length,
                        r = n ? e[0] * s : t.length,
                        o = i.EarCut.linkedList(t, 0, r, s, !0),
                        a = [];
                    if (!o) return a;
                    var h, u, l, c, d, p, f;
                    if (n && (o = i.EarCut.eliminateHoles(t, e, o, s)), t.length > 80 * s) {
                        h = l = t[0], u = c = t[1];
                        for (var g = s; g < r; g += s) d = t[g], p = t[g + 1], d < h && (h = d), p < u && (u = p), d > l && (l = d), p > c && (c = p);
                        f = Math.max(l - h, c - u)
                    }
                    return i.EarCut.earcutLinked(o, a, s, h, u, f), a
                }, i.EarCut.linkedList = function(t, e, s, n, r) {
                    var o, a, h, u = 0;
                    for (o = e, a = s - n; o < s; o += n) u += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                    if (r === u > 0)
                        for (o = e; o < s; o += n) h = i.EarCut.insertNode(o, t[o], t[o + 1], h);
                    else
                        for (o = s - n; o >= e; o -= n) h = i.EarCut.insertNode(o, t[o], t[o + 1], h);
                    return h
                }, i.EarCut.filterPoints = function(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    var s, n = t;
                    do {
                        if (s = !1, n.steiner || !i.EarCut.equals(n, n.next) && 0 !== i.EarCut.area(n.prev, n, n.next)) n = n.next;
                        else {
                            if (i.EarCut.removeNode(n), (n = e = n.prev) === n.next) return null;
                            s = !0
                        }
                    } while (s || n !== e);
                    return e
                }, i.EarCut.earcutLinked = function(t, e, s, n, r, o, a) {
                    if (t) {
                        !a && o && i.EarCut.indexCurve(t, n, r, o);
                        for (var h, u, l = t; t.prev !== t.next;)
                            if (h = t.prev, u = t.next, o ? i.EarCut.isEarHashed(t, n, r, o) : i.EarCut.isEar(t)) e.push(h.i / s), e.push(t.i / s), e.push(u.i / s), i.EarCut.removeNode(t), t = u.next, l = u.next;
                            else if ((t = u) === l) {
                            a ? 1 === a ? (t = i.EarCut.cureLocalIntersections(t, e, s), i.EarCut.earcutLinked(t, e, s, n, r, o, 2)) : 2 === a && i.EarCut.splitEarcut(t, e, s, n, r, o) : i.EarCut.earcutLinked(i.EarCut.filterPoints(t), e, s, n, r, o, 1);
                            break
                        }
                    }
                }, i.EarCut.isEar = function(t) {
                    var e = t.prev,
                        s = t,
                        n = t.next;
                    if (i.EarCut.area(e, s, n) >= 0) return !1;
                    for (var r = t.next.next; r !== t.prev;) {
                        if (i.EarCut.pointInTriangle(e.x, e.y, s.x, s.y, n.x, n.y, r.x, r.y) && i.EarCut.area(r.prev, r, r.next) >= 0) return !1;
                        r = r.next
                    }
                    return !0
                }, i.EarCut.isEarHashed = function(t, e, s, n) {
                    var r = t.prev,
                        o = t,
                        a = t.next;
                    if (i.EarCut.area(r, o, a) >= 0) return !1;
                    for (var h = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, u = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, c = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, d = i.EarCut.zOrder(h, u, e, s, n), p = i.EarCut.zOrder(l, c, e, s, n), f = t.nextZ; f && f.z <= p;) {
                        if (f !== t.prev && f !== t.next && i.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && i.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                        f = f.nextZ
                    }
                    for (f = t.prevZ; f && f.z >= d;) {
                        if (f !== t.prev && f !== t.next && i.EarCut.pointInTriangle(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && i.EarCut.area(f.prev, f, f.next) >= 0) return !1;
                        f = f.prevZ
                    }
                    return !0
                }, i.EarCut.cureLocalIntersections = function(t, e, s) {
                    var n = t;
                    do {
                        var r = n.prev,
                            o = n.next.next;
                        i.EarCut.intersects(r, n, n.next, o) && i.EarCut.locallyInside(r, o) && i.EarCut.locallyInside(o, r) && (e.push(r.i / s), e.push(n.i / s), e.push(o.i / s), i.EarCut.removeNode(n), i.EarCut.removeNode(n.next), n = t = o), n = n.next
                    } while (n !== t);
                    return n
                }, i.EarCut.splitEarcut = function(t, e, s, n, r, o) {
                    var a = t;
                    do {
                        for (var h = a.next.next; h !== a.prev;) {
                            if (a.i !== h.i && i.EarCut.isValidDiagonal(a, h)) {
                                var u = i.EarCut.splitPolygon(a, h);
                                return a = i.EarCut.filterPoints(a, a.next), u = i.EarCut.filterPoints(u, u.next), i.EarCut.earcutLinked(a, e, s, n, r, o), void i.EarCut.earcutLinked(u, e, s, n, r, o)
                            }
                            h = h.next
                        }
                        a = a.next
                    } while (a !== t)
                }, i.EarCut.eliminateHoles = function(t, e, s, n) {
                    var r, o, a, h, u, l = [];
                    for (r = 0, o = e.length; r < o; r++) a = e[r] * n, h = r < o - 1 ? e[r + 1] * n : t.length, (u = i.EarCut.linkedList(t, a, h, n, !1)) === u.next && (u.steiner = !0), l.push(i.EarCut.getLeftmost(u));
                    for (l.sort(compareX), r = 0; r < l.length; r++) i.EarCut.eliminateHole(l[r], s), s = i.EarCut.filterPoints(s, s.next);
                    return s
                }, i.EarCut.compareX = function(t, e) {
                    return t.x - e.x
                }, i.EarCut.eliminateHole = function(t, e) {
                    if (e = i.EarCut.findHoleBridge(t, e)) {
                        var s = i.EarCut.splitPolygon(e, t);
                        i.EarCut.filterPoints(s, s.next)
                    }
                }, i.EarCut.findHoleBridge = function(t, e) {
                    var s, n = e,
                        r = t.x,
                        o = t.y,
                        a = -1 / 0;
                    do {
                        if (o <= n.y && o >= n.next.y) {
                            var h = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            h <= r && h > a && (a = h, s = n.x < n.next.x ? n : n.next)
                        }
                        n = n.next
                    } while (n !== e);
                    if (!s) return null;
                    if (t.x === s.x) return s.prev;
                    var u, l = s,
                        c = 1 / 0;
                    for (n = s.next; n !== l;) r >= n.x && n.x >= s.x && i.EarCut.pointInTriangle(o < s.y ? r : a, o, s.x, s.y, o < s.y ? a : r, o, n.x, n.y) && ((u = Math.abs(o - n.y) / (r - n.x)) < c || u === c && n.x > s.x) && i.EarCut.locallyInside(n, t) && (s = n, c = u), n = n.next;
                    return s
                }, i.EarCut.indexCurve = function(t, e, s, n) {
                    var r = t;
                    do {
                        null === r.z && (r.z = i.EarCut.zOrder(r.x, r.y, e, s, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== t);
                    r.prevZ.nextZ = null, r.prevZ = null, i.EarCut.sortLinked(r)
                }, i.EarCut.sortLinked = function(t) {
                    var e, i, s, n, r, o, a, h, u = 1;
                    do {
                        for (i = t, t = null, r = null, o = 0; i;) {
                            for (o++, s = i, a = 0, e = 0; e < u && (a++, s = s.nextZ); e++);
                            for (h = u; a > 0 || h > 0 && s;) 0 === a ? (n = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (n = i, i = i.nextZ, a--) : (n = s, s = s.nextZ, h--) : (n = i, i = i.nextZ, a--), r ? r.nextZ = n : t = n, n.prevZ = r, r = n;
                            i = s
                        }
                        r.nextZ = null, u *= 2
                    } while (o > 1);
                    return t
                }, i.EarCut.zOrder = function(t, e, i, s, n) {
                    return t = 32767 * (t - i) / n, e = 32767 * (e - s) / n, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
                }, i.EarCut.getLeftmost = function(t) {
                    var e = t,
                        i = t;
                    do {
                        e.x < i.x && (i = e), e = e.next
                    } while (e !== t);
                    return i
                }, i.EarCut.pointInTriangle = function(t, e, i, s, n, r, o, a) {
                    return (n - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (s - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (n - o) * (s - a) >= 0
                }, i.EarCut.isValidDiagonal = function(t, e) {
                    return i.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !i.EarCut.intersectsPolygon(t, e) && i.EarCut.locallyInside(t, e) && i.EarCut.locallyInside(e, t) && i.EarCut.middleInside(t, e)
                }, i.EarCut.area = function(t, e, i) {
                    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
                }, i.EarCut.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, i.EarCut.intersects = function(t, e, s, n) {
                    return i.EarCut.area(t, e, s) > 0 != i.EarCut.area(t, e, n) > 0 && i.EarCut.area(s, n, t) > 0 != i.EarCut.area(s, n, e) > 0
                }, i.EarCut.intersectsPolygon = function(t, e) {
                    var s = t;
                    do {
                        if (s.i !== t.i && s.next.i !== t.i && s.i !== e.i && s.next.i !== e.i && i.EarCut.intersects(s, s.next, t, e)) return !0;
                        s = s.next
                    } while (s !== t);
                    return !1
                }, i.EarCut.locallyInside = function(t, e) {
                    return i.EarCut.area(t.prev, t, t.next) < 0 ? i.EarCut.area(t, e, t.next) >= 0 && i.EarCut.area(t, t.prev, e) >= 0 : i.EarCut.area(t, e, t.prev) < 0 || i.EarCut.area(t, t.next, e) < 0
                }, i.EarCut.middleInside = function(t, e) {
                    var i = t,
                        s = !1,
                        n = (t.x + e.x) / 2,
                        r = (t.y + e.y) / 2;
                    do {
                        i.y > r != i.next.y > r && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
                    } while (i !== t);
                    return s
                }, i.EarCut.splitPolygon = function(t, e) {
                    var s = new i.EarCut.Node(t.i, t.x, t.y),
                        n = new i.EarCut.Node(e.i, e.x, e.y),
                        r = t.next,
                        o = e.prev;
                    return t.next = e, e.prev = t, s.next = r, r.prev = s, n.next = s, s.prev = n, o.next = n, n.prev = o, n
                }, i.EarCut.insertNode = function(t, e, s, n) {
                    var r = new i.EarCut.Node(t, e, s);
                    return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
                }, i.EarCut.removeNode = function(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }, i.EarCut.Node = function(t, e, i) {
                    this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
                    var s, n = e.gl,
                        r = e.projection,
                        o = e.offset,
                        a = e.shaderManager.primitiveShader;
                    t.dirty && PIXI.WebGLGraphics.updateGraphics(t, n);
                    var h = t._webGL[n.id];
                    if (h)
                        for (var u = 0; u < h.data.length; u++) 1 === h.data[u].mode ? (s = h.data[u], e.stencilManager.pushStencil(t, s, e), n.drawElements(n.TRIANGLE_FAN, 4, n.UNSIGNED_SHORT, 2 * (s.indices.length - 4)), e.stencilManager.popStencil(t, s, e)) : (s = h.data[u], e.shaderManager.setShader(a), a = e.shaderManager.primitiveShader, n.uniformMatrix3fv(a.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(a.flipY, 1), n.uniform2f(a.projectionVector, r.x, -r.y), n.uniform2f(a.offsetVector, -o.x, -o.y), n.uniform3fv(a.tintColor, i.Color.hexToRGBArray(t.tint)), n.uniform1f(a.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, s.buffer), n.vertexAttribPointer(a.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(a.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, s.indexBuffer), n.drawElements(n.TRIANGLE_STRIP, s.indices.length, n.UNSIGNED_SHORT, 0))
                }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
                    var s = t._webGL[e.id];
                    s || (s = t._webGL[e.id] = {
                        lastIndex: 0,
                        data: [],
                        gl: e
                    }), t.dirty = !1;
                    var n;
                    if (t.clearDirty) {
                        for (t.clearDirty = !1, n = 0; n < s.data.length; n++) {
                            var r = s.data[n];
                            r.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(r)
                        }
                        s.data = [], s.lastIndex = 0
                    }
                    var o;
                    for (n = s.lastIndex; n < t.graphicsData.length; n++) {
                        var a = t.graphicsData[n];
                        a.type === i.POLYGON ? (a.points = a.shape.points.slice(), a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])), a.fill && a.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (a.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (o = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildPoly(a, o) || (o = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(a, o))) : (o = PIXI.WebGLGraphics.switchMode(s, 1), PIXI.WebGLGraphics.buildComplexPoly(a, o))), a.lineWidth > 0 && (o = PIXI.WebGLGraphics.switchMode(s, 0), PIXI.WebGLGraphics.buildLine(a, o))) : (o = PIXI.WebGLGraphics.switchMode(s, 0), a.type === i.RECTANGLE ? PIXI.WebGLGraphics.buildRectangle(a, o) : a.type === i.CIRCLE || a.type === i.ELLIPSE ? PIXI.WebGLGraphics.buildCircle(a, o) : a.type === i.ROUNDEDRECTANGLE && PIXI.WebGLGraphics.buildRoundedRectangle(a, o)), s.lastIndex++
                    }
                    for (n = 0; n < s.data.length; n++)(o = s.data[n]).dirty && o.upload()
                }, PIXI.WebGLGraphics.switchMode = function(t, e) {
                    var i;
                    return t.data.length ? (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)) : ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i
                }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
                    var s = t.shape,
                        n = s.x,
                        r = s.y,
                        o = s.width,
                        a = s.height;
                    if (t.fill) {
                        var h = i.Color.hexToRGBArray(t.fillColor),
                            u = t.fillAlpha,
                            l = h[0] * u,
                            c = h[1] * u,
                            d = h[2] * u,
                            p = e.points,
                            f = e.indices,
                            g = p.length / 6;
                        p.push(n, r), p.push(l, c, d, u), p.push(n + o, r), p.push(l, c, d, u), p.push(n, r + a), p.push(l, c, d, u), p.push(n + o, r + a), p.push(l, c, d, u), f.push(g, g, g + 1, g + 2, g + 3, g + 3)
                    }
                    if (t.lineWidth) {
                        var m = t.points;
                        t.points = [n, r, n + o, r, n + o, r + a, n, r + a, n, r], PIXI.WebGLGraphics.buildLine(t, e), t.points = m
                    }
                }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
                    var s = t.shape,
                        n = s.x,
                        r = s.y,
                        o = s.width,
                        a = s.height,
                        h = s.radius,
                        u = [];
                    if (u.push(n, r + h), u = u.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n, r + a - h, n, r + a, n + h, r + a)), u = u.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + o - h, r + a, n + o, r + a, n + o, r + a - h)), u = u.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + o, r + h, n + o, r, n + o - h, r)), u = u.concat(PIXI.WebGLGraphics.quadraticBezierCurve(n + h, r, n, r, n, r + h)), t.fill) {
                        var l = i.Color.hexToRGBArray(t.fillColor),
                            c = t.fillAlpha,
                            d = l[0] * c,
                            p = l[1] * c,
                            f = l[2] * c,
                            g = e.points,
                            m = e.indices,
                            y = g.length / 6,
                            v = i.EarCut.Triangulate(u, null, 2),
                            x = 0;
                        for (x = 0; x < v.length; x += 3) m.push(v[x] + y), m.push(v[x] + y), m.push(v[x + 1] + y), m.push(v[x + 2] + y), m.push(v[x + 2] + y);
                        for (x = 0; x < u.length; x++) g.push(u[x], u[++x], d, p, f, c)
                    }
                    if (t.lineWidth) {
                        var _ = t.points;
                        t.points = u, PIXI.WebGLGraphics.buildLine(t, e), t.points = _
                    }
                }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, r) {
                    function o(t, e, i) {
                        return t + (e - t) * i
                    }
                    for (var a, h, u, l, c, d, p = [], f = 0, g = 0; g <= 20; g++) a = o(t, i, f = g / 20), h = o(e, s, f), u = o(i, n, f), l = o(s, r, f), c = o(a, u, f), d = o(h, l, f), p.push(c, d);
                    return p
                }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
                    var s, n, r = t.shape,
                        o = r.x,
                        a = r.y;
                    t.type === i.CIRCLE ? (s = r.radius, n = r.radius) : (s = r.width, n = r.height);
                    var h = 2 * Math.PI / 40,
                        u = 0;
                    if (t.fill) {
                        var l = i.Color.hexToRGBArray(t.fillColor),
                            c = t.fillAlpha,
                            d = l[0] * c,
                            p = l[1] * c,
                            f = l[2] * c,
                            g = e.points,
                            m = e.indices,
                            y = g.length / 6;
                        for (m.push(y), u = 0; u < 41; u++) g.push(o, a, d, p, f, c), g.push(o + Math.sin(h * u) * s, a + Math.cos(h * u) * n, d, p, f, c), m.push(y++, y++);
                        m.push(y - 1)
                    }
                    if (t.lineWidth) {
                        var v = t.points;
                        for (t.points = [], u = 0; u < 41; u++) t.points.push(o + Math.sin(h * u) * s, a + Math.cos(h * u) * n);
                        PIXI.WebGLGraphics.buildLine(t, e), t.points = v
                    }
                }, PIXI.WebGLGraphics.buildLine = function(t, e) {
                    var s = 0,
                        n = t.points;
                    if (0 !== n.length) {
                        if (t.lineWidth % 2)
                            for (s = 0; s < n.length; s++) n[s] += .5;
                        var r = new PIXI.Point(n[0], n[1]),
                            o = new PIXI.Point(n[n.length - 2], n[n.length - 1]);
                        if (r.x === o.x && r.y === o.y) {
                            (n = n.slice()).pop(), n.pop();
                            var a = (o = new PIXI.Point(n[n.length - 2], n[n.length - 1])).x + .5 * (r.x - o.x),
                                h = o.y + .5 * (r.y - o.y);
                            n.unshift(a, h), n.push(a, h)
                        }
                        var u, l, c, d, p, f, g, m, y, v, x, _, b, T, w, C, S, P, E, A, M, R, O = e.points,
                            I = e.indices,
                            L = n.length / 2,
                            D = n.length,
                            k = O.length / 6,
                            F = t.lineWidth / 2,
                            B = i.Color.hexToRGBArray(t.lineColor),
                            U = t.lineAlpha,
                            G = B[0] * U,
                            N = B[1] * U,
                            X = B[2] * U;
                        for (c = n[0], d = n[1], p = n[2], y = -(d - (f = n[3])), v = c - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, O.push(c - y, d - v, G, N, X, U), O.push(c + y, d + v, G, N, X, U), s = 1; s < L - 1; s++) c = n[2 * (s - 1)], d = n[2 * (s - 1) + 1], p = n[2 * s], f = n[2 * s + 1], g = n[2 * (s + 1)], m = n[2 * (s + 1) + 1], y = -(d - f), v = c - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, x = -(f - m), _ = p - g, x /= R = Math.sqrt(x * x + _ * _), _ /= R, S = (-y + c) * (-v + f) - (-y + p) * (-v + d), A = (-(x *= F) + g) * (-(_ *= F) + f) - (-x + p) * (-_ + m), M = (w = -v + d - (-v + f)) * (E = -x + p - (-x + g)) - (P = -_ + m - (-_ + f)) * (C = -y + p - (-y + c)), Math.abs(M) < .1 ? (M += 10.1, O.push(p - y, f - v, G, N, X, U), O.push(p + y, f + v, G, N, X, U)) : ((u = (C * A - E * S) / M) - p) * (u - p) + ((l = (P * S - w * A) / M) - f) + (l - f) > 19600 ? (b = y - x, T = v - _, b /= R = Math.sqrt(b * b + T * T), T /= R, b *= F, T *= F, O.push(p - b, f - T), O.push(G, N, X, U), O.push(p + b, f + T), O.push(G, N, X, U), O.push(p - b, f - T), O.push(G, N, X, U), D++) : (O.push(u, l), O.push(G, N, X, U), O.push(p - (u - p), f - (l - f)), O.push(G, N, X, U));
                        for (c = n[2 * (L - 2)], d = n[2 * (L - 2) + 1], p = n[2 * (L - 1)], y = -(d - (f = n[2 * (L - 1) + 1])), v = c - p, y /= R = Math.sqrt(y * y + v * v), v /= R, y *= F, v *= F, O.push(p - y, f - v), O.push(G, N, X, U), O.push(p + y, f + v), O.push(G, N, X, U), I.push(k), s = 0; s < D; s++) I.push(k++);
                        I.push(k - 1)
                    }
                }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
                    var s = t.points.slice();
                    if (!(s.length < 6)) {
                        var n = e.indices;
                        e.points = s, e.alpha = t.fillAlpha, e.color = i.Color.hexToRGBArray(t.fillColor);
                        for (var r, o, a = 1 / 0, h = -1 / 0, u = 1 / 0, l = -1 / 0, c = 0; c < s.length; c += 2) r = s[c], o = s[c + 1], a = r < a ? r : a, h = r > h ? r : h, u = o < u ? o : u, l = o > l ? o : l;
                        s.push(a, u, h, u, h, l, a, l);
                        var d = s.length / 2;
                        for (c = 0; c < d; c++) n.push(c)
                    }
                }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
                    var s = t.points;
                    if (!(s.length < 6)) {
                        var n = e.points,
                            r = e.indices,
                            o = s.length / 2,
                            a = i.Color.hexToRGBArray(t.fillColor),
                            h = t.fillAlpha,
                            u = a[0] * h,
                            l = a[1] * h,
                            c = a[2] * h,
                            d = i.EarCut.Triangulate(s, null, 2);
                        if (!d) return !1;
                        var p = n.length / 6,
                            f = 0;
                        for (f = 0; f < d.length; f += 3) r.push(d[f] + p), r.push(d[f] + p), r.push(d[f + 1] + p), r.push(d[f + 2] + p), r.push(d[f + 2] + p);
                        for (f = 0; f < o; f++) n.push(s[2 * f], s[2 * f + 1], u, l, c, h);
                        return !0
                    }
                }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
                    this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
                }, PIXI.WebGLGraphicsData.prototype.reset = function() {
                    this.points = [], this.indices = []
                }, PIXI.WebGLGraphicsData.prototype.upload = function() {
                    var t = this.gl;
                    this.glPoints = new Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
                }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
                    var s = t.worldAlpha;
                    t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
                    for (var n = 0; n < t.graphicsData.length; n++) {
                        var r = t.graphicsData[n],
                            o = r.shape,
                            a = r._fillTint,
                            h = r._lineTint;
                        if (e.lineWidth = r.lineWidth, r.type === i.POLYGON) {
                            e.beginPath();
                            var u = o.points;
                            e.moveTo(u[0], u[1]);
                            for (var l = 1; l < u.length / 2; l++) e.lineTo(u[2 * l], u[2 * l + 1]);
                            o.closed && e.lineTo(u[0], u[1]), u[0] === u[u.length - 2] && u[1] === u[u.length - 1] && e.closePath(), r.fill && (e.globalAlpha = r.fillAlpha * s, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * s, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                        } else if (r.type === i.RECTANGLE)(r.fillColor || 0 === r.fillColor) && (e.globalAlpha = r.fillAlpha * s, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fillRect(o.x, o.y, o.width, o.height)), r.lineWidth && (e.globalAlpha = r.lineAlpha * s, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.strokeRect(o.x, o.y, o.width, o.height));
                        else if (r.type === i.CIRCLE) e.beginPath(), e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), e.closePath(), r.fill && (e.globalAlpha = r.fillAlpha * s, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * s, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke());
                        else if (r.type === i.ELLIPSE) {
                            var c = 2 * o.width,
                                d = 2 * o.height,
                                p = o.x - c / 2,
                                f = o.y - d / 2;
                            e.beginPath();
                            var g = c / 2 * .5522848,
                                m = d / 2 * .5522848,
                                y = p + c,
                                v = f + d,
                                x = p + c / 2,
                                _ = f + d / 2;
                            e.moveTo(p, _), e.bezierCurveTo(p, _ - m, x - g, f, x, f), e.bezierCurveTo(x + g, f, y, _ - m, y, _), e.bezierCurveTo(y, _ + m, x + g, v, x, v), e.bezierCurveTo(x - g, v, p, _ + m, p, _), e.closePath(), r.fill && (e.globalAlpha = r.fillAlpha * s, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * s, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                        } else if (r.type === i.ROUNDEDRECTANGLE) {
                            var b = o.x,
                                T = o.y,
                                w = o.width,
                                C = o.height,
                                S = o.radius,
                                P = Math.min(w, C) / 2 | 0;
                            S = S > P ? P : S, e.beginPath(), e.moveTo(b, T + S), e.lineTo(b, T + C - S), e.quadraticCurveTo(b, T + C, b + S, T + C), e.lineTo(b + w - S, T + C), e.quadraticCurveTo(b + w, T + C, b + w, T + C - S), e.lineTo(b + w, T + S), e.quadraticCurveTo(b + w, T, b + w - S, T), e.lineTo(b + S, T), e.quadraticCurveTo(b, T, b, T + S), e.closePath(), (r.fillColor || 0 === r.fillColor) && (e.globalAlpha = r.fillAlpha * s, e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.fill()), r.lineWidth && (e.globalAlpha = r.lineAlpha * s, e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6), e.stroke())
                        }
                    }
                }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
                    var s = t.graphicsData.length;
                    if (0 !== s) {
                        e.beginPath();
                        for (var n = 0; n < s; n++) {
                            var r = t.graphicsData[n],
                                o = r.shape;
                            if (r.type === i.POLYGON) {
                                var a = o.points;
                                e.moveTo(a[0], a[1]);
                                for (var h = 1; h < a.length / 2; h++) e.lineTo(a[2 * h], a[2 * h + 1]);
                                a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && e.closePath()
                            } else if (r.type === i.RECTANGLE) e.rect(o.x, o.y, o.width, o.height), e.closePath();
                            else if (r.type === i.CIRCLE) e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI), e.closePath();
                            else if (r.type === i.ELLIPSE) {
                                var u = 2 * o.width,
                                    l = 2 * o.height,
                                    c = o.x - u / 2,
                                    d = o.y - l / 2,
                                    p = u / 2 * .5522848,
                                    f = l / 2 * .5522848,
                                    g = c + u,
                                    m = d + l,
                                    y = c + u / 2,
                                    v = d + l / 2;
                                e.moveTo(c, v), e.bezierCurveTo(c, v - f, y - p, d, y, d), e.bezierCurveTo(y + p, d, g, v - f, g, v), e.bezierCurveTo(g, v + f, y + p, m, y, m), e.bezierCurveTo(y - p, m, c, v + f, c, v), e.closePath()
                            } else if (r.type === i.ROUNDEDRECTANGLE) {
                                var x = o.x,
                                    _ = o.y,
                                    b = o.width,
                                    T = o.height,
                                    w = o.radius,
                                    C = Math.min(b, T) / 2 | 0;
                                w = w > C ? C : w, e.moveTo(x, _ + w), e.lineTo(x, _ + T - w), e.quadraticCurveTo(x, _ + T, x + w, _ + T), e.lineTo(x + b - w, _ + T), e.quadraticCurveTo(x + b, _ + T, x + b, _ + T - w), e.lineTo(x + b, _ + w), e.quadraticCurveTo(x + b, _, x + b - w, _), e.lineTo(x + w, _), e.quadraticCurveTo(x, _, x, _ + w), e.closePath()
                            }
                        }
                    }
                }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
                    if (16777215 !== t.tint)
                        for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                            var r = t.graphicsData[n],
                                o = 0 | r.fillColor,
                                a = 0 | r.lineColor;
                            r._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255, r._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * s * 255
                        }
                }, i.GraphicsData = function(t, e, i, s, n, r, o) {
                    this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = r, this.shape = o, this.type = o.type
                }, i.GraphicsData.prototype.constructor = i.GraphicsData, i.GraphicsData.prototype.clone = function() {
                    return new i.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
                }, i.Graphics = function(t, e, s) {
                    void 0 === e && (e = 0), void 0 === s && (s = 0), this.type = i.GRAPHICS, this.physicsType = i.SPRITE, this.anchor = new i.Point, PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new i.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1, i.Component.Core.init.call(this, t, e, s, "", null)
                }, i.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Graphics.prototype.constructor = i.Graphics, i.Component.Core.install.call(i.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.Graphics.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Graphics.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Graphics.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Graphics.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Graphics.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, i.Graphics.prototype.postUpdate = function() {
                    i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, i.Graphics.prototype.destroy = function(t) {
                    this.clear(), i.Component.Destroy.prototype.destroy.call(this, t)
                }, i.Graphics.prototype.drawTriangle = function(t, e) {
                    void 0 === e && (e = !1);
                    var s = new i.Polygon(t);
                    if (e) {
                        var n = new i.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                            r = new i.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                            o = new i.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(r);
                        n.dot(o) > 0 && this.drawPolygon(s)
                    } else this.drawPolygon(s)
                }, i.Graphics.prototype.drawTriangles = function(t, e, s) {
                    void 0 === s && (s = !1);
                    var n, r = new i.Point,
                        o = new i.Point,
                        a = new i.Point,
                        h = [];
                    if (e)
                        if (t[0] instanceof i.Point)
                            for (n = 0; n < e.length / 3; n++) h.push(t[e[3 * n]]), h.push(t[e[3 * n + 1]]), h.push(t[e[3 * n + 2]]), 3 === h.length && (this.drawTriangle(h, s), h = []);
                        else
                            for (n = 0; n < e.length; n++) r.x = t[2 * e[n]], r.y = t[2 * e[n] + 1], h.push(r.copyTo({})), 3 === h.length && (this.drawTriangle(h, s), h = []);
                    else if (t[0] instanceof i.Point)
                        for (n = 0; n < t.length / 3; n++) this.drawTriangle([t[3 * n], t[3 * n + 1], t[3 * n + 2]], s);
                    else
                        for (n = 0; n < t.length / 6; n++) r.x = t[6 * n + 0], r.y = t[6 * n + 1], o.x = t[6 * n + 2], o.y = t[6 * n + 3], a.x = t[6 * n + 4], a.y = t[6 * n + 5], this.drawTriangle([r, o, a], s)
                }, i.Graphics.prototype.lineStyle = function(t, e, s) {
                    return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === s ? 1 : s, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new i.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
                }, i.Graphics.prototype.moveTo = function(t, e) {
                    return this.drawShape(new i.Polygon([t, e])), this
                }, i.Graphics.prototype.lineTo = function(t, e) {
                    return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
                }, i.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    var n, r, o = this.currentPath.shape.points;
                    0 === o.length && this.moveTo(0, 0);
                    for (var a = o[o.length - 2], h = o[o.length - 1], u = 0, l = 1; l <= 20; ++l) n = a + (t - a) * (u = l / 20), r = h + (e - h) * u, o.push(n + (t + (i - t) * u - n) * u, r + (e + (s - e) * u - r) * u);
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, i.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, r) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    for (var o, a, h, u, l, c = this.currentPath.shape.points, d = c[c.length - 2], p = c[c.length - 1], f = 0, g = 1; g <= 20; ++g) h = (a = (o = 1 - (f = g / 20)) * o) * o, l = (u = f * f) * f, c.push(h * d + 3 * a * f * t + 3 * o * u * i + l * n, h * p + 3 * a * f * e + 3 * o * u * s + l * r);
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, i.Graphics.prototype.arcTo = function(t, e, i, s, n) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
                    var r = this.currentPath.shape.points,
                        o = r[r.length - 2],
                        a = r[r.length - 1] - e,
                        h = o - t,
                        u = s - e,
                        l = i - t,
                        c = Math.abs(a * l - h * u);
                    if (c < 1e-8 || 0 === n) r[r.length - 2] === t && r[r.length - 1] === e || r.push(t, e);
                    else {
                        var d = a * a + h * h,
                            p = u * u + l * l,
                            f = a * u + h * l,
                            g = n * Math.sqrt(d) / c,
                            m = n * Math.sqrt(p) / c,
                            y = g * f / d,
                            v = m * f / p,
                            x = g * l + m * h,
                            _ = g * u + m * a,
                            b = h * (m + y),
                            T = a * (m + y),
                            w = l * (g + v),
                            C = u * (g + v),
                            S = Math.atan2(T - _, b - x),
                            P = Math.atan2(C - _, w - x);
                        this.arc(x + t, _ + e, n, S, P, h * u > l * a)
                    }
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, i.Graphics.prototype.arc = function(t, e, i, s, n, r, o) {
                    if (s === n) return this;
                    void 0 === r && (r = !1), void 0 === o && (o = 40), !r && n <= s ? n += 2 * Math.PI : r && s <= n && (s += 2 * Math.PI);
                    var a = r ? -1 * (s - n) : n - s,
                        h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * o;
                    if (0 === a) return this;
                    var u = t + Math.cos(s) * i,
                        l = e + Math.sin(s) * i;
                    r && this.filling ? this.moveTo(t, e) : this.moveTo(u, l);
                    for (var c = this.currentPath.shape.points, d = a / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), m = h - 1, y = m % 1 / m, v = 0; v <= m; v++) {
                        var x = d + s + p * (v + y * v),
                            _ = Math.cos(x),
                            b = -Math.sin(x);
                        c.push((f * _ + g * b) * i + t, (f * -b + g * _) * i + e)
                    }
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, i.Graphics.prototype.beginFill = function(t, e) {
                    return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
                }, i.Graphics.prototype.endFill = function() {
                    return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
                }, i.Graphics.prototype.drawRect = function(t, e, s, n) {
                    return this.drawShape(new i.Rectangle(t, e, s, n)), this
                }, i.Graphics.prototype.drawRoundedRect = function(t, e, s, n, r) {
                    return this.drawShape(new i.RoundedRectangle(t, e, s, n, r)), this
                }, i.Graphics.prototype.drawCircle = function(t, e, s) {
                    return this.drawShape(new i.Circle(t, e, s)), this
                }, i.Graphics.prototype.drawEllipse = function(t, e, s, n) {
                    return this.drawShape(new i.Ellipse(t, e, s, n)), this
                }, i.Graphics.prototype.drawPolygon = function(t) {
                    t instanceof i.Polygon && (t = t.points);
                    var e = t;
                    if (!Array.isArray(e)) {
                        e = new Array(arguments.length);
                        for (var s = 0; s < e.length; ++s) e[s] = arguments[s]
                    }
                    return this.drawShape(new i.Polygon(e)), this
                }, i.Graphics.prototype.clear = function() {
                    return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
                }, i.Graphics.prototype.generateTexture = function(t, e, i) {
                    void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
                    var s = this.getBounds();
                    s.width += i, s.height += i;
                    var n = new PIXI.CanvasBuffer(s.width * t, s.height * t),
                        r = PIXI.Texture.fromCanvas(n.canvas, e);
                    return r.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), r
                }, i.Graphics.prototype._renderWebGL = function(t) {
                    if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                        if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                        if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                            t.spriteBatch.currentBlendMode = this.blendMode;
                            var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                            t.spriteBatch.gl.blendFunc(e[0], e[1])
                        }
                        if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                            t.spriteBatch.start();
                            for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                            t.spriteBatch.stop()
                        }
                        this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
                    }
                }, i.Graphics.prototype._renderCanvas = function(t) {
                    if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                        if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                        var e = t.context,
                            i = this.worldTransform;
                        this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                        var s = t.resolution,
                            n = i.tx * t.resolution + t.shakeX,
                            r = i.ty * t.resolution + t.shakeY;
                        e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), PIXI.CanvasGraphics.renderGraphics(this, e);
                        for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                }, i.Graphics.prototype.getBounds = function(t) {
                    if (this._currentBounds) return this._currentBounds;
                    if (!this.renderable) return i.EmptyRectangle;
                    this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                    var e = this._localBounds,
                        s = e.x,
                        n = e.width + e.x,
                        r = e.y,
                        o = e.height + e.y,
                        a = t || this.worldTransform,
                        h = a.a,
                        u = a.b,
                        l = a.c,
                        c = a.d,
                        d = a.tx,
                        p = a.ty,
                        f = h * n + l * o + d,
                        g = c * o + u * n + p,
                        m = h * s + l * o + d,
                        y = c * o + u * s + p,
                        v = h * s + l * r + d,
                        x = c * r + u * s + p,
                        _ = h * n + l * r + d,
                        b = c * r + u * n + p,
                        T = f,
                        w = g,
                        C = f,
                        S = g;
                    return C = m < C ? m : C, C = v < C ? v : C, C = _ < C ? _ : C, S = y < S ? y : S, S = x < S ? x : S, S = b < S ? b : S, T = m > T ? m : T, T = v > T ? v : T, T = _ > T ? _ : T, w = y > w ? y : w, w = x > w ? x : w, w = b > w ? b : w, this._bounds.x = C, this._bounds.width = T - C, this._bounds.y = S, this._bounds.height = w - S, this._currentBounds = this._bounds, this._currentBounds
                }, i.Graphics.prototype.getLocalBounds = function() {
                    var t = this.worldTransform;
                    this.worldTransform = i.identityMatrix;
                    for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                    var s = this.getBounds();
                    for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                    return s
                }, i.Graphics.prototype.containsPoint = function(t, e) {
                    void 0 === e && (e = new i.Point), this.worldTransform.applyInverse(t, e);
                    for (var s = this.graphicsData, n = 0; n < s.length; n++) {
                        var r = s[n];
                        if (r.fill && (r.shape && r.shape.contains(e.x, e.y))) return !0
                    }
                    return !1
                }, i.Graphics.prototype.updateLocalBounds = function() {
                    var t = 1 / 0,
                        e = -1 / 0,
                        s = 1 / 0,
                        n = -1 / 0;
                    if (this.graphicsData.length)
                        for (var r, o, a, h, u, l, c = 0; c < this.graphicsData.length; c++) {
                            var d = this.graphicsData[c],
                                p = d.type,
                                f = d.lineWidth;
                            if (r = d.shape, p === i.RECTANGLE || p === i.ROUNDEDRECTANGLE) a = r.x - f / 2, h = r.y - f / 2, u = r.width + f, l = r.height + f, t = a < t ? a : t, e = a + u > e ? a + u : e, s = h < s ? h : s, n = h + l > n ? h + l : n;
                            else if (p === i.CIRCLE) a = r.x, h = r.y, u = r.radius + f / 2, l = r.radius + f / 2, t = a - u < t ? a - u : t, e = a + u > e ? a + u : e, s = h - l < s ? h - l : s, n = h + l > n ? h + l : n;
                            else if (p === i.ELLIPSE) a = r.x, h = r.y, u = r.width + f / 2, l = r.height + f / 2, t = a - u < t ? a - u : t, e = a + u > e ? a + u : e, s = h - l < s ? h - l : s, n = h + l > n ? h + l : n;
                            else {
                                o = r.points;
                                for (var g = 0; g < o.length; g++) o[g] instanceof i.Point ? (a = o[g].x, h = o[g].y) : (a = o[g], h = o[g + 1], g < o.length - 1 && g++), t = a - f < t ? a - f : t, e = a + f > e ? a + f : e, s = h - f < s ? h - f : s, n = h + f > n ? h + f : n
                            }
                        } else t = 0, e = 0, s = 0, n = 0;
                    var m = this.boundsPadding;
                    this._localBounds.x = t - m, this._localBounds.width = e - t + 2 * m, this._localBounds.y = s - m, this._localBounds.height = n - s + 2 * m
                }, i.Graphics.prototype._generateCachedSprite = function() {
                    var t = this.getLocalBounds();
                    if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
                    else {
                        var e = new PIXI.CanvasBuffer(t.width, t.height),
                            i = PIXI.Texture.fromCanvas(e.canvas);
                        this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
                    }
                    this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
                }, i.Graphics.prototype.updateCachedSpriteTexture = function() {
                    var t = this._cachedSprite,
                        e = t.texture,
                        i = t.buffer.canvas;
                    e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
                }, i.Graphics.prototype.destroyCachedSprite = function() {
                    this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
                }, i.Graphics.prototype.drawShape = function(t) {
                    this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof i.Polygon && (t = t.clone()).flatten();
                    var e = new i.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
                    return this.graphicsData.push(e), e.type === i.POLYGON && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
                }, Object.defineProperty(i.Graphics.prototype, "cacheAsBitmap", {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
                    }
                }), i.RenderTexture = function(t, e, s, n, r, o, a, h) {
                    if (void 0 === e && (e = 100), void 0 === s && (s = 100), void 0 === n && (n = ""), void 0 === r && (r = i.scaleModes.DEFAULT), void 0 === o && (o = 1), void 0 === a && (a = PIXI.defaultRenderer), void 0 === h && (h = 0), this.game = t, this.key = n, this.type = i.RENDERTEXTURE, this._tempMatrix = new i.Matrix, this.width = e, this.height = s, this.resolution = o, this.frame = new i.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = this.frame.clone(), this.baseTexture = new PIXI.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = r, this.baseTexture.hasLoaded = !0, PIXI.Texture.call(this, this.baseTexture, this.frame.clone()), this.renderer = a, this.renderer.type === i.WEBGL) {
                        var u = this.renderer.gl;
                        this.baseTexture.textureIndex = h, this.baseTexture._dirty[u.id] = !1, this.textureBuffer = new PIXI.FilterTexture(u, this.width, this.height, this.baseTexture.scaleMode, h), this.baseTexture._glTextures[u.id] = this.textureBuffer.texture, this.projection = new i.Point(.5 * this.width, .5 * -this.height)
                    } else this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
                    this.valid = !0, this.tempMatrix = new i.Matrix, this._updateUvs()
                }, i.RenderTexture.prototype = Object.create(PIXI.Texture.prototype), i.RenderTexture.prototype.constructor = i.RenderTexture, i.RenderTexture.prototype.renderXY = function(t, e, s, n) {
                    t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = s, this.renderer.type === i.WEBGL ? this._renderWebGL(t, this._tempMatrix, n) : this._renderCanvas(t, this._tempMatrix, n)
                }, i.RenderTexture.prototype.renderRawXY = function(t, e, s, n) {
                    this._tempMatrix.identity().translate(e, s), this.renderer.type === i.WEBGL ? this._renderWebGL(t, this._tempMatrix, n) : this._renderCanvas(t, this._tempMatrix, n)
                }, i.RenderTexture.prototype.render = function(t, e, s) {
                    void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === i.WEBGL ? this._renderWebGL(t, this._tempMatrix, s) : this._renderCanvas(t, this._tempMatrix, s)
                }, i.RenderTexture.prototype.resize = function(t, e, s) {
                    t === this.width && e === this.height || (this.valid = t > 0 && e > 0, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, s && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === i.WEBGL && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
                }, i.RenderTexture.prototype.clear = function() {
                    this.valid && (this.renderer.type === i.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
                }, i.RenderTexture.prototype._renderWebGL = function(t, e, i) {
                    if (this.valid && 0 !== t.alpha) {
                        var s = t.worldTransform;
                        s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
                        for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                        var r = this.renderer.gl;
                        r.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0, r.bindFramebuffer(r.FRAMEBUFFER, null)
                    }
                }, i.RenderTexture.prototype._renderCanvas = function(t, e, i) {
                    if (this.valid && 0 !== t.alpha) {
                        var s = t.worldTransform;
                        s.identity(), e && s.append(e);
                        for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                        i && this.textureBuffer.clear();
                        var r = this.renderer.resolution;
                        this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = r
                    }
                }, i.RenderTexture.prototype.getImage = function() {
                    var t = new Image; t.crossOrigin="anonymous";
                    return t.src = this.getBase64(), t
                }, i.RenderTexture.prototype.getBase64 = function() {
                    return this.getCanvas().toDataURL()
                }, i.RenderTexture.prototype.getCanvas = function() {
                    if (this.renderer.type === i.WEBGL) {
                        var t = this.renderer.gl,
                            e = this.textureBuffer.width,
                            s = this.textureBuffer.height,
                            n = new Uint8Array(4 * e * s);
                        t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, s, t.RGBA, t.UNSIGNED_BYTE, n), t.bindFramebuffer(t.FRAMEBUFFER, null);
                        var r = new PIXI.CanvasBuffer(e, s),
                            o = r.context.getImageData(0, 0, e, s);
                        return o.data.set(n), r.context.putImageData(o, 0, 0), r.canvas
                    }
                    return this.textureBuffer.canvas
                }, i.Text = function(t, e, s, n, r) {
                    e = e || 0, s = s || 0, n = void 0 === n || null === n ? "" : n.toString(), this.type = i.TEXT, this.physicsType = i.SPRITE, this.padding = new i.Point, this.textBounds = null, this.canvas = i.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this.splitRegExp = /(?:\r\n|\r|\n)/, this.characterLimitSize = -1, this.characterLimitSuffix = "", this._res = t.renderer.resolution, this._text = n, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, i.Sprite.call(this, t, e, s, PIXI.Texture.fromCanvas(this.canvas)), this.style = {}, this.setStyle(r || {}), "" !== n && this.updateText()
                }, i.Text.prototype = Object.create(i.Sprite.prototype), i.Text.prototype.constructor = i.Text, i.Text.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, i.Text.prototype.update = function() {}, i.Text.prototype.destroy = function(t) {
                    this.texture.destroy(!0), i.Component.Destroy.prototype.destroy.call(this, t)
                }, i.Text.prototype.setShadow = function(t, e, i, s, n, r) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === r && (r = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = r, this.dirty = !0, this
                }, i.Text.prototype.setStyle = function(t, e) {
                    void 0 === e && (e = !1);
                    var i = Object.assign({}, t);
                    i.font = t.font || "bold 20pt Arial", i.backgroundColor = t.backgroundColor || null, i.fill = t.fill || "black", i.align = (t.align || "left").toLowerCase(), i.boundsAlignH = (t.boundsAlignH || "left").toLowerCase(), i.boundsAlignV = (t.boundsAlignV || "top").toLowerCase(), i.stroke = t.stroke || "black", i.strokeThickness = Number(t.strokeThickness) || 0, i.wordWrap = t.wordWrap || !1, i.wordWrapWidth = t.wordWrapWidth || 100, i.maxLines = t.maxLines || 0, i.shadowOffsetX = t.shadowOffsetX || 0, i.shadowOffsetY = t.shadowOffsetY || 0, i.shadowColor = t.shadowColor || "rgba(0,0,0,0)", i.shadowBlur = t.shadowBlur || 0, i.tabs = t.tabs || 0;
                    var s = this.fontToComponents(i.font);
                    return i.fontStyle && (s.fontStyle = i.fontStyle), i.fontVariant && (s.fontVariant = i.fontVariant), i.fontWeight && (s.fontWeight = i.fontWeight), i.fontSize && ("number" == typeof i.fontSize && (i.fontSize = i.fontSize + "px"), s.fontSize = i.fontSize), this._fontComponents = s, i.font = this.componentsToFont(this._fontComponents), this.style = i, this.dirty = !0, e && this.updateText(), this
                }, i.Text.prototype.updateText = function() {
                    this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
                    var t = this.text;
                    this.characterLimitSize > -1 && this.characterLimitSize < t.length && (t = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix), this.style.wordWrap && (t = this.runWordWrap(this.text));
                    var e = t.split(this.splitRegExp),
                        i = this.style.tabs,
                        s = [],
                        n = 0,
                        r = this.determineFontProperties(this.style.font),
                        o = e.length;
                    this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines), this._charCount = 0;
                    for (var a = 0; a < o; a++) {
                        if (0 === i) {
                            u = this.style.strokeThickness + this.padding.x;
                            this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? u += this.measureLine(e[a]) : u += this.context.measureText(e[a]).width, this.style.wordWrap && (u -= this.context.measureText(" ").width)
                        } else {
                            var h = e[a].split(/(?:\t)/),
                                u = this.padding.x + this.style.strokeThickness;
                            if (Array.isArray(i))
                                for (var l = 0, c = 0; c < h.length; c++) {
                                    var d = 0;
                                    d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[c]) : Math.ceil(this.context.measureText(h[c]).width), c > 0 && (l += i[c - 1]), u = l + d
                                } else
                                    for (c = 0; c < h.length; c++) this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? u += this.measureLine(h[c]) : u += Math.ceil(this.context.measureText(h[c]).width), u += this.game.math.snapToCeil(u, i) - u
                        }
                        s[a] = Math.ceil(u), n = Math.max(n, s[a])
                    }
                    this.canvas.width = n * this._res;
                    var p = r.fontSize + this.style.strokeThickness + this.padding.y,
                        f = p * o,
                        g = this._lineSpacing;
                    g < 0 && Math.abs(g) > p && (g = -p), 0 !== g && (f += g > 0 ? g * e.length : g * (e.length - 1)), this.canvas.height = f * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
                    var m, y;
                    for (this._charCount = 0, a = 0; a < o; a++) m = this.style.strokeThickness / 2, y = this.style.strokeThickness / 2 + a * p + r.ascent, a > 0 && (y += g * a), "right" === this.style.align ? m += n - s[a] : "center" === this.style.align && (m += (n - s[a]) / 2), this.autoRound && (m = Math.round(m), y = Math.round(y)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], m, y) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], m, y) : this.renderTabLine(e[a], m, y, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], m, y) : this.renderTabLine(e[a], m, y, !0)));
                    this.updateTexture(), this.dirty = !1
                }, i.Text.prototype.renderTabLine = function(t, e, i, s) {
                    var n = t.split(/(?:\t)/),
                        r = this.style.tabs,
                        o = 0;
                    if (Array.isArray(r))
                        for (var a = 0, h = 0; h < n.length; h++) h > 0 && (a += r[h - 1]), o = e + a, s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
                    else
                        for (h = 0; h < n.length; h++) {
                            var u = Math.ceil(this.context.measureText(n[h]).width);
                            o = this.game.math.snapToCeil(e, r), s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i), e = o + u
                        }
                }, i.Text.prototype.updateShadow = function(t) {
                    t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
                }, i.Text.prototype.measureLine = function(t) {
                    for (var e = 0, i = 0; i < t.length; i++) {
                        var s = t[i];
                        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                            var n = this.fontToComponents(this.context.font);
                            this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                        }
                        this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s).width, this._charCount++
                    }
                    return Math.ceil(e)
                }, i.Text.prototype.updateLine = function(t, e, i) {
                    for (var s = 0; s < t.length; s++) {
                        var n = t[s];
                        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                            var r = this.fontToComponents(this.context.font);
                            this.fontStyles[this._charCount] && (r.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (r.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(r)
                        }
                        this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n).width, this._charCount++
                    }
                }, i.Text.prototype.clearColors = function() {
                    return this.colors = [], this.strokeColors = [], this.dirty = !0, this
                }, i.Text.prototype.clearFontValues = function() {
                    return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
                }, i.Text.prototype.addColor = function(t, e) {
                    return this.colors[e] = t, this.dirty = !0, this
                }, i.Text.prototype.addStrokeColor = function(t, e) {
                    return this.strokeColors[e] = t, this.dirty = !0, this
                }, i.Text.prototype.addFontStyle = function(t, e) {
                    return this.fontStyles[e] = t, this.dirty = !0, this
                }, i.Text.prototype.addFontWeight = function(t, e) {
                    return this.fontWeights[e] = t, this.dirty = !0, this
                }, i.Text.prototype.precalculateWordWrap = function(t) {
                    return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/)
                }, i.Text.prototype.runWordWrap = function(t) {
                    return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
                }, i.Text.prototype.advancedWordWrap = function(t) {
                    for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), r = n.length, o = 0; o < r; o++) {
                        var a = n[o],
                            h = "";
                        if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) s += a + "\n";
                        else {
                            for (var u = i, l = a.split(" "), c = 0; c < l.length; c++) {
                                var d = l[c],
                                    p = d + " ",
                                    f = e.measureText(p).width;
                                if (f > u) {
                                    if (0 === c) {
                                        for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g).width) <= u)););
                                        if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                        var m = d.substr(g.length);
                                        l[c] = m, h += g
                                    }
                                    var y = l[c].length ? c : c + 1,
                                        v = l.slice(y).join(" ").replace(/[ \n]*$/gi, "");
                                    n[o + 1] = v + " " + (n[o + 1] || ""), r = n.length;
                                    break
                                }
                                h += p, u -= f
                            }
                            s += h.replace(/[ \n]*$/gi, "") + "\n"
                        }
                    }
                    return s = s.replace(/[\s|\n]*$/gi, "")
                }, i.Text.prototype.basicWordWrap = function(t) {
                    for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                        for (var n = this.style.wordWrapWidth, r = i[s].split(" "), o = 0; o < r.length; o++) {
                            var a = this.context.measureText(r[o]).width,
                                h = a + this.context.measureText(" ").width;
                            h > n ? (o > 0 && (e += "\n"), e += r[o] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += r[o] + " ")
                        }
                        s < i.length - 1 && (e += "\n")
                    }
                    return e
                }, i.Text.prototype.updateFont = function(t) {
                    var e = this.componentsToFont(t);
                    this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
                }, i.Text.prototype.fontToComponents = function(t) {
                    var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
                    if (e) {
                        var i = e[5].trim();
                        return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                            font: t,
                            fontStyle: e[1] || "normal",
                            fontVariant: e[2] || "normal",
                            fontWeight: e[3] || "normal",
                            fontSize: e[4] || "medium",
                            fontFamily: i
                        }
                    }
                    return console.warn("Phaser.Text - unparsable CSS font: " + t), {
                        font: t
                    }
                }, i.Text.prototype.componentsToFont = function(t) {
                    var e, i = [];
                    return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ")
                }, i.Text.prototype.setText = function(t, e) {
                    return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
                }, i.Text.prototype.parseList = function(t) {
                    if (!Array.isArray(t)) return this;
                    for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
                    return this.text = e, this.dirty = !0, this
                }, i.Text.prototype.setTextBounds = function(t, e, s, n) {
                    return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, s, n) : this.textBounds = new i.Rectangle(t, e, s, n), this.style.wordWrapWidth > s && (this.style.wordWrapWidth = s)), this.updateTexture(), this
                }, i.Text.prototype.updateTexture = function() {
                    var t = this.texture.baseTexture,
                        e = this.texture.crop,
                        i = this.texture.frame,
                        s = this.canvas.width,
                        n = this.canvas.height;
                    if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
                        var r = this.textBounds.x,
                            o = this.textBounds.y;
                        "right" === this.style.boundsAlignH ? r += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (r += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -r, this.pivot.y = -o
                    }
                    this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
                }, i.Text.prototype._renderWebGL = function(t) {
                    this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
                }, i.Text.prototype._renderCanvas = function(t) {
                    this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
                }, i.Text.prototype.determineFontProperties = function(t) {
                    var e = i.Text.fontPropertiesCache[t];
                    if (!e) {
                        e = {};
                        var s = i.Text.fontPropertiesCanvas,
                            n = i.Text.fontPropertiesContext;
                        n.font = t;
                        var r = Math.ceil(n.measureText("|Mq").width),
                            o = Math.ceil(n.measureText("|Mq").width),
                            a = 2 * o;
                        if (o = 1.4 * o | 0, s.width = r, s.height = a, n.fillStyle = "#f00", n.fillRect(0, 0, r, a), n.font = t, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText("|Mq", 0, o), !n.getImageData(0, 0, r, a)) return e.ascent = o, e.descent = o + 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e, e;
                        var h, u, l = n.getImageData(0, 0, r, a).data,
                            c = l.length,
                            d = 4 * r,
                            p = 0,
                            f = !1;
                        for (h = 0; h < o; h++) {
                            for (u = 0; u < d; u += 4)
                                if (255 !== l[p + u]) {
                                    f = !0;
                                    break
                                }
                            if (f) break;
                            p += d
                        }
                        for (e.ascent = o - h, p = c - d, f = !1, h = a; h > o; h--) {
                            for (u = 0; u < d; u += 4)
                                if (255 !== l[p + u]) {
                                    f = !0;
                                    break
                                }
                            if (f) break;
                            p -= d
                        }
                        e.descent = h - o, e.descent += 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e
                    }
                    return e
                }, i.Text.prototype.getBounds = function(t) {
                    return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
                }, i.Text.prototype.setCharacterLimit = function(t, e) {
                    this.characterLimitSuffix = void 0 === e ? "" : e, this.characterLimitSize = t, this.updateText()
                }, Object.defineProperty(i.Text.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
                    }
                }), Object.defineProperty(i.Text.prototype, "cssFont", {
                    get: function() {
                        return this.componentsToFont(this._fontComponents)
                    },
                    set: function(t) {
                        t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(i.Text.prototype, "font", {
                    get: function() {
                        return this._fontComponents.fontFamily
                    },
                    set: function(t) {
                        t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(i.Text.prototype, "fontSize", {
                    get: function() {
                        var t = this._fontComponents.fontSize;
                        return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
                    },
                    set: function(t) {
                        "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(i.Text.prototype, "fontWeight", {
                    get: function() {
                        return this._fontComponents.fontWeight || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(i.Text.prototype, "fontStyle", {
                    get: function() {
                        return this._fontComponents.fontStyle || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(i.Text.prototype, "fontVariant", {
                    get: function() {
                        return this._fontComponents.fontVariant || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(i.Text.prototype, "fill", {
                    get: function() {
                        return this.style.fill
                    },
                    set: function(t) {
                        t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "align", {
                    get: function() {
                        return this.style.align
                    },
                    set: function(t) {
                        (t = t.toLowerCase()) !== this.style.align && (this.style.align = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "resolution", {
                    get: function() {
                        return this._res
                    },
                    set: function(t) {
                        t !== this._res && (this._res = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "tabs", {
                    get: function() {
                        return this.style.tabs
                    },
                    set: function(t) {
                        t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "boundsAlignH", {
                    get: function() {
                        return this.style.boundsAlignH
                    },
                    set: function(t) {
                        (t = t.toLowerCase()) !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "boundsAlignV", {
                    get: function() {
                        return this.style.boundsAlignV
                    },
                    set: function(t) {
                        (t = t.toLowerCase()) !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "stroke", {
                    get: function() {
                        return this.style.stroke
                    },
                    set: function(t) {
                        t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "strokeThickness", {
                    get: function() {
                        return this.style.strokeThickness
                    },
                    set: function(t) {
                        t !== this.style.strokeThickness && (this.style.strokeThickness = Number(t), this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "wordWrap", {
                    get: function() {
                        return this.style.wordWrap
                    },
                    set: function(t) {
                        t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "wordWrapWidth", {
                    get: function() {
                        return this.style.wordWrapWidth
                    },
                    set: function(t) {
                        t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "lineSpacing", {
                    get: function() {
                        return this._lineSpacing
                    },
                    set: function(t) {
                        t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
                    }
                }), Object.defineProperty(i.Text.prototype, "shadowOffsetX", {
                    get: function() {
                        return this.style.shadowOffsetX
                    },
                    set: function(t) {
                        t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "shadowOffsetY", {
                    get: function() {
                        return this.style.shadowOffsetY
                    },
                    set: function(t) {
                        t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "shadowColor", {
                    get: function() {
                        return this.style.shadowColor
                    },
                    set: function(t) {
                        t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "shadowBlur", {
                    get: function() {
                        return this.style.shadowBlur
                    },
                    set: function(t) {
                        t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "shadowStroke", {
                    get: function() {
                        return this.style.shadowStroke
                    },
                    set: function(t) {
                        t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "shadowFill", {
                    get: function() {
                        return this.style.shadowFill
                    },
                    set: function(t) {
                        t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
                    }
                }), Object.defineProperty(i.Text.prototype, "width", {
                    get: function() {
                        return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * (this.texture.frame.width / this.resolution)
                    },
                    set: function(t) {
                        this.scale.x = t / this.texture.frame.width, this._width = t
                    }
                }), Object.defineProperty(i.Text.prototype, "height", {
                    get: function() {
                        return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * (this.texture.frame.height / this.resolution)
                    },
                    set: function(t) {
                        this.scale.y = t / this.texture.frame.height, this._height = t
                    }
                }), i.Text.fontPropertiesCache = {}, i.Text.fontPropertiesCanvas = document.createElement("canvas"), i.Text.fontPropertiesContext = i.Text.fontPropertiesCanvas.getContext("2d"), i.BitmapText = function(t, e, s, n, r, o, a) {
                    e = e || 0, s = s || 0, n = n || "", r = r || "", o = o || 32, a = a || "left", PIXI.DisplayObjectContainer.call(this), this.type = i.BITMAPTEXT, this.physicsType = i.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new i.Point, this._prevAnchor = new i.Point, this._glyphs = [], this._maxWidth = 0, this._text = r.toString() || "", this._data = t.cache.getBitmapFont(n), this._font = n, this._fontSize = o, this._align = a, this._tint = 16777215, this.updateText(), this.dirty = !1, i.Component.Core.init.call(this, t, e, s, "", null)
                }, i.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.BitmapText.prototype.constructor = i.BitmapText, i.Component.Core.install.call(i.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.BitmapText.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.BitmapText.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.BitmapText.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.BitmapText.prototype.preUpdateCore = i.Component.Core.preUpdate, i.BitmapText.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, i.BitmapText.prototype.postUpdate = function() {
                    i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === i.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
                }, i.BitmapText.prototype.setText = function(t) {
                    this.text = t
                }, i.BitmapText.prototype.scanLine = function(t, e, i) {
                    for (var s = 0, n = 0, r = -1, o = 0, a = null, h = this._maxWidth > 0 ? this._maxWidth : null, u = [], l = 0; l < i.length; l++) {
                        var c = l === i.length - 1;
                        if (/(?:\r\n|\r|\n)/.test(i.charAt(l))) return {
                            width: n,
                            text: i.substr(0, l),
                            end: c,
                            chars: u
                        };
                        var d = i.charCodeAt(l),
                            p = t.chars[d],
                            f = 0;
                        void 0 === p && (d = 32, p = t.chars[d]);
                        var g = a && p.kerning[a] ? p.kerning[a] : 0;
                        if (/(\s)/.test(i.charAt(l)) && (r = l, o = n), f = (g + p.texture.width + p.xOffset) * e, h && n + f >= h && r > -1) return {
                            width: o || n,
                            text: i.substr(0, l - (l - r)),
                            end: !1,
                            chars: u
                        };
                        n += (p.xAdvance + g) * e, u.push(s + (p.xOffset + g) * e), s += (p.xAdvance + g) * e, a = d
                    }
                    return {
                        width: n,
                        text: i,
                        end: c,
                        chars: u
                    }
                }, i.BitmapText.prototype.cleanText = function(t, e) {
                    void 0 === e && (e = "");
                    var i = this._data.font;
                    if (!i) return "";
                    for (var s = /\r\n|\n\r|\n|\r/g, n = t.replace(s, "\n").split("\n"), r = 0; r < n.length; r++) {
                        for (var o = "", a = n[r], h = 0; h < a.length; h++) o = i.chars[a.charCodeAt(h)] ? o.concat(a[h]) : o.concat(e);
                        n[r] = o
                    }
                    return n.join("\n")
                }, i.BitmapText.prototype.updateText = function() {
                    var t = this._data.font;
                    if (t) {
                        var e = this.text,
                            i = this._fontSize / t.size,
                            s = [],
                            n = 0;
                        this.textWidth = 0;
                        do {
                            (l = this.scanLine(t, i, e)).y = n, s.push(l), l.width > this.textWidth && (this.textWidth = l.width), n += t.lineHeight * i, e = e.substr(l.text.length + 1)
                        } while (!1 === l.end);
                        this.textHeight = n;
                        for (var r = 0, o = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, u = 0; u < s.length; u++) {
                            var l = s[u];
                            "right" === this._align ? o = this.textWidth - l.width : "center" === this._align && (o = (this.textWidth - l.width) / 2);
                            for (var c = 0; c < l.text.length; c++) {
                                var d = l.text.charCodeAt(c),
                                    p = t.chars[d];
                                void 0 === p && (d = 32, p = t.chars[d]);
                                var f = this._glyphs[r];
                                f ? f.texture = p.texture : ((f = new PIXI.Sprite(p.texture)).name = l.text[c], this._glyphs.push(f)), f.position.x = l.chars[c] + o - a, f.position.y = l.y + p.yOffset * i - h, f.scale.set(i), f.tint = this.tint, f.texture.requiresReTint = !0, f.cachedTint = 16777215, f.parent || this.addChild(f), r++
                            }
                        }
                        for (u = r; u < this._glyphs.length; u++) this.removeChild(this._glyphs[u])
                    }
                }, i.BitmapText.prototype.purgeGlyphs = function() {
                    for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
                    return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
                }, i.BitmapText.prototype.updateTransform = function() {
                    !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
                }, Object.defineProperty(i.BitmapText.prototype, "align", {
                    get: function() {
                        return this._align
                    },
                    set: function(t) {
                        t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
                    }
                }), Object.defineProperty(i.BitmapText.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        t !== this._tint && (this._tint = t, this.updateText())
                    }
                }), Object.defineProperty(i.BitmapText.prototype, "font", {
                    get: function() {
                        return this._font
                    },
                    set: function(t) {
                        t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
                    }
                }), Object.defineProperty(i.BitmapText.prototype, "fontSize", {
                    get: function() {
                        return this._fontSize
                    },
                    set: function(t) {
                        (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
                    }
                }), Object.defineProperty(i.BitmapText.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t !== this._text && (this._text = t.toString() || "", this.updateText())
                    }
                }), Object.defineProperty(i.BitmapText.prototype, "maxWidth", {
                    get: function() {
                        return this._maxWidth
                    },
                    set: function(t) {
                        t !== this._maxWidth && (this._maxWidth = t, this.updateText())
                    }
                }), Object.defineProperty(i.BitmapText.prototype, "smoothed", {
                    get: function() {
                        return !this._data.base.scaleMode
                    },
                    set: function(t) {
                        this._data.base.scaleMode = t ? 0 : 1, this._data.base.dirty()
                    }
                }), i.TileSprite = function(t, e, s, n, r, o, a) {
                    e = e || 0, s = s || 0, n = n || 256, r = r || 256, o = o || null, a = a || null, PIXI.Sprite.call(this, new PIXI.Texture(i.Cache.DEFAULT.baseTexture), n, r), this.type = i.TILESPRITE, this.physicsType = i.SPRITE, this._scroll = new i.Point, this.tileScale = new i.Point(1, 1), this.tileScaleOffset = new i.Point(1, 1), this.tilePosition = new i.Point, this.textureDebug = !1, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0, this._width = n, this._height = r, i.Component.Core.init.call(this, t, e, s, o, a)
                }, i.TileSprite.prototype = Object.create(PIXI.Sprite.prototype), i.TileSprite.prototype.constructor = i.TileSprite, i.Component.Core.install.call(i.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), i.TileSprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.TileSprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.TileSprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.TileSprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TileSprite.prototype.preUpdate = function() {
                    return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, i.TileSprite.prototype.autoScroll = function(t, e) {
                    return this._scroll.set(t, e), this
                }, i.TileSprite.prototype.stopScroll = function() {
                    return this._scroll.set(0, 0), this
                }, i.TileSprite.prototype.destroy = function(t) {
                    i.Component.Destroy.prototype.destroy.call(this, t), PIXI.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
                }, i.TileSprite.prototype.reset = function(t, e) {
                    return i.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
                }, i.TileSprite.prototype.setTexture = function(t) {
                    return this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215), this
                }, i.TileSprite.prototype._renderWebGL = function(t) {
                    if (this.visible && this.renderable && 0 !== this.alpha) {
                        if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                            if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                            this.tilingTexture.needsUpdate && (this.tilingTexture.baseTexture.textureIndex = this.texture.baseTexture.textureIndex, t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                        }
                        t.spriteBatch.renderTilingSprite(this);
                        for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                        var i = !1;
                        this._filters && (i = !0, t.spriteBatch.stop(), t.filterManager.popFilter()), this._mask && (i || t.spriteBatch.stop(), t.maskManager.popMask(this._mask, t)), i && t.spriteBatch.start()
                    }
                }, i.TileSprite.prototype._renderCanvas = function(t) {
                    if (this.visible && this.renderable && 0 !== this.alpha) {
                        var e = t.context;
                        this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
                        var i = this.worldTransform,
                            s = t.resolution,
                            n = i.tx * s + t.shakeX,
                            r = i.ty * s + t.shakeY;
                        if (e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, r), 16777215 === this.tint || !this.texture.requiresReTint && this.cachedTint === this.tint || (this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1, this.refreshTexture = !0), this.refreshTexture) {
                            if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                            this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                        }
                        var o = t.currentBlendMode;
                        this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]);
                        var a = this.tilePosition,
                            h = this.tileScale;
                        a.x %= this.tilingTexture.baseTexture.width, a.y %= this.tilingTexture.baseTexture.height, e.scale(h.x, h.y), e.translate(a.x + this.anchor.x * -this._width, a.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern, n = -a.x, r = -a.y;
                        var u = this._width / h.x,
                            l = this._height / h.y;
                        t.roundPixels && (n |= 0, r |= 0, u |= 0, l |= 0), e.fillRect(n, r, u, l), e.scale(1 / h.x, 1 / h.y), e.translate(-a.x + this.anchor.x * this._width, -a.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                        for (var c = 0; c < this.children.length; c++) this.children[c]._renderCanvas(t);
                        o !== this.blendMode && (t.currentBlendMode = o, e.globalCompositeOperation = PIXI.blendModesCanvas[o])
                    }
                }, i.TileSprite.prototype.onTextureUpdate = function() {}, i.TileSprite.prototype.generateTilingTexture = function(t) {
                    if (this.texture.baseTexture.hasLoaded) {
                        var e = this.texture,
                            s = e.frame,
                            n = this._frame.sourceSizeW || this._frame.width,
                            r = this._frame.sourceSizeH || this._frame.height,
                            o = 0,
                            a = 0;
                        this._frame.trimmed && (o = this._frame.spriteSourceSizeX, a = this._frame.spriteSourceSizeY), t && (n = i.Math.getNextPowerOfTwo(n), r = i.Math.getNextPowerOfTwo(r)), this.canvasBuffer ? (this.canvasBuffer.resize(n, r), this.tilingTexture.baseTexture.width = n, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new PIXI.CanvasBuffer(n, r), this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, n, r));
                        var h = e.crop.width,
                            u = e.crop.height;
                        h === n && u === r || (h = n, u = r);
                        var l = this.tintedTexture ? this.tintedTexture : e.baseTexture.source;
                        this.canvasBuffer.context.drawImage(l, e.crop.x, e.crop.y, e.crop.width, e.crop.height, o, a, h, u), this.tileScaleOffset.x = s.width / n, this.tileScaleOffset.y = s.height / r, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
                    }
                }, i.TileSprite.prototype.getBounds = function() {
                    var t = this._width,
                        e = this._height,
                        i = t * (1 - this.anchor.x),
                        s = t * -this.anchor.x,
                        n = e * (1 - this.anchor.y),
                        r = e * -this.anchor.y,
                        o = this.worldTransform,
                        a = o.a,
                        h = o.b,
                        u = o.c,
                        l = o.d,
                        c = o.tx,
                        d = o.ty,
                        p = a * s + u * r + c,
                        f = l * r + h * s + d,
                        g = a * i + u * r + c,
                        m = l * r + h * i + d,
                        y = a * i + u * n + c,
                        v = l * n + h * i + d,
                        x = a * s + u * n + c,
                        _ = l * n + h * s + d,
                        b = -1 / 0,
                        T = -1 / 0,
                        w = 1 / 0,
                        C = 1 / 0;
                    w = x < (w = y < (w = g < (w = p < w ? p : w) ? g : w) ? y : w) ? x : w, C = _ < (C = v < (C = m < (C = f < C ? f : C) ? m : C) ? v : C) ? _ : C, b = x > (b = y > (b = g > (b = p > b ? p : b) ? g : b) ? y : b) ? x : b, T = _ > (T = v > (T = m > (T = f > T ? f : T) ? m : T) ? v : T) ? _ : T;
                    var S = this._bounds;
                    return S.x = w, S.width = b - w, S.y = C, S.height = T - C, this._currentBounds = S, S
                }, Object.defineProperty(i.TileSprite.prototype, "width", {
                    get: function() {
                        return this._width
                    },
                    set: function(t) {
                        this._width = t
                    }
                }), Object.defineProperty(i.TileSprite.prototype, "height", {
                    get: function() {
                        return this._height
                    },
                    set: function(t) {
                        this._height = t
                    }
                }), i.CanvasPool = {
                    create: function(t, e, s) {
                        var n, r = i.CanvasPool.getFirst();
                        if (-1 === r) {
                            var o = {
                                parent: t,
                                canvas: document.createElement("canvas")
                            };
                            i.CanvasPool.pool.push(o), n = o.canvas
                        } else i.CanvasPool.pool[r].parent = t, n = i.CanvasPool.pool[r].canvas;
                        return void 0 !== e && (n.width = e, n.height = s), n
                    },
                    getFirst: function() {
                        for (var t = i.CanvasPool.pool, e = 0; e < t.length; e++)
                            if (!t[e].parent) return e;
                        return -1
                    },
                    remove: function(t) {
                        for (var e = i.CanvasPool.pool, s = 0; s < e.length; s++) e[s].parent === t && (e[s].parent = null, e[s].canvas.width = 1, e[s].canvas.height = 1)
                    },
                    removeByCanvas: function(t) {
                        for (var e = i.CanvasPool.pool, s = 0; s < e.length; s++) e[s].canvas === t && (e[s].parent = null, e[s].canvas.width = 1, e[s].canvas.height = 1)
                    },
                    getTotal: function() {
                        for (var t = i.CanvasPool.pool, e = 0, s = 0; s < t.length; s++) t[s].parent && e++;
                        return e
                    },
                    getFree: function() {
                        for (var t = i.CanvasPool.pool, e = 0, s = 0; s < t.length; s++) t[s].parent || e++;
                        return e
                    },
                    log: function() {
                        console.log("CanvasPool: %s used, %s free, %s total", this.getTotal(), this.getFree(), this.pool.length)
                    }
                }, i.CanvasPool.pool = [], Object.defineProperty(i.CanvasPool, "length", {
                    get: function() {
                        return this.pool.length
                    }
                }), i.Device = function() {
                    this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.canHandleAlpha = !1, this.canUseMultiply = !1, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
                }, i.Device = new i.Device, i.Device.onInitialized = new i.Signal, i.Device.whenReady = function(t, e, i) {
                    var s = this._readyCheck;
                    if (this.deviceReadyAt || !s) t.call(e, this);
                    else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]);
                    else {
                        s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
                        var n = void 0 !== window.cordova,
                            r = navigator.isCocoonJS;
                        "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !r ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
                    }
                }, i.Device._readyCheck = function() {
                    var t = this._readyCheck;
                    if (document.body) {
                        if (!this.deviceReadyAt) {
                            this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                            for (var e; e = t._queue.shift();) {
                                var i = e[0],
                                    s = e[1];
                                i.call(s, this)
                            }
                            this._readyCheck = null, this._initialize = null, this.onInitialized = null
                        }
                    } else window.setTimeout(t._monitor, 20)
                }, i.Device._initialize = function() {
                    function t() {
                        var t = new ArrayBuffer(4),
                            e = new Uint8Array(t),
                            i = new Uint32Array(t);
                        return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
                    }
        
                    function e() {
                        if (void 0 === Uint8ClampedArray) return !1;
                        var t = i.CanvasPool.create(this, 1, 1).getContext("2d");
                        if (!t) return !1;
                        var e = t.createImageData(1, 1);
                        return i.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray
                    }
                    var s = this;
                    ! function() {
                        var t = navigator.userAgent;
                        /Playstation Vita/.test(t) ? s.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? s.kindle = !0 : /Android/.test(t) ? s.android = !0 : /CrOS/.test(t) ? s.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (s.iOS = !0, navigator.appVersion.match(/OS (\d+)/), s.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? s.linux = !0 : /Mac OS/.test(t) ? s.macOS = !0 : /Windows/.test(t) && (s.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (s.android = !1, s.iOS = !1, s.macOS = !1, s.windows = !0, s.windowsPhone = !0);
                        var e = /Silk/.test(t);
                        (s.windows || s.macOS || s.linux && !e || s.chromeOS) && (s.desktop = !0), (s.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (s.desktop = !1)
                    }(),
                    function() {
                        var t = navigator.userAgent;
                        if (/Arora/.test(t) ? s.arora = !0 : /Edge\/\d+/.test(t) ? s.edge = !0 : /Chrome\/(\d+)/.test(t) && !s.windowsPhone ? (s.chrome = !0, s.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? s.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (s.firefox = !0, s.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && s.iOS ? s.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (s.ie = !0, s.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? s.midori = !0 : /Opera/.test(t) ? s.opera = !0 : /Safari\/(\d+)/.test(t) && !s.windowsPhone ? (s.safari = !0, /Version\/(\d+)\./.test(t) && (s.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (s.ie = !0, s.trident = !0, s.tridentVersion = parseInt(RegExp.$1, 10), s.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (s.silk = !0), navigator.standalone && (s.webApp = !0), void 0 !== window.cordova && (s.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (s.node = !0), s.node && "object" == typeof process.versions && (s.nodeWebkit = !!process.versions["node-webkit"], s.electron = !!process.versions.electron), navigator.isCocoonJS && (s.cocoonJS = !0), s.cocoonJS) try {
                            s.cocoonJSApp = "undefined" != typeof CocoonJS
                        } catch (t) {
                            s.cocoonJSApp = !1
                        }
                        void 0 !== window.ejecta && (s.ejecta = !0), /Crosswalk/.test(t) && (s.crosswalk = !0)
                    }(),
                    function() {
                        s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                        var t = document.createElement("audio");
                        try {
                            if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (s.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (s.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (s.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (s.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (s.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (s.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                                if (s.edge) s.dolby = !0;
                                else if (s.safari && s.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                                var e = parseInt(RegExp.$1, 10),
                                    i = parseInt(RegExp.$2, 10);
                                (10 === e && i >= 11 || e > 10) && (s.dolby = !0)
                            }
                        } catch (t) {}
                    }(),
                    function() {
                        var t = document.createElement("video");
                        try {
                            !!t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (s.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (s.h264Video = !0, s.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (s.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (s.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (s.hlsVideo = !0))
                        } catch (t) {}
                    }(),
                    function() {
                        var t, e = document.createElement("p"),
                            i = {
                                webkitTransform: "-webkit-transform",
                                OTransform: "-o-transform",
                                msTransform: "-ms-transform",
                                MozTransform: "-moz-transform",
                                transform: "transform"
                            };
                        document.body.insertBefore(e, null);
                        for (var n in i) void 0 !== e.style[n] && (e.style[n] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(i[n]));
                        document.body.removeChild(e), s.css3D = void 0 !== t && t.length > 0 && "none" !== t
                    }(), s.pixelRatio = window.devicePixelRatio || 1, s.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), s.iPhone4 = 2 === s.pixelRatio && s.iPhone, s.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? s.typedArray = !0 : s.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (s.littleEndian = t(), s.LITTLE_ENDIAN = s.littleEndian), s.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== s.littleEndian && e(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (s.vibration = !0),
                        function() {
                            s.canvas = !!window.CanvasRenderingContext2D || s.cocoonJS;
                            try {
                                s.localStorage = !!localStorage.getItem
                            } catch (t) {
                                s.localStorage = !1
                            }
                            s.file = !!(window.File && window.FileReader && window.FileList && window.Blob), s.fileSystem = !!window.requestFileSystem, s.webGL = !!window.WebGLRenderingContext, s.worker = !!window.Worker, s.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, s.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, s.getUserMedia = s.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (s.getUserMedia = !1), !s.iOS && (s.ie || s.firefox || s.chrome) && (s.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (s.canvasBitBltShift = !1)
                        }(),
                        function() {
                            var t = i.CanvasPool.create(this, 6, 1),
                                e = t.getContext("2d");
                            e.fillStyle = "rgba(10, 20, 30, 0.5)", e.fillRect(0, 0, 1, 1);
                            var n = e.getImageData(0, 0, 1, 1);
                            if (n) {
                                e.putImageData(n, 1, 0);
                                var r = e.getImageData(1, 0, 1, 1);
                                s.canHandleAlpha = r.data[0] === n.data[0] && r.data[1] === n.data[1] && r.data[2] === n.data[2] && r.data[3] === n.data[3]
                            }
                            e.globalCompositeOperation = "multiply", s.canUseMultiply = "multiply" === e.globalCompositeOperation, i.CanvasPool.removeByCanvas(t), PIXI.CanvasTinter.tintMethod = s.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply : PIXI.CanvasTinter.tintWithPerPixel
                        }(),
                        function() {
                            for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                                if (e[t[i]]) {
                                    s.fullscreen = !0, s.requestFullscreen = t[i];
                                    break
                                }
                            var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                            if (s.fullscreen)
                                for (i = 0; i < n.length; i++)
                                    if (document[n[i]]) {
                                        s.cancelFullscreen = n[i];
                                        break
                                    }
                            window.Element && Element.ALLOW_KEYBOARD_INPUT && (s.fullscreenKeyboard = !0)
                        }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (s.touch = !0), (window.PointerEvent || window.MSPointerEvent || window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (s.mspointer = !0), s.cocoonJS || ("onwheel" in window || s.ie && "WheelEvent" in window ? s.wheelEvent = "wheel" : "onmousewheel" in window ? s.wheelEvent = "mousewheel" : s.firefox && "MouseScrollEvent" in window && (s.wheelEvent = "DOMMouseScroll"))
                }, i.Device.canPlayAudio = function(t) {
                    return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
                }, i.Device.canPlayVideo = function(t) {
                    return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
                }, i.Device.needsTouchUnlock = function() {
                    return !!(!this.cocoonJS && (this.iOS || this.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)
                }, i.Device.isAndroidStockBrowser = function() {
                    var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                    return t && t[1] < 537
                }, i.Canvas = {
                    create: function(t, e, s, n, r) {
                        e = e || 256, s = s || 256;
                        var o = r ? document.createElement("canvas") : i.CanvasPool.create(t, e, s);
                        return "string" == typeof n && "" !== n && (o.id = n), o.width = e, o.height = s, o.style.display = "block", o
                    },
                    setBackgroundColor: function(t, e) {
                        return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
                    },
                    setTouchAction: function(t, e) {
                        return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
                    },
                    setUserSelect: function(t, e) {
                        return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
                    },
                    addToDOM: function(t, e, i) {
                        var s;
                        return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
                    },
                    removeFromDOM: function(t) {
                        t.parentNode && t.parentNode.removeChild(t)
                    },
                    setTransform: function(t, e, i, s, n, r, o) {
                        return t.setTransform(s, r, o, n, e, i), t
                    },
                    setSmoothingEnabled: function(t, e) {
                        var s = i.Canvas.getSmoothingPrefix(t);
                        return s && (t[s] = e), t
                    },
                    getSmoothingPrefix: function(t) {
                        var e = ["i", "webkitI", "msI", "mozI", "oI"];
                        for (var i in e) {
                            var s = e[i] + "mageSmoothingEnabled";
                            if (s in t) return s
                        }
                        return null
                    },
                    getSmoothingEnabled: function(t) {
                        var e = i.Canvas.getSmoothingPrefix(t);
                        if (e) return t[e]
                    },
                    setImageRenderingCrisp: function(t) {
                        for (var e = ["-webkit-optimize-contrast", "-moz-crisp-edges", "crisp-edges", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                        return t.style.msInterpolationMode = "nearest-neighbor", t
                    },
                    setImageRenderingBicubic: function(t) {
                        return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
                    }
                }, i.RequestAnimationFrame = function(t, e) {
                    void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
                    for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"] || window[i[s] + "CancelRequestAnimationFrame"];
                    this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
                }, i.RequestAnimationFrame.prototype = {
                    start: function() {
                        this.isRunning = !0;
                        var t = this;
                        !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                            return t.updateSetTimeout()
                        }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                            return t.updateRAF(e)
                        }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
                    },
                    updateRAF: function(t) {
                        this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
                    },
                    updateSetTimeout: function() {
                        this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
                    },
                    stop: function() {
                        this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
                    },
                    isSetTimeOut: function() {
                        return this._isSetTimeOut
                    },
                    isRAF: function() {
                        return !1 === this._isSetTimeOut
                    }
                }, i.RequestAnimationFrame.prototype.constructor = i.RequestAnimationFrame, i.Math = {
                    PI2: 2 * Math.PI,
                    HALF_PI: .5 * Math.PI,
                    DEG_TO_RAD: Math.PI / 180,
                    RAD_TO_DEG: 180 / Math.PI,
                    degToRad: function(t) {
                        return t * i.Math.DEG_TO_RAD
                    },
                    radToDeg: function(t) {
                        return t * i.Math.RAD_TO_DEG
                    },
                    getNextPowerOfTwo: function(t) {
                        if (t > 0 && 0 == (t & t - 1)) return t;
                        for (var e = 1; e < t;) e <<= 1;
                        return e
                    },
                    isPowerOfTwo: function(t, e) {
                        return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
                    },
                    random: function(t, e) {
                        if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                        if (t > e) {
                            var i = t;
                            t = e, e = i
                        }
                        return Math.random() * (e - t) + t
                    },
                    between: function(t, e) {
                        if (void 0 === t && (t = 0), void 0 === e && (e = 1), t === e) return t;
                        if (t > e) {
                            var i = t;
                            t = e, e = i
                        }
                        return t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t
                    },
                    fuzzyEqual: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
                    },
                    fuzzyLessThan: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), t < e + i
                    },
                    fuzzyGreaterThan: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), t > e - i
                    },
                    fuzzyCeil: function(t, e) {
                        return void 0 === e && (e = 1e-4), Math.ceil(t - e)
                    },
                    fuzzyFloor: function(t, e) {
                        return void 0 === e && (e = 1e-4), Math.floor(t + e)
                    },
                    average: function() {
                        for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                        return t / e
                    },
                    shear: function(t) {
                        return t % 1
                    },
                    snapTo: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
                    },
                    snapToFloor: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
                    },
                    snapToCeil: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
                    },
                    roundTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.round(t * s) / s
                    },
                    floorTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.floor(t * s) / s
                    },
                    ceilTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.ceil(t * s) / s
                    },
                    rotateToAngle: function(t, e, s) {
                        return void 0 === s && (s = .05), t === e ? t : (Math.abs(e - t) <= s || Math.abs(e - t) >= i.Math.PI2 - s ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += i.Math.PI2 : e -= i.Math.PI2), e > t ? t += s : e < t && (t -= s)), t)
                    },
                    getShortestAngle: function(t, e) {
                        var i = e - t;
                        return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
                    },
                    angleBetween: function(t, e, i, s) {
                        return Math.atan2(s - e, i - t)
                    },
                    angleBetweenY: function(t, e, i, s) {
                        return Math.atan2(i - t, s - e)
                    },
                    angleBetweenPoints: function(t, e) {
                        return Math.atan2(e.y - t.y, e.x - t.x)
                    },
                    angleBetweenPointsY: function(t, e) {
                        return Math.atan2(e.x - t.x, e.y - t.y)
                    },
                    reverseAngle: function(t) {
                        return this.normalizeAngle(t + Math.PI, !0)
                    },
                    normalizeAngle: function(t) {
                        return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI
                    },
                    maxAdd: function(t, e, i) {
                        return Math.min(t + e, i)
                    },
                    minSub: function(t, e, i) {
                        return Math.max(t - e, i)
                    },
                    wrap: function(t, e, i) {
                        var s = i - e;
                        if (s <= 0) return 0;
                        var n = (t - e) % s;
                        return n < 0 && (n += s), n + e
                    },
                    wrapValue: function(t, e, i) {
                        return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), (t + e) % i
                    },
                    isOdd: function(t) {
                        return !!(1 & t)
                    },
                    isEven: function(t) {
                        return !(1 & t)
                    },
                    min: function() {
                        if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                        else var t = arguments;
                        for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
                        return t[i]
                    },
                    max: function() {
                        if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                        else var t = arguments;
                        for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
                        return t[i]
                    },
                    minProperty: function(t) {
                        if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                        else var e = arguments.slice(1);
                        for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
                        return e[s][t]
                    },
                    maxProperty: function(t) {
                        if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                        else var e = arguments.slice(1);
                        for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
                        return e[s][t]
                    },
                    wrapAngle: function(t, e) {
                        return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
                    },
                    linearInterpolation: function(t, e) {
                        var i = t.length - 1,
                            s = i * e,
                            n = Math.floor(s);
                        return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i : n + 1], s - n)
                    },
                    bezierInterpolation: function(t, e) {
                        for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                        return i
                    },
                    catmullRomInterpolation: function(t, e) {
                        var i = t.length - 1,
                            s = i * e,
                            n = Math.floor(s);
                        return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
                    },
                    linear: function(t, e, i) {
                        return (e - t) * i + t
                    },
                    bernstein: function(t, e) {
                        return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
                    },
                    factorial: function(t) {
                        if (0 === t) return 1;
                        for (var e = t; --t;) e *= t;
                        return e
                    },
                    catmullRom: function(t, e, i, s, n) {
                        var r = .5 * (i - t),
                            o = .5 * (s - e),
                            a = n * n;
                        return (2 * e - 2 * i + r + o) * (n * a) + (-3 * e + 3 * i - 2 * r - o) * a + r * n + e
                    },
                    difference: function(t, e) {
                        return Math.abs(t - e)
                    },
                    roundAwayFromZero: function(t) {
                        return t > 0 ? Math.ceil(t) : Math.floor(t)
                    },
                    sinCosGenerator: function(t, e, i, s) {
                        void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                        for (var n = e, r = i, o = s * Math.PI / t, a = [], h = [], u = 0; u < t; u++) n += (r -= n * o) * o, a[u] = r, h[u] = n;
                        return {
                            sin: h,
                            cos: a,
                            length: t
                        }
                    },
                    hypot: function(t, e) {
                        return Math.sqrt(t * t + e * e)
                    },
                    distance: function(t, e, i, s) {
                        var n = t - i,
                            r = e - s;
                        return Math.sqrt(n * n + r * r)
                    },
                    distanceSq: function(t, e, i, s) {
                        var n = t - i,
                            r = e - s;
                        return n * n + r * r
                    },
                    distancePow: function(t, e, i, s, n) {
                        return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
                    },
                    clamp: function(t, e, i) {
                        return t < e ? e : i < t ? i : t
                    },
                    clampBottom: function(t, e) {
                        return t < e ? e : t
                    },
                    within: function(t, e, i) {
                        return Math.abs(t - e) <= i
                    },
                    mapLinear: function(t, e, i, s, n) {
                        return s + (t - e) * (n - s) / (i - e)
                    },
                    smoothstep: function(t, e, i) {
                        return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, i) {
                        return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
                    },
                    sign: function(t) {
                        return t < 0 ? -1 : t > 0 ? 1 : 0
                    },
                    percent: function(t, e, i) {
                        return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
                    }
                }, i.RandomDataGenerator = function(t) {
                    void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
                }, i.RandomDataGenerator.prototype = {
                    rnd: function() {
                        var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                        return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
                    },
                    sow: function(t) {
                        if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                            for (var e = 0; e < t.length && null != t[e]; e++) {
                                var i = t[e];
                                this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                            }
                    },
                    hash: function(t) {
                        var e, i, s;
                        for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (s += t.charCodeAt(i)), e -= s = e >>> 0, s = (e *= s) >>> 0, s += 4294967296 * (e -= s);
                        return 2.3283064365386963e-10 * (s >>> 0)
                    },
                    integer: function() {
                        return 4294967296 * this.rnd.apply(this)
                    },
                    frac: function() {
                        return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
                    },
                    real: function() {
                        return this.integer() + this.frac()
                    },
                    integerInRange: function(t, e) {
                        return Math.floor(this.realInRange(0, e - t + 1) + t)
                    },
                    between: function(t, e) {
                        return this.integerInRange(t, e)
                    },
                    realInRange: function(t, e) {
                        return this.frac() * (e - t) + t
                    },
                    normal: function() {
                        return 1 - 2 * this.frac()
                    },
                    uuid: function() {
                        var t = "",
                            e = "";
                        for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-");
                        return e
                    },
                    pick: function(t) {
                        return t[this.integerInRange(0, t.length - 1)]
                    },
                    sign: function() {
                        return this.pick([-1, 1])
                    },
                    weightedPick: function(t) {
                        return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
                    },
                    timestamp: function(t, e) {
                        return this.realInRange(t || 9466848e5, e || 1577862e6)
                    },
                    angle: function() {
                        return this.integerInRange(-180, 180)
                    },
                    state: function(t) {
                        return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
                    }
                }, i.RandomDataGenerator.prototype.constructor = i.RandomDataGenerator, i.QuadTree = function(t, e, i, s, n, r, o) {
                    this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, r, o)
                }, i.QuadTree.prototype = {
                    reset: function(t, e, i, s, n, r, o) {
                        this.maxObjects = n || 10, this.maxLevels = r || 4, this.level = o || 0, this.bounds = {
                            x: Math.round(t),
                            y: Math.round(e),
                            width: i,
                            height: s,
                            subWidth: Math.floor(i / 2),
                            subHeight: Math.floor(s / 2),
                            right: Math.round(t) + Math.floor(i / 2),
                            bottom: Math.round(e) + Math.floor(s / 2)
                        }, this.objects.length = 0, this.nodes.length = 0
                    },
                    populate: function(t) {
                        t.forEach(this.populateHandler, this, !0)
                    },
                    populateHandler: function(t) {
                        t.body && t.exists && this.insert(t.body)
                    },
                    split: function() {
                        this.nodes[0] = new i.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new i.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new i.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new i.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
                    },
                    insert: function(t) {
                        var e, i = 0;
                        if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) {
                            if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                                for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++
                        } else this.nodes[e].insert(t)
                    },
                    getIndex: function(t) {
                        var e = -1;
                        return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
                    },
                    retrieve: function(t) {
                        if (t instanceof i.Rectangle) var e = this.objects,
                            s = this.getIndex(t);
                        else {
                            if (!t.body) return this._empty;
                            var e = this.objects,
                                s = this.getIndex(t.body)
                        }
                        return this.nodes[0] && (e = -1 !== s ? e.concat(this.nodes[s].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e
                    },
                    clear: function() {
                        this.objects.length = 0;
                        for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                        this.nodes.length = 0
                    }
                }, i.QuadTree.prototype.constructor = i.QuadTree, i.Net = function(t) {
                    this.game = t
                }, i.Net.prototype = {
                    getHostName: function() {
                        return window.location && window.location.hostname ? window.location.hostname : null
                    },
                    checkDomainName: function(t) {
                        return -1 !== window.location.hostname.indexOf(t)
                    },
                    updateQueryString: function(t, e, i, s) {
                        void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
                        var n = "",
                            r = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                        if (r.test(s)) n = void 0 !== e && null !== e ? s.replace(r, "$1" + t + "=" + e + "$2$3") : s.replace(r, "$1$3").replace(/(&|\?)$/, "");
                        else if (void 0 !== e && null !== e) {
                            var o = -1 !== s.indexOf("?") ? "&" : "?",
                                a = s.split("#");
                            s = a[0] + o + t + "=" + e, a[1] && (s += "#" + a[1]), n = s
                        } else n = s;
                        if (!i) return n;
                        window.location.href = n
                    },
                    getQueryString: function(t) {
                        void 0 === t && (t = "");
                        var e = {},
                            i = location.search.substring(1).split("&");
                        for (var s in i) {
                            var n = i[s].split("=");
                            if (n.length > 1) {
                                if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                                e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                            }
                        }
                        return e
                    },
                    decodeURI: function(t) {
                        return decodeURIComponent(t.replace(/\+/g, " "))
                    }
                }, i.Net.prototype.constructor = i.Net, i.TweenManager = function(t) {
                    this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                        Power0: i.Easing.Power0,
                        Power1: i.Easing.Power1,
                        Power2: i.Easing.Power2,
                        Power3: i.Easing.Power3,
                        Power4: i.Easing.Power4,
                        Linear: i.Easing.Linear.None,
                        Quad: i.Easing.Quadratic.Out,
                        Cubic: i.Easing.Cubic.Out,
                        Quart: i.Easing.Quartic.Out,
                        Quint: i.Easing.Quintic.Out,
                        Sine: i.Easing.Sinusoidal.Out,
                        Expo: i.Easing.Exponential.Out,
                        Circ: i.Easing.Circular.Out,
                        Elastic: i.Easing.Elastic.Out,
                        Back: i.Easing.Back.Out,
                        Bounce: i.Easing.Bounce.Out,
                        "Quad.easeIn": i.Easing.Quadratic.In,
                        "Cubic.easeIn": i.Easing.Cubic.In,
                        "Quart.easeIn": i.Easing.Quartic.In,
                        "Quint.easeIn": i.Easing.Quintic.In,
                        "Sine.easeIn": i.Easing.Sinusoidal.In,
                        "Expo.easeIn": i.Easing.Exponential.In,
                        "Circ.easeIn": i.Easing.Circular.In,
                        "Elastic.easeIn": i.Easing.Elastic.In,
                        "Back.easeIn": i.Easing.Back.In,
                        "Bounce.easeIn": i.Easing.Bounce.In,
                        "Quad.easeOut": i.Easing.Quadratic.Out,
                        "Cubic.easeOut": i.Easing.Cubic.Out,
                        "Quart.easeOut": i.Easing.Quartic.Out,
                        "Quint.easeOut": i.Easing.Quintic.Out,
                        "Sine.easeOut": i.Easing.Sinusoidal.Out,
                        "Expo.easeOut": i.Easing.Exponential.Out,
                        "Circ.easeOut": i.Easing.Circular.Out,
                        "Elastic.easeOut": i.Easing.Elastic.Out,
                        "Back.easeOut": i.Easing.Back.Out,
                        "Bounce.easeOut": i.Easing.Bounce.Out,
                        "Quad.easeInOut": i.Easing.Quadratic.InOut,
                        "Cubic.easeInOut": i.Easing.Cubic.InOut,
                        "Quart.easeInOut": i.Easing.Quartic.InOut,
                        "Quint.easeInOut": i.Easing.Quintic.InOut,
                        "Sine.easeInOut": i.Easing.Sinusoidal.InOut,
                        "Expo.easeInOut": i.Easing.Exponential.InOut,
                        "Circ.easeInOut": i.Easing.Circular.InOut,
                        "Elastic.easeInOut": i.Easing.Elastic.InOut,
                        "Back.easeInOut": i.Easing.Back.InOut,
                        "Bounce.easeInOut": i.Easing.Bounce.InOut
                    }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
                }, i.TweenManager.prototype = {
                    getAll: function() {
                        return this._tweens
                    },
                    removeAll: function() {
                        for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                        this._add = []
                    },
                    removeFrom: function(t, e) {
                        void 0 === e && (e = !0);
                        if (Array.isArray(t))
                            for (s = 0, n = t.length; s < n; s++) this.removeFrom(t[s]);
                        else if (t.type === i.GROUP && e)
                            for (var s = 0, n = t.children.length; s < n; s++) this.removeFrom(t.children[s]);
                        else {
                            for (s = 0, n = this._tweens.length; s < n; s++) t === this._tweens[s].target && this.remove(this._tweens[s]);
                            for (s = 0, n = this._add.length; s < n; s++) t === this._add[s].target && this.remove(this._add[s])
                        }
                    },
                    add: function(t) {
                        t._manager = this, this._add.push(t)
                    },
                    create: function(t) {
                        return new i.Tween(t, this.game, this)
                    },
                    remove: function(t) {
                        var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
                    },
                    update: function() {
                        var t = this._add.length,
                            e = this._tweens.length;
                        if (0 === e && 0 === t) return !1;
                        for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                        return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
                    },
                    isTweening: function(t, e) {
                        return e || (e = !1), this._tweens.some(function(i) {
                            return i.target === t && (!e || i.isRunning && !i.pendingDelete)
                        })
                    },
                    _pauseAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
                    },
                    _resumeAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
                    },
                    pauseAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
                    },
                    resumeAll: function() {
                        for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
                    }
                }, i.TweenManager.prototype.constructor = i.TweenManager, i.Tween = function(t, e, s) {
                    this.game = e, this.target = t, this.manager = s, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new i.Signal, this.onLoop = new i.Signal, this.onRepeat = new i.Signal, this.onChildComplete = new i.Signal, this.onComplete = new i.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = s.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
                }, i.Tween.updateColor = function(t) {
                    i.Color.updateColor(t.target)
                }, i.Tween.prototype = {
                    to: function(t, e, s, n, r, o, a) {
                        return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== s && null !== s || (s = i.Easing.Default), void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.to cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).to(t, e, s, r, o, a)), n && this.start(), this)
                    },
                    from: function(t, e, s, n, r, o, a) {
                        return void 0 === e && (e = 1e3), void 0 !== s && null !== s || (s = i.Easing.Default), void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = !1), "string" == typeof s && this.manager.easeMap[s] && (s = this.manager.easeMap[s]), this.isRunning ? (console.warn("Phaser.Tween.from cannot be called after Tween.start"), this) : (this.timeline.push(new i.TweenData(this).from(t, e, s, r, o, a)), n && this.start(), this)
                    },
                    start: function(t) {
                        if (void 0 === t && (t = 0), this.pendingDelete) return console.warn("Phaser.Tween.start cannot be called after Tween.stop"), this;
                        if (null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                        for (i = 0; i < this.timeline.length; i++)
                            for (var e in this.timeline[i].vEnd) this.properties[e] = this.target[e] || 0, Array.isArray(this.properties[e]) || (this.properties[e] *= 1);
                        for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                        return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
                    },
                    stop: function(t) {
                        return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
                    },
                    updateTweenData: function(t, e, i) {
                        if (0 === this.timeline.length) return this;
                        if (void 0 === i && (i = 0), -1 === i)
                            for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                        else this.timeline[i][t] = e;
                        return this
                    },
                    delay: function(t, e) {
                        return this.updateTweenData("delay", t, e)
                    },
                    repeat: function(t, e, i) {
                        return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatTotal", t, i), this.updateTweenData("repeatDelay", e, i)
                    },
                    repeatDelay: function(t, e) {
                        return this.updateTweenData("repeatDelay", t, e)
                    },
                    yoyo: function(t, e, i) {
                        return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
                    },
                    yoyoDelay: function(t, e) {
                        return this.updateTweenData("yoyoDelay", t, e)
                    },
                    easing: function(t, e) {
                        return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
                    },
                    interpolation: function(t, e, s) {
                        return void 0 === e && (e = i.Math), this.updateTweenData("interpolationFunction", t, s), this.updateTweenData("interpolationContext", e, s)
                    },
                    repeatAll: function(t) {
                        return void 0 === t && (t = 0), this.repeatCounter = t, this
                    },
                    chain: function() {
                        for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                        return this
                    },
                    loop: function(t) {
                        return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
                    },
                    onUpdateCallback: function(t, e) {
                        return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
                    },
                    pause: function() {
                        this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
                    },
                    _pause: function() {
                        this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
                    },
                    resume: function() {
                        if (this.isPaused) {
                            this.isPaused = !1, this._codePaused = !1;
                            for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                        }
                    },
                    _resume: function() {
                        this._codePaused || this.resume()
                    },
                    update: function(t) {
                        if (this.pendingDelete || !this.target) return !1;
                        if (this.isPaused) return !0;
                        var e = this.timeline[this.current].update(t);
                        if (e === i.TweenData.PENDING) return !0;
                        if (e === i.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                        if (e === i.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                        if (e === i.TweenData.COMPLETE) {
                            var s = !1;
                            return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, s = !0) : ++this.current === this.timeline.length && (this.current = 0, s = !0), s ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                        }
                    },
                    generateData: function(t, e) {
                        if (null === this.game || null === this.target) return null;
                        void 0 === t && (t = 60), void 0 === e && (e = []);
                        for (s = 0; s < this.timeline.length; s++)
                            for (var i in this.timeline[s].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                        for (s = 0; s < this.timeline.length; s++) this.timeline[s].loadValues();
                        for (var s = 0; s < this.timeline.length; s++) e = e.concat(this.timeline[s].generateData(t));
                        return e
                    }
                }, Object.defineProperty(i.Tween.prototype, "totalDuration", {
                    get: function() {
                        for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                        return t
                    }
                }), i.Tween.prototype.constructor = i.Tween, i.TweenData = function(t) {
                    this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = i.Easing.Default, this.interpolationFunction = i.Math.linearInterpolation, this.interpolationContext = i.Math, this.isRunning = !1, this.isFrom = !1
                }, i.TweenData.PENDING = 0, i.TweenData.RUNNING = 1, i.TweenData.LOOPED = 2, i.TweenData.COMPLETE = 3, i.TweenData.prototype = {
                    to: function(t, e, i, s, n, r) {
                        return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !1, this
                    },
                    from: function(t, e, i, s, n, r) {
                        return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = r, this.isFrom = !0, this
                    },
                    start: function() {
                        if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                            for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                        return this.value = 0, this.repeatCounter = this.repeatTotal, this
                    },
                    loadValues: function() {
                        for (var t in this.parent.properties) {
                            if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                                if (0 === this.vEnd[t].length) continue;
                                0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                            }
                            void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                        }
                        return this
                    },
                    update: function(t) {
                        if (this.isRunning) {
                            if (t < this.startTime) return i.TweenData.RUNNING
                        } else {
                            if (!(t >= this.startTime)) return i.TweenData.PENDING;
                            this.isRunning = !0
                        }
                        var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                        this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                        for (var s in this.vEnd) {
                            var n = this.vStart[s],
                                r = this.vEnd[s];
                            Array.isArray(r) ? this.parent.target[s] = this.interpolationFunction.call(this.interpolationContext, r, this.value) : this.parent.target[s] = n + (r - n) * this.value
                        }
                        return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : i.TweenData.RUNNING
                    },
                    generateData: function(t) {
                        this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                        var e = [],
                            i = !1,
                            s = 1 / t * 1e3;
                        do {
                            this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                            var n = {};
                            for (var r in this.vEnd) {
                                var o = this.vStart[r],
                                    a = this.vEnd[r];
                                Array.isArray(a) ? n[r] = this.interpolationFunction.call(this.interpolationContext, a, this.value) : n[r] = o + (a - o) * this.value
                            }
                            e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                        } while (!i);
                        if (this.yoyo) {
                            var h = e.slice();
                            h.reverse(), e = e.concat(h)
                        }
                        return e
                    },
                    repeat: function() {
                        if (this.yoyo) {
                            if (this.inReverse && 0 === this.repeatCounter) {
                                for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                                return this.inReverse = !1, i.TweenData.COMPLETE
                            }
                            this.inReverse = !this.inReverse
                        } else if (0 === this.repeatCounter) return i.TweenData.COMPLETE;
                        if (this.inReverse)
                            for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                        else {
                            for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                            this.repeatCounter > 0 && this.repeatCounter--
                        }
                        return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, i.TweenData.LOOPED
                    }
                }, i.TweenData.prototype.constructor = i.TweenData, i.Easing = {
                    Linear: {
                        None: function(t) {
                            return t
                        }
                    },
                    Quadratic: {
                        In: function(t) {
                            return t * t
                        },
                        Out: function(t) {
                            return t * (2 - t)
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                        }
                    },
                    Cubic: {
                        In: function(t) {
                            return t * t * t
                        },
                        Out: function(t) {
                            return --t * t * t + 1
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                        }
                    },
                    Quartic: {
                        In: function(t) {
                            return t * t * t * t
                        },
                        Out: function(t) {
                            return 1 - --t * t * t * t
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                        }
                    },
                    Quintic: {
                        In: function(t) {
                            return t * t * t * t * t
                        },
                        Out: function(t) {
                            return --t * t * t * t * t + 1
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                        }
                    },
                    Sinusoidal: {
                        In: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                        },
                        Out: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                        }
                    },
                    Exponential: {
                        In: function(t) {
                            return 0 === t ? 0 : Math.pow(1024, t - 1)
                        },
                        Out: function(t) {
                            return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                        },
                        InOut: function(t) {
                            return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        }
                    },
                    Circular: {
                        In: function(t) {
                            return 1 - Math.sqrt(1 - t * t)
                        },
                        Out: function(t) {
                            return Math.sqrt(1 - --t * t)
                        },
                        InOut: function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        }
                    },
                    Elastic: {
                        In: function(t) {
                            var e, i = .1;
                            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
                        },
                        Out: function(t) {
                            var e, i = .1;
                            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
                        },
                        InOut: function(t) {
                            var e, i = .1;
                            return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
                        }
                    },
                    Back: {
                        In: function(t) {
                            var e = 1.70158;
                            return t * t * ((e + 1) * t - e)
                        },
                        Out: function(t) {
                            var e = 1.70158;
                            return --t * t * ((e + 1) * t + e) + 1
                        },
                        InOut: function(t) {
                            var e = 2.5949095;
                            return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                        }
                    },
                    Bounce: {
                        In: function(t) {
                            return 1 - i.Easing.Bounce.Out(1 - t)
                        },
                        Out: function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        },
                        InOut: function(t) {
                            return t < .5 ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5
                        }
                    }
                }, i.Easing.Default = i.Easing.Linear.None, i.Easing.Power0 = i.Easing.Linear.None, i.Easing.Power1 = i.Easing.Quadratic.Out, i.Easing.Power2 = i.Easing.Cubic.Out, i.Easing.Power3 = i.Easing.Quartic.Out, i.Easing.Power4 = i.Easing.Quintic.Out, i.Time = function(t) {
                    this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.updates = 0, this.renders = 0, this.fps = 0, this.ups = 0, this.rps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new i.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
                }, i.Time.prototype = {
                    boot: function() {
                        this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
                    },
                    add: function(t) {
                        return this._timers.push(t), t
                    },
                    create: function(t) {
                        void 0 === t && (t = !0);
                        var e = new i.Timer(this.game, t);
                        return this._timers.push(e), e
                    },
                    removeAll: function() {
                        for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                        this._timers = [], this.events.removeAll()
                    },
                    refresh: function() {
                        var t = this.time;
                        this.time = Date.now(), this.elapsedMS = this.time - t
                    },
                    update: function(t) {
                        var e = this.time;
                        this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
                    },
                    updateTimers: function() {
                        for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
                    },
                    updateAdvancedTiming: function() {
                        if (this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3) {
                            var t = this.now - this._timeLastSecond;
                            this.fps = Math.round(1e3 * this.frames / t), this.ups = Math.round(1e3 * this.updates / t), this.rps = Math.round(1e3 * this.renders / t), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0, this.updates = 0, this.renders = 0
                        }
                    },
                    countUpdate: function() {
                        this.advancedTiming && this.updates++
                    },
                    countRender: function() {
                        this.advancedTiming && this.renders++
                    },
                    gamePaused: function() {
                        this._pauseStarted = Date.now(), this.events.pause();
                        for (var t = this._timers.length; t--;) this._timers[t]._pause()
                    },
                    gameResumed: function() {
                        this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                        for (var t = this._timers.length; t--;) this._timers[t]._resume()
                    },
                    totalElapsedSeconds: function() {
                        return .001 * (this.time - this._started)
                    },
                    elapsedSince: function(t) {
                        return this.time - t
                    },
                    elapsedSecondsSince: function(t) {
                        return .001 * (this.time - t)
                    },
                    reset: function() {
                        this._started = this.time, this.removeAll()
                    }
                }, Object.defineProperty(i.Time.prototype, "desiredFps", {
                    get: function() {
                        return this._desiredFps
                    },
                    set: function(t) {
                        this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
                    }
                }), i.Time.prototype.constructor = i.Time, i.Timer = function(t, e) {
                    void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new i.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
                }, i.Timer.MINUTE = 6e4, i.Timer.SECOND = 1e3, i.Timer.HALF = 500, i.Timer.QUARTER = 250, i.Timer.prototype = {
                    create: function(t, e, s, n, r, o) {
                        var a = t = Math.round(t);
                        0 === this._now ? a += this.game.time.time : a += this._now;
                        var h = new i.TimerEvent(this, t, a, s, e, n, r, o);
                        return this.events.push(h), this.order(), this.expired = !1, h
                    },
                    add: function(t, e, i) {
                        return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
                    },
                    repeat: function(t, e, i, s) {
                        return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
                    },
                    loop: function(t, e, i) {
                        return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
                    },
                    start: function(t) {
                        if (!this.running) {
                            this._started = this.game.time.time + (t || 0), this.running = !0;
                            for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                        }
                    },
                    stop: function(t) {
                        this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
                    },
                    remove: function(t) {
                        for (var e = 0; e < this.events.length; e++)
                            if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                        return !1
                    },
                    order: function() {
                        this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
                    },
                    sortHandler: function(t, e) {
                        return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
                    },
                    clearPendingEvents: function() {
                        for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                        this._len = this.events.length, this._i = 0
                    },
                    update: function(t) {
                        if (this.paused) return !0;
                        if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                            for (; this._i < this._len && this.running;) {
                                var e = this.events[this._i];
                                if (!(this._now >= e.tick) || e.pendingDelete) break;
                                this._newTick = this._now + e.delay - (this._now - e.tick), this._newTick < 0 && (this._newTick = this._now + e.delay), !0 === e.loop ? (e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : e.repeatCount > 0 ? (e.repeatCount--, e.tick = this._newTick, e.callback.apply(e.callbackContext, e.args)) : (this._marked++, e.pendingDelete = !0, e.callback.apply(e.callbackContext, e.args)), this._i++
                            }
                            this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                        }
                        return !this.expired || !this.autoDestroy
                    },
                    pause: function() {
                        this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
                    },
                    _pause: function() {
                        !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
                    },
                    adjustEvents: function(t) {
                        for (var e = 0; e < this.events.length; e++)
                            if (!this.events[e].pendingDelete) {
                                var i = this.events[e].tick - t;
                                i < 0 && (i = 0), this.events[e].tick = this._now + i
                            }
                        var s = this.nextTick - t;
                        this.nextTick = s < 0 ? this._now : this._now + s
                    },
                    resume: function() {
                        if (this.paused) {
                            var t = this.game.time.time;
                            this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                        }
                    },
                    _resume: function() {
                        this._codePaused || this.resume()
                    },
                    removeAll: function() {
                        this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
                    },
                    destroy: function() {
                        this.onComplete.removeAll(), this.running = !1, this.expired = !0, this.events = [], this._len = 0, this._i = 0
                    }
                }, Object.defineProperty(i.Timer.prototype, "next", {
                    get: function() {
                        return this.nextTick
                    }
                }), Object.defineProperty(i.Timer.prototype, "duration", {
                    get: function() {
                        return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
                    }
                }), Object.defineProperty(i.Timer.prototype, "length", {
                    get: function() {
                        return this.events.length
                    }
                }), Object.defineProperty(i.Timer.prototype, "ms", {
                    get: function() {
                        return this.running ? this._now - this._started - this._pauseTotal : 0
                    }
                }), Object.defineProperty(i.Timer.prototype, "seconds", {
                    get: function() {
                        return this.running ? .001 * this.ms : 0
                    }
                }), i.Timer.prototype.constructor = i.Timer, i.TimerEvent = function(t, e, i, s, n, r, o, a) {
                    this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = r, this.callbackContext = o, this.args = a, this.pendingDelete = !1
                }, i.TimerEvent.prototype.constructor = i.TimerEvent, i.AnimationManager = function(t) {
                    this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
                }, i.AnimationManager.prototype = {
                    loadFrameData: function(t, e) {
                        if (void 0 === t) return !1;
                        if (this.isLoaded)
                            for (var i in this._anims) this._anims[i].updateFrameData(t);
                        return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                    },
                    copyFrameData: function(t, e) {
                        if (this._frameData = t.clone(), this.isLoaded)
                            for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                        return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                    },
                    add: function(t, e, s, n, r) {
                        return e = e || [], s = s || 60, void 0 === n && (n = !1), void 0 === r && (r = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, r, this._outputFrames), this._anims[t] = new i.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, s, n), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
                    },
                    validateFrames: function(t, e) {
                        void 0 === e && (e = !0);
                        for (var i = 0; i < t.length; i++)
                            if (!0 === e) {
                                if (t[i] > this._frameData.total) return !1
                            } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                        return !0
                    },
                    play: function(t, e, i, s) {
                        if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
                    },
                    stop: function(t, e) {
                        void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
                    },
                    update: function() {
                        return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
                    },
                    next: function(t) {
                        this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
                    },
                    previous: function(t) {
                        this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
                    },
                    getAnimation: function(t) {
                        return "string" == typeof t && this._anims[t] ? this._anims[t] : null
                    },
                    refreshFrame: function() {},
                    destroy: function() {
                        t = null;
                        for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                        this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
                    }
                }, i.AnimationManager.prototype.constructor = i.AnimationManager, Object.defineProperty(i.AnimationManager.prototype, "frameData", {
                    get: function() {
                        return this._frameData
                    }
                }), Object.defineProperty(i.AnimationManager.prototype, "frameTotal", {
                    get: function() {
                        return this._frameData.total
                    }
                }), Object.defineProperty(i.AnimationManager.prototype, "paused", {
                    get: function() {
                        return this.currentAnim.isPaused
                    },
                    set: function(t) {
                        this.currentAnim.paused = t
                    }
                }), Object.defineProperty(i.AnimationManager.prototype, "name", {
                    get: function() {
                        if (this.currentAnim) return this.currentAnim.name
                    }
                }), Object.defineProperty(i.AnimationManager.prototype, "frame", {
                    get: function() {
                        if (this.currentFrame) return this.currentFrame.index
                    },
                    set: function(t) {
                        var e;
                        "number" == typeof t && this._frameData && (e = this._frameData.getFrame(t)) && (this.currentFrame = e, this.sprite.setFrame(this.currentFrame))
                    }
                }), Object.defineProperty(i.AnimationManager.prototype, "frameName", {
                    get: function() {
                        if (this.currentFrame) return this.currentFrame.name
                    },
                    set: function(t) {
                        var e;
                        "string" == typeof t && this._frameData && (e = this._frameData.getFrameByName(t)) ? (this.currentFrame = e, this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)) : console.warn("Cannot set frameName: " + t)
                    }
                }), i.Animation = function(t, e, s, n, r, o, a) {
                    void 0 === a && (a = !1), this.game = t, this._parent = e, this._frameData = n, this.name = s, this._frames = [], this._frames = this._frames.concat(r), this.delay = 1e3 / o, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new i.Signal, this.onUpdate = null, this.onComplete = new i.Signal, this.onLoop = new i.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
                }, i.Animation.prototype = {
                    play: function(t, e, i) {
                        return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
                    },
                    restart: function() {
                        this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
                    },
                    reverse: function() {
                        return this.reversed = !this.reversed, this
                    },
                    reverseOnce: function() {
                        return this.onComplete.addOnce(this.reverse, this), this.reverse()
                    },
                    setFrame: function(t, e) {
                        var i;
                        if (void 0 === e && (e = !1), "string" == typeof t)
                            for (s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s]).name === t && (i = s);
                        else if ("number" == typeof t)
                            if (e) i = t;
                            else
                                for (var s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                        if (i) {
                            var n = this.isReversed ? -1 : 1;
                            this._frameIndex = i - n, this._timeNextFrame = this.game.time.time, this.update()
                        }
                    },
                    stop: function(t, e) {
                        void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
                    },
                    onPause: function() {
                        this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
                    },
                    onResume: function() {
                        this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
                    },
                    update: function() {
                        return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay ? (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay) : this._frameDiff = 0, this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
                    },
                    updateCurrentFrame: function(t, e) {
                        if (void 0 === e && (e = !1), !this._frameData) return !1;
                        var i = this.currentFrame.index;
                        return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
                    },
                    next: function(t) {
                        void 0 === t && (t = 1);
                        var e = this._frameIndex + t;
                        e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                    },
                    previous: function(t) {
                        void 0 === t && (t = 1);
                        var e = this._frameIndex - t;
                        e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                    },
                    updateFrameData: function(t) {
                        this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
                    },
                    destroy: function() {
                        this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
                    },
                    complete: function() {
                        this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
                    }
                }, i.Animation.prototype.constructor = i.Animation, Object.defineProperty(i.Animation.prototype, "paused", {
                    get: function() {
                        return this.isPaused
                    },
                    set: function(t) {
                        this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
                    }
                }), Object.defineProperty(i.Animation.prototype, "reversed", {
                    get: function() {
                        return this.isReversed
                    },
                    set: function(t) {
                        this.isReversed = t
                    }
                }), Object.defineProperty(i.Animation.prototype, "frameTotal", {
                    get: function() {
                        return this._frames.length
                    }
                }), Object.defineProperty(i.Animation.prototype, "frame", {
                    get: function() {
                        return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
                    },
                    set: function(t) {
                        this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
                    }
                }), Object.defineProperty(i.Animation.prototype, "speed", {
                    get: function() {
                        return 1e3 / this.delay
                    },
                    set: function(t) {
                        t > 0 && (this.delay = 1e3 / t)
                    }
                }), Object.defineProperty(i.Animation.prototype, "enableUpdate", {
                    get: function() {
                        return null !== this.onUpdate
                    },
                    set: function(t) {
                        t && null === this.onUpdate ? this.onUpdate = new i.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
                    }
                }), i.Animation.generateFrameNames = function(t, e, s, n, r) {
                    void 0 === n && (n = "");
                    var o = [],
                        a = "";
                    if (e < s)
                        for (h = e; h <= s; h++) a = t + (a = "number" == typeof r ? i.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n, o.push(a);
                    else
                        for (var h = e; h >= s; h--) a = t + (a = "number" == typeof r ? i.Utils.pad(h.toString(), r, "0", 1) : h.toString()) + n, o.push(a);
                    return o
                }, i.Frame = function(t, e, s, n, r, o) {
                    this.index = t, this.x = e, this.y = s, this.width = n, this.height = r, 0 !== this.width && 0 !== this.height || console.warn('Phaser.Frame: Frame "' + this.name + '" has a width or height of zero'), this.name = o, this.centerX = Math.floor(n / 2), this.centerY = Math.floor(r / 2), this.distance = i.Math.distance(0, 0, n, r), this.rotated = !1, this.trimmed = !1, this.sourceSizeW = n, this.sourceSizeH = r, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
                }, i.Frame.prototype = {
                    resize: function(t, e) {
                        this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = i.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
                    },
                    setTrim: function(t, e, i, s, n, r, o) {
                        this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = r, this.spriteSourceSizeH = o)
                    },
                    clone: function() {
                        var t = new i.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                        for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                        return t
                    },
                    getRect: function(t) {
                        return void 0 === t ? t = new i.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                    }
                }, i.Frame.prototype.constructor = i.Frame, i.FrameData = function() {
                    this._frames = [], this._frameNames = []
                }, i.FrameData.prototype = {
                    addFrame: function(t) {
                        return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
                    },
                    getFrame: function(t) {
                        return t >= this._frames.length && (t = 0), this._frames[t]
                    },
                    getFrameByName: function(t) {
                        return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
                    },
                    checkFrameName: function(t) {
                        return null != this._frameNames[t]
                    },
                    clone: function() {
                        for (var t = new i.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                        for (var s in this._frameNames) this._frameNames.hasOwnProperty(s) && t._frameNames.push(this._frameNames[s]);
                        return t
                    },
                    getFrameRange: function(t, e, i) {
                        void 0 === i && (i = []);
                        for (var s = t; s <= e; s++) i.push(this._frames[s]);
                        return i
                    },
                    getFrames: function(t, e, i) {
                        if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                            for (s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                        else
                            for (var s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                        return i
                    },
                    getFrameIndexes: function(t, e, i) {
                        if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                            for (s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                        else
                            for (var s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s]).index);
                        return i
                    },
                    destroy: function() {
                        this._frames = null, this._frameNames = null
                    }
                }, i.FrameData.prototype.constructor = i.FrameData, Object.defineProperty(i.FrameData.prototype, "total", {
                    get: function() {
                        return this._frames.length
                    }
                }), i.AnimationParser = {
                    spriteSheet: function(t, e, s, n, r, o, a, h) {
                        void 0 === r && (r = -1), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === h && (h = 0);
                        var u = e;
                        if ("string" == typeof e && (u = t.cache.getImage(e)), null === u) return null;
                        var l = u.width,
                            c = u.height;
                        s <= 0 && (s = Math.floor(-l / Math.min(-1, s))), n <= 0 && (n = Math.floor(-c / Math.min(-1, n)));
                        var d = Math.floor((l - o) / (s + a)) * Math.floor((c - o) / (n + a));
                        if (h > d || h < -d) return console.warn("Phaser.AnimationParser.spriteSheet: skipFrames = " + h.toString() + " is larger than total sprite number " + d.toString()), null;
                        if (h < 0 && (h = d + h), -1 !== r && (d = h + r), 0 === l || 0 === c || l < s || c < n || 0 === d) return console.warn("Phaser.AnimationParser.spriteSheet: '" + e + "'s width/height zero or width/height < given frameWidth/frameHeight"), null;
                        for (var p = new i.FrameData, f = o, g = o, m = 0; m < d; m++) p.addFrame(new i.Frame(m, f, g, s, n, "")), (f += s + a) + s > l && (f = o, g += n + a);
                        return p
                    },
                    JSONData: function(t, e) {
                        if (!e.frames) return console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"), void console.log(e);
                        for (var s, n = new i.FrameData, r = e.frames, o = 0; o < r.length; o++) s = n.addFrame(new i.Frame(o, r[o].frame.x, r[o].frame.y, r[o].frame.w, r[o].frame.h, r[o].filename)), r[o].trimmed && s.setTrim(r[o].trimmed, r[o].sourceSize.w, r[o].sourceSize.h, r[o].spriteSourceSize.x, r[o].spriteSourceSize.y, r[o].spriteSourceSize.w, r[o].spriteSourceSize.h), r[o].rotated && (s.rotated = !0);
                        return n
                    },
                    JSONDataPyxel: function(t, e) {
                        if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                                if (!e[t]) return console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + t + '" key.'), void console.log(e)
                            }), 1 !== e.layers.length) return console.warn("Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps."), void console.log(e);
                        for (var s = new i.FrameData, n = e.tileheight, r = e.tilewidth, o = e.layers[0].tiles, a = 0; a < o.length; a++) s.addFrame(new i.Frame(a, o[a].x, o[a].y, r, n, "frame_" + a)).setTrim(!1);
                        return s
                    },
                    JSONDataHash: function(t, e) {
                        if (!e.frames) return console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"), void console.log(e);
                        var s, n = new i.FrameData,
                            r = e.frames,
                            o = 0;
                        for (var a in r) s = n.addFrame(new i.Frame(o, r[a].frame.x, r[a].frame.y, r[a].frame.w, r[a].frame.h, a)), r[a].trimmed && s.setTrim(r[a].trimmed, r[a].sourceSize.w, r[a].sourceSize.h, r[a].spriteSourceSize.x, r[a].spriteSourceSize.y, r[a].spriteSourceSize.w, r[a].spriteSourceSize.h), r[a].rotated && (s.rotated = !0), o++;
                        return n
                    },
                    XMLData: function(t, e) {
                        if (e.getElementsByTagName("TextureAtlas")) {
                            for (var s, n, r, o, a, h, u, l, c, d, p, f = new i.FrameData, g = e.getElementsByTagName("SubTexture"), m = 0; m < g.length; m++) n = (r = g[m].attributes).name.value, o = parseInt(r.x.value, 10), a = parseInt(r.y.value, 10), h = parseInt(r.width.value, 10), u = parseInt(r.height.value, 10), l = null, c = null, r.frameX && (l = Math.abs(parseInt(r.frameX.value, 10)), c = Math.abs(parseInt(r.frameY.value, 10)), d = parseInt(r.frameWidth.value, 10), p = parseInt(r.frameHeight.value, 10)), s = f.addFrame(new i.Frame(m, o, a, h, u, n)), null === l && null === c || s.setTrim(!0, h, u, l, c, d, p);
                            return f
                        }
                        console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag")
                    }
                }, i.Cache = function(t) {
                    this.game = t, this.autoResolveURL = !1, this._cache = {
                        canvas: {},
                        image: {},
                        texture: {},
                        sound: {},
                        video: {},
                        text: {},
                        json: {},
                        xml: {},
                        physics: {},
                        tilemap: {},
                        binary: {},
                        bitmapData: {},
                        bitmapFont: {},
                        shader: {},
                        renderTexture: {},
                        compressedTexture: {}
                    }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new i.Signal, this._cacheMap = [], this._cacheMap[i.Cache.CANVAS] = this._cache.canvas, this._cacheMap[i.Cache.IMAGE] = this._cache.image, this._cacheMap[i.Cache.TEXTURE] = this._cache.texture, this._cacheMap[i.Cache.SOUND] = this._cache.sound, this._cacheMap[i.Cache.TEXT] = this._cache.text, this._cacheMap[i.Cache.PHYSICS] = this._cache.physics, this._cacheMap[i.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[i.Cache.BINARY] = this._cache.binary, this._cacheMap[i.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[i.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[i.Cache.JSON] = this._cache.json, this._cacheMap[i.Cache.XML] = this._cache.xml, this._cacheMap[i.Cache.VIDEO] = this._cache.video, this._cacheMap[i.Cache.SHADER] = this._cache.shader, this._cacheMap[i.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this._pendingCount = 0, this.onReady = new i.Signal, this._addImages()
                }, i.Cache.CANVAS = 1, i.Cache.IMAGE = 2, i.Cache.TEXTURE = 3, i.Cache.SOUND = 4, i.Cache.TEXT = 5, i.Cache.PHYSICS = 6, i.Cache.TILEMAP = 7, i.Cache.BINARY = 8, i.Cache.BITMAPDATA = 9, i.Cache.BITMAPFONT = 10, i.Cache.JSON = 11, i.Cache.XML = 12, i.Cache.VIDEO = 13, i.Cache.SHADER = 14, i.Cache.RENDER_TEXTURE = 15, i.Cache.DEFAULT = null, i.Cache.DEFAULT_KEY = "__default", i.Cache.DEFAULT_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==", i.Cache.MISSING = null, i.Cache.MISSING_KEY = "__missing", i.Cache.MISSING_SRC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==", i.Cache.READY_TIMEOUT = 1e3, i.Cache.prototype = {
                    addCompressedTextureMetaData: function(t, e, s, n) {
                        this.checkImageKey(t) && this.removeImage(t);
                        var r = s in i.LoaderParser ? i.LoaderParser[s](n) : n,
                            o = {
                                key: t,
                                url: e,
                                data: r,
                                base: new PIXI.BaseTexture(r, null, this.game.resolution),
                                frame: new i.Frame(0, 0, 0, r.width, r.height, t),
                                frameData: new i.FrameData,
                                fileFormat: s
                            };
                        return o.frameData.addFrame(new i.Frame(0, 0, 0, r.width, r.height, e)), this._cache.image[t] = o, this._resolveURL(e, o), o
                    },
                    addCanvas: function(t, e, i) {
                        void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                            canvas: e,
                            context: i
                        }
                    },
                    addImage: function(t, e, s) {
                        this.checkImageKey(t) && this.removeImage(t), !1 === s.complete && console.warn('Phaser.Cache.addImage: Image "' + t + "\" hasn't been retrieved yet");
                        var n = {
                            key: t,
                            url: e,
                            data: s,
                            base: new PIXI.BaseTexture(s, null, this.game.resolution),
                            frame: new i.Frame(0, 0, 0, s.width, s.height, t),
                            frameData: new i.FrameData
                        };
                        return n.frameData.addFrame(new i.Frame(0, 0, 0, s.width, s.height, e)), this._cache.image[t] = n, this._resolveURL(e, n), "__default" === t ? i.Cache.DEFAULT = new PIXI.Texture(n.base) : "__missing" === t && (i.Cache.MISSING = new PIXI.Texture(n.base)), n
                    },
                    addImageAsync: function(t, e, i) {
                        var s = this,
                            n = new Image; n.crossOrigin="anonymous";
                        n.onload = function() {
                            i.call(this, s.addImage(t, null, n)), s._removePending(), n.onload = null
                        }, this._addPending(), n.src = e
                    },
                    addDefaultImage: function() {
                        this.addImageAsync(i.Cache.DEFAULT_KEY, i.Cache.DEFAULT_SRC, function(t) {
                            t.base.skipRender = !0, i.Cache.DEFAULT = new PIXI.Texture(t.base)
                        })
                    },
                    addMissingImage: function() {
                        this.addImageAsync(i.Cache.MISSING_KEY, i.Cache.MISSING_SRC, function(t) {
                            i.Cache.MISSING = new PIXI.Texture(t.base)
                        })
                    },
                    addSound: function(t, e, i, s, n) {
                        void 0 === s && (s = !0, n = !1), void 0 === n && (s = !1, n = !0);
                        var r = !1;
                        n && (r = !0), this._cache.sound[t] = {
                            url: e,
                            data: i,
                            isDecoding: !1,
                            decoded: r,
                            webAudio: s,
                            audioTag: n,
                            locked: this.game.sound.touchLocked
                        }, this._resolveURL(e, this._cache.sound[t])
                    },
                    addText: function(t, e, i) {
                        this._cache.text[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.text[t])
                    },
                    addPhysicsData: function(t, e, i, s) {
                        this._cache.physics[t] = {
                            url: e,
                            data: i,
                            format: s
                        }, this._resolveURL(e, this._cache.physics[t])
                    },
                    addTilemap: function(t, e, i, s) {
                        this._cache.tilemap[t] = {
                            url: e,
                            data: i,
                            format: s
                        }, this._resolveURL(e, this._cache.tilemap[t])
                    },
                    addBinary: function(t, e) {
                        this._cache.binary[t] = e
                    },
                    addBitmapData: function(t, e, s) {
                        return e.key = t, void 0 === s && (s = new i.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = {
                            data: e,
                            frameData: s
                        }, e
                    },
                    addBitmapFont: function(t, e, s, n, r, o, a) {
                        var h = {
                            url: e,
                            data: s,
                            font: null,
                            base: new PIXI.BaseTexture(s, null, this.game.resolution)
                        };
                        void 0 === o && (o = 0), void 0 === a && (a = 0), h.font = "json" === r ? i.LoaderParser.jsonBitmapFont(n, h.base, o, a, !1, this.game.resolution) : i.LoaderParser.xmlBitmapFont(n, h.base, o, a, !1, this.game.resolution), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
                    },
                    addBitmapFontFromAtlas: function(t, e, s, n, r, o, a) {
                        var h = this.getFrameByName(e, s);
                        if (h) {
                            var u = {
                                font: null,
                                base: this.getBaseTexture(e),
                                frame: h
                            };
                            void 0 === o && (o = 0), void 0 === a && (a = 0);
                            var l;
                            "json" === r ? (l = this.getJSON(n), u.font = i.LoaderParser.jsonBitmapFont(l, u.base, o, a, h, this.game.resolution)) : (l = this.getXML(n), u.font = i.LoaderParser.xmlBitmapFont(l, u.base, o, a, h, this.game.resolution)), this._cache.bitmapFont[t] = u
                        }
                    },
                    addJSON: function(t, e, i) {
                        this._cache.json[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.json[t])
                    },
                    addXML: function(t, e, i) {
                        this._cache.xml[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.xml[t])
                    },
                    addVideo: function(t, e, i, s) {
                        this._cache.video[t] = {
                            url: e,
                            data: i,
                            isBlob: s,
                            locked: !0
                        }, this._resolveURL(e, this._cache.video[t])
                    },
                    addShader: function(t, e, i) {
                        this._cache.shader[t] = {
                            url: e,
                            data: i
                        }, this._resolveURL(e, this._cache.shader[t])
                    },
                    addRenderTexture: function(t, e) {
                        this._cache.renderTexture[t] = {
                            texture: e,
                            frame: new i.Frame(0, 0, 0, e.width, e.height, "", "")
                        }
                    },
                    addSpriteSheet: function(t, e, s, n, r, o, a, h, u) {
                        void 0 === o && (o = -1), void 0 === a && (a = 0), void 0 === h && (h = 0);
                        var l = {
                            key: t,
                            url: e,
                            data: s,
                            frameWidth: n,
                            frameHeight: r,
                            margin: a,
                            spacing: h,
                            base: new PIXI.BaseTexture(s, null, this.game.resolution),
                            frameData: i.AnimationParser.spriteSheet(this.game, s, n, r, o, a, h, u)
                        };
                        this._cache.image[t] = l, this._resolveURL(e, l)
                    },
                    addTextureAtlas: function(t, e, s, n, r) {
                        var o = {
                            key: t,
                            url: e,
                            data: s,
                            base: new PIXI.BaseTexture(s, null, this.game.resolution)
                        };
                        r === i.Loader.TEXTURE_ATLAS_XML_STARLING ? o.frameData = i.AnimationParser.XMLData(this.game, n, t) : r === i.Loader.TEXTURE_ATLAS_JSON_PYXEL ? o.frameData = i.AnimationParser.JSONDataPyxel(this.game, n, t) : Array.isArray(n.frames) ? o.frameData = i.AnimationParser.JSONData(this.game, n, t) : o.frameData = i.AnimationParser.JSONDataHash(this.game, n, t), this._cache.image[t] = o, this._resolveURL(e, o)
                    },
                    reloadSound: function(t) {
                        var e = this,
                            i = this.getSound(t);
                        i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                            return e.reloadSoundComplete(t)
                        }, !1), i.data.load())
                    },
                    reloadSoundComplete: function(t) {
                        var e = this.getSound(t);
                        e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
                    },
                    updateSound: function(t, e, i) {
                        var s = this.getSound(t);
                        s && (s[e] = i)
                    },
                    decodedSound: function(t, e) {
                        var i = this.getSound(t);
                        i.data = e, i.decoded = !0, i.isDecoding = !1
                    },
                    isSoundDecoded: function(t) {
                        var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                        if (e) return e.decoded
                    },
                    isSoundReady: function(t) {
                        var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded");
                        if (e) return e.decoded && !this.game.sound.touchLocked
                    },
                    checkKey: function(t, e) {
                        return !!this._cacheMap[t][e]
                    },
                    checkURL: function(t) {
                        return !!this._urlMap[this._resolveURL(t)]
                    },
                    checkCanvasKey: function(t) {
                        return this.checkKey(i.Cache.CANVAS, t)
                    },
                    checkImageKey: function(t) {
                        return this.checkKey(i.Cache.IMAGE, t)
                    },
                    checkTextureKey: function(t) {
                        return this.checkKey(i.Cache.TEXTURE, t)
                    },
                    checkSoundKey: function(t) {
                        return this.checkKey(i.Cache.SOUND, t)
                    },
                    checkTextKey: function(t) {
                        return this.checkKey(i.Cache.TEXT, t)
                    },
                    checkPhysicsKey: function(t) {
                        return this.checkKey(i.Cache.PHYSICS, t)
                    },
                    checkTilemapKey: function(t) {
                        return this.checkKey(i.Cache.TILEMAP, t)
                    },
                    checkBinaryKey: function(t) {
                        return this.checkKey(i.Cache.BINARY, t)
                    },
                    checkBitmapDataKey: function(t) {
                        return this.checkKey(i.Cache.BITMAPDATA, t)
                    },
                    checkBitmapFontKey: function(t) {
                        return this.checkKey(i.Cache.BITMAPFONT, t)
                    },
                    checkJSONKey: function(t) {
                        return this.checkKey(i.Cache.JSON, t)
                    },
                    checkXMLKey: function(t) {
                        return this.checkKey(i.Cache.XML, t)
                    },
                    checkVideoKey: function(t) {
                        return this.checkKey(i.Cache.VIDEO, t)
                    },
                    checkShaderKey: function(t) {
                        return this.checkKey(i.Cache.SHADER, t)
                    },
                    checkRenderTextureKey: function(t) {
                        return this.checkKey(i.Cache.RENDER_TEXTURE, t)
                    },
                    getItem: function(t, e, i, s) {
                        return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : (i && console.warn("Phaser.Cache." + i + ': Key "' + t + '" not found in Cache.'), null)
                    },
                    getCanvas: function(t) {
                        return this.getItem(t, i.Cache.CANVAS, "getCanvas", "canvas")
                    },
                    getImage: function(t, e) {
                        void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                        var s = this.getItem(t, i.Cache.IMAGE, "getImage");
                        return null === s && (s = this.getItem("__missing", i.Cache.IMAGE, "getImage")), e ? s : s.data
                    },
                    getTextureFrame: function(t) {
                        return this.getItem(t, i.Cache.TEXTURE, "getTextureFrame", "frame")
                    },
                    getSound: function(t) {
                        return this.getItem(t, i.Cache.SOUND, "getSound")
                    },
                    getSoundData: function(t) {
                        return this.getItem(t, i.Cache.SOUND, "getSoundData", "data")
                    },
                    getText: function(t) {
                        return this.getItem(t, i.Cache.TEXT, "getText", "data")
                    },
                    getPhysicsData: function(t, e, s) {
                        var n = this.getItem(t, i.Cache.PHYSICS, "getPhysicsData", "data");
                        if (null === n || void 0 === e || null === e) return n;
                        if (n[e]) {
                            var r = n[e];
                            if (!r || !s) return r;
                            for (var o in r)
                                if ((o = r[o]).fixtureKey === s) return o;
                            console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: "' + s + " in " + t + '"')
                        } else console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: "' + t + " / " + e + '"');
                        return null
                    },
                    getTilemapData: function(t) {
                        return this.getItem(t, i.Cache.TILEMAP, "getTilemapData")
                    },
                    getBinary: function(t) {
                        return this.getItem(t, i.Cache.BINARY, "getBinary")
                    },
                    getBitmapData: function(t) {
                        return this.getItem(t, i.Cache.BITMAPDATA, "getBitmapData", "data")
                    },
                    getBitmapFont: function(t) {
                        return this.getItem(t, i.Cache.BITMAPFONT, "getBitmapFont")
                    },
                    getJSON: function(t, e) {
                        var s = this.getItem(t, i.Cache.JSON, "getJSON", "data");
                        return s ? e ? i.Utils.extend(!0, Array.isArray(s) ? [] : {}, s) : s : null
                    },
                    getXML: function(t) {
                        return this.getItem(t, i.Cache.XML, "getXML", "data")
                    },
                    getVideo: function(t) {
                        return this.getItem(t, i.Cache.VIDEO, "getVideo")
                    },
                    getShader: function(t) {
                        return this.getItem(t, i.Cache.SHADER, "getShader", "data")
                    },
                    getRenderTexture: function(t) {
                        return this.getItem(t, i.Cache.RENDER_TEXTURE, "getRenderTexture")
                    },
                    getBaseTexture: function(t, e) {
                        return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
                    },
                    getFrame: function(t, e) {
                        return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
                    },
                    getFrameCount: function(t, e) {
                        var i = this.getFrameData(t, e);
                        return i ? i.total : 0
                    },
                    getFrameData: function(t, e) {
                        return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
                    },
                    hasFrameData: function(t, e) {
                        return void 0 === e && (e = i.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
                    },
                    updateFrameData: function(t, e, s) {
                        void 0 === s && (s = i.Cache.IMAGE), this._cacheMap[s][t] && (this._cacheMap[s][t].frameData = e)
                    },
                    getFrameByIndex: function(t, e, i) {
                        var s = this.getFrameData(t, i);
                        return s ? s.getFrame(e) : null
                    },
                    getFrameByName: function(t, e, i) {
                        var s = this.getFrameData(t, i);
                        return s ? s.getFrameByName(e) : null
                    },
                    getURL: function(t) {
                        return (t = this._resolveURL(t)) ? this._urlMap[t] : (console.warn('Phaser.Cache.getUrl: Invalid url: "' + t + '" or Cache.autoResolveURL was false'), null)
                    },
                    getKeys: function(t) {
                        void 0 === t && (t = i.Cache.IMAGE);
                        var e = [];
                        if (this._cacheMap[t])
                            for (var s in this._cacheMap[t]) "__default" !== s && "__missing" !== s && e.push(s);
                        return e
                    },
                    removeCanvas: function(t) {
                        delete this._cache.canvas[t]
                    },
                    removeImage: function(t, e) {
                        void 0 === e && (e = !0);
                        var i = this.getImage(t, !0);
                        e && i.base && i.base.destroy(), delete this._cache.image[t]
                    },
                    removeSound: function(t) {
                        delete this._cache.sound[t]
                    },
                    removeText: function(t) {
                        delete this._cache.text[t]
                    },
                    removePhysics: function(t) {
                        delete this._cache.physics[t]
                    },
                    removeTilemap: function(t) {
                        delete this._cache.tilemap[t]
                    },
                    removeBinary: function(t) {
                        delete this._cache.binary[t]
                    },
                    removeBitmapData: function(t) {
                        delete this._cache.bitmapData[t]
                    },
                    removeBitmapFont: function(t) {
                        delete this._cache.bitmapFont[t]
                    },
                    removeJSON: function(t) {
                        delete this._cache.json[t]
                    },
                    removeXML: function(t) {
                        delete this._cache.xml[t]
                    },
                    removeVideo: function(t) {
                        delete this._cache.video[t]
                    },
                    removeShader: function(t) {
                        delete this._cache.shader[t]
                    },
                    removeRenderTexture: function(t) {
                        delete this._cache.renderTexture[t]
                    },
                    removeSpriteSheet: function(t) {
                        delete this._cache.spriteSheet[t]
                    },
                    removeTextureAtlas: function(t) {
                        delete this._cache.image[t]
                    },
                    clearGLTextures: function() {
                        for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
                    },
                    _resolveURL: function(t, e) {
                        return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
                    },
                    destroy: function() {
                        for (var t = 0; t < this._cacheMap.length; t++) {
                            var e = this._cacheMap[t];
                            for (var i in e) "__default" !== i && "__missing" !== i && (this.destroyItem(e[i]), delete e[i])
                        }
                        this._urlMap = null, this._urlResolver = null, this._urlTemp = null
                    },
                    destroyItem: function(t) {
                        t.destroy ? t.destroy() : (t.base && t.base.destroy && t.base.destroy(), t.data && t.data.destroy && t.data.destroy(), t.frameData && t.frameData.destroy && t.frameData.destroy(), t.texture && t.texture.destroy && t.texture.destroy(!0))
                    },
                    _addImages: function() {
                        this._pendingCount = 0, this.addDefaultImage(), this.addMissingImage();
                        var t = this,
                            e = i.Cache.READY_TIMEOUT;
                        i.Cache.READY_TIMEOUT > 0 ? setTimeout(function() {
                            t.isReady || (console.warn("Phaser.Cache: Still waiting for images after %s ms.", e), t._ready())
                        }, i.Cache.READY_TIMEOUT) : this._ready()
                    },
                    _addPending: function() {
                        this._pendingCount += 1
                    },
                    _removePending: function() {
                        this._pendingCount -= 1, this._checkReady()
                    },
                    _checkReady: function() {
                        this.isReady && this._ready()
                    },
                    _ready: function() {
                        this._pendingCount = 0, this.onReady.dispatch(this)
                    }
                }, i.Cache.prototype.constructor = i.Cache, Object.defineProperty(i.Cache.prototype, "isReady", {
                    get: function() {
                        return this._pendingCount <= 0
                    }
                }), i.Loader = function(t) {
                    this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                        requestedWith: !1,
                        json: "application/json",
                        xml: "application/xml"
                    }, this.onLoadStart = new i.Signal, this.onLoadComplete = new i.Signal, this.onPackComplete = new i.Signal, this.onFileStart = new i.Signal, this.onFileComplete = new i.Signal, this.onFileError = new i.Signal, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
                }, i.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, i.Loader.TEXTURE_ATLAS_JSON_HASH = 1, i.Loader.TEXTURE_ATLAS_XML_STARLING = 2, i.Loader.PHYSICS_LIME_CORONA_JSON = 3, i.Loader.PHYSICS_PHASER_JSON = 4, i.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, i.Loader.prototype = {
                    setPreloadSprite: function(t, e) {
                        e = e || 0, this.preloadSprite = {
                            sprite: t,
                            direction: e,
                            width: t.width,
                            height: t.height,
                            rect: null
                        }, this.preloadSprite.rect = 0 === e ? new i.Rectangle(0, 0, 1, t.height) : new i.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
                    },
                    resize: function() {
                        this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
                    },
                    checkKeyExists: function(t, e) {
                        return this.getAssetIndex(t, e) > -1
                    },
                    getAssetIndex: function(t, e) {
                        for (var i = -1, s = 0; s < this._fileList.length; s++) {
                            var n = this._fileList[s];
                            if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
                        }
                        return i
                    },
                    getAsset: function(t, e) {
                        var i = this.getAssetIndex(t, e);
                        return i > -1 && {
                            index: i,
                            file: this._fileList[i]
                        }
                    },
                    reset: function(t, e) {
                        void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
                    },
                    addToFileList: function(t, e, i, s, n, r) {
                        if (void 0 === n && (n = !1), void 0 === e || "" === e) return console.warn("Phaser.Loader: Invalid or no key given of type " + t), this;
                        if (void 0 === i || null === i) {
                            if (!r) return console.warn("Phaser.Loader: No URL given for file type: " + t + " key: " + e), this;
                            i = e + r
                        }
                        var o = {
                            type: t,
                            key: e,
                            path: this.path,
                            url: i,
                            syncPoint: this._withSyncPointDepth > 0,
                            data: null,
                            loading: !1,
                            loaded: !1,
                            error: !1
                        };
                        if (s)
                            for (var a in s) o[a] = s[a];
                        var h = this.getAssetIndex(t, e);
                        if (n && h > -1) {
                            var u = this._fileList[h];
                            u.loading || u.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
                        } else -1 === h && (this._fileList.push(o), this._totalFileCount++);
                        return this
                    },
                    replaceInFileList: function(t, e, i, s) {
                        return this.addToFileList(t, e, i, s, !0)
                    },
                    pack: function(t, e, i, s) {
                        if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return console.warn("Phaser.Loader.pack - Both url and data are null. One must be set."), this;
                        var n = {
                            type: "packfile",
                            key: t,
                            url: e,
                            path: this.path,
                            syncPoint: !0,
                            data: null,
                            loading: !1,
                            loaded: !1,
                            error: !1,
                            callbackContext: s
                        };
                        i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
                        for (var r = 0; r < this._fileList.length + 1; r++) {
                            var o = this._fileList[r];
                            if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                                this._fileList.splice(r, 0, n), this._totalPackCount++;
                                break
                            }
                        }
                        return this
                    },
                    image: function(t, e, i) {
                        return "object" == typeof e ? this.texture(t, e, i) : this.addToFileList("image", t, e, void 0, i, ".png")
                    },
                    imageFromBitmapData: function(t, e, i) {
                        return this.image(t, e.canvas.toDataURL("image/png"), i)
                    },
                    imageFromGrid: function(t, e, i, s, n, r) {
                        return this.imageFromBitmapData(t, this.game.create.grid(t, e, i, s, n, r, !1))
                    },
                    imageFromTexture: function(t, e, i, s, n) {
                        return this.imageFromBitmapData(t, this.game.create.texture(t, e, i, s, n, !1))
                    },
                    texture: function(t, e, s) {
                        if (this.game.renderType === i.WEBGL) {
                            var n, r = this.game.renderer.extensions.compression;
                            for (n in e)
                                if (n.toUpperCase() in r) return this.addToFileList("texture", t, e[n], void 0, s, ".pvr")
                        }
                        return e.truecolor && this.addToFileList("image", t, e.truecolor, void 0, s, ".png"), this
                    },
                    images: function(t, e) {
                        if (Array.isArray(e))
                            for (i = 0; i < t.length; i++) this.image(t[i], e[i]);
                        else
                            for (var i = 0; i < t.length; i++) this.image(t[i]);
                        return this
                    },
                    text: function(t, e, i) {
                        return this.addToFileList("text", t, e, void 0, i, ".txt")
                    },
                    json: function(t, e, i) {
                        return this.addToFileList("json", t, e, void 0, i, ".json")
                    },
                    shader: function(t, e, i) {
                        return this.addToFileList("shader", t, e, void 0, i, ".frag")
                    },
                    xml: function(t, e, i) {
                        return this.addToFileList("xml", t, e, void 0, i, ".xml")
                    },
                    script: function(t, e, i, s) {
                        return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                            syncPoint: !0,
                            callback: i,
                            callbackContext: s
                        }, !1, ".js")
                    },
                    binary: function(t, e, i, s) {
                        return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                            callback: i,
                            callbackContext: s
                        }, !1, ".bin")
                    },
                    spritesheet: function(t, e, i, s, n, r, o, a) {
                        return void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), this.addToFileList("spritesheet", t, e, {
                            frameWidth: i,
                            frameHeight: s,
                            frameMax: n,
                            margin: r,
                            spacing: o,
                            skipFrames: a
                        }, !1, ".png")
                    },
                    audio: function(t, e, i) {
                        return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                            buffer: null,
                            autoDecode: i
                        }))
                    },
                    audioSprite: function(t, e, i, s, n) {
                        return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)) : console.warn("Phaser.Loader.audiosprite - You must specify either a jsonURL or provide a jsonData object"), this)
                    },
                    audiosprite: function(t, e, i, s, n) {
                        return this.audioSprite(t, e, i, s, n)
                    },
                    video: function(t, e, i, s) {
                        return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                            buffer: null,
                            asBlob: s,
                            loadEvent: i
                        })
                    },
                    tilemap: function(t, e, s, n) {
                        if (void 0 === e && (e = null), void 0 === s && (s = null), void 0 === n && (n = i.Tilemap.CSV), e || s || (e = n === i.Tilemap.CSV ? t + ".csv" : t + ".json"), s) {
                            switch (n) {
                                case i.Tilemap.CSV:
                                    break;
                                case i.Tilemap.TILED_JSON:
                                    "string" == typeof s && (s = JSON.parse(s))
                            }
                            this.cache.addTilemap(t, null, s, n)
                        } else this.addToFileList("tilemap", t, e, {
                            format: n
                        });
                        return this
                    },
                    physics: function(t, e, s, n) {
                        return void 0 === e && (e = null), void 0 === s && (s = null), void 0 === n && (n = i.Physics.LIME_CORONA_JSON), e || s || (e = t + ".json"), s ? ("string" == typeof s && (s = JSON.parse(s)), this.cache.addPhysicsData(t, null, s, n)) : this.addToFileList("physics", t, e, {
                            format: n
                        }), this
                    },
                    bitmapFont: function(t, e, i, s, n, r) {
                        if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === r && (r = 0), i) this.addToFileList("bitmapfont", t, e, {
                            atlasURL: i,
                            xSpacing: n,
                            ySpacing: r
                        });
                        else if ("string" == typeof s) {
                            var o, a;
                            try {
                                o = JSON.parse(s)
                            } catch (t) {
                                a = this.parseXml(s)
                            }
                            if (!a && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                            this.addToFileList("bitmapfont", t, e, {
                                atlasURL: null,
                                atlasData: o || a,
                                atlasType: o ? "json" : "xml",
                                xSpacing: n,
                                ySpacing: r
                            })
                        }
                        return this
                    },
                    atlasJSONArray: function(t, e, s, n) {
                        return this.atlas(t, e, s, n, i.Loader.TEXTURE_ATLAS_JSON_ARRAY)
                    },
                    atlasJSONHash: function(t, e, s, n) {
                        return this.atlas(t, e, s, n, i.Loader.TEXTURE_ATLAS_JSON_HASH)
                    },
                    atlasXML: function(t, e, s, n) {
                        return void 0 === s && (s = null), void 0 === n && (n = null), s || n || (s = t + ".xml"), this.atlas(t, e, s, n, i.Loader.TEXTURE_ATLAS_XML_STARLING)
                    },
                    atlas: function(t, e, s, n, r) {
                        if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === s && (s = null), void 0 === n && (n = null), void 0 === r && (r = i.Loader.TEXTURE_ATLAS_JSON_ARRAY), s || n || (s = r === i.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), s) this.addToFileList("textureatlas", t, e, {
                            atlasURL: s,
                            format: r
                        });
                        else {
                            switch (r) {
                                case i.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                    "string" == typeof n && (n = JSON.parse(n));
                                    break;
                                case i.Loader.TEXTURE_ATLAS_XML_STARLING:
                                    if ("string" == typeof n) {
                                        var o = this.parseXml(n);
                                        if (!o) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                        n = o
                                    }
                            }
                            this.addToFileList("textureatlas", t, e, {
                                atlasURL: null,
                                atlasData: n,
                                format: r
                            })
                        }
                        return this
                    },
                    withSyncPoint: function(t, e) {
                        this._withSyncPointDepth++;
                        try {
                            t.call(e || this, this)
                        } finally {
                            this._withSyncPointDepth--
                        }
                        return this
                    },
                    addSyncPoint: function(t, e) {
                        var i = this.getAsset(t, e);
                        return i && (i.file.syncPoint = !0), this
                    },
                    removeFile: function(t, e) {
                        var i = this.getAsset(t, e);
                        i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
                    },
                    removeAll: function() {
                        this._fileList.length = 0, this._flightQueue.length = 0
                    },
                    start: function() {
                        this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
                    },
                    processLoadQueue: function() {
                        if (!this.isLoading) return console.warn("Phaser.Loader - active loading canceled / reset"), void this.finishedLoading(!0);
                        for (i = 0; i < this._flightQueue.length; i++)((s = this._flightQueue[i]).loaded || s.error) && (this._flightQueue.splice(i, 1), i--, s.loading = !1, s.requestUrl = null, s.requestObject = null, s.error && this.onFileError.dispatch(s.key, s), "packfile" !== s.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, s.key, !s.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === s.type && s.error && (this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)));
                        for (var t = !1, e = this.enableParallel ? Math.max(1, this.maxParallelDownloads) : 1, i = this._processingHead; i < this._fileList.length; i++) {
                            var s = this._fileList[i];
                            if ("packfile" === s.type && !s.error && s.loaded && i === this._processingHead && (this.processPack(s), this._loadedPackCount++, this.onPackComplete.dispatch(s.key, !s.error, this._loadedPackCount, this._totalPackCount)), s.loaded || s.error ? i === this._processingHead && (this._processingHead = i + 1) : !s.loading && this._flightQueue.length < e && ("packfile" !== s.type || s.data ? t || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(s), s.loading = !0, this.onFileStart.dispatch(this.progress, s.key, s.url), this.loadFile(s)) : (this._flightQueue.push(s), s.loading = !0, this.loadFile(s))), !s.loaded && s.syncPoint && (t = !0), this._flightQueue.length >= e || t && this._loadedPackCount === this._totalPackCount) break
                        }
                        if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                        else if (!this._flightQueue.length) {
                            console.warn("Phaser.Loader - aborting: processing queue empty, loading may have stalled");
                            var n = this;
                            setTimeout(function() {
                                n.finishedLoading(!0)
                            }, 2e3)
                        }
                    },
                    finishedLoading: function(t) {
                        this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.reset(), this.onLoadComplete.dispatch(), this.game.state && this.game.state.loadComplete())
                    },
                    asyncComplete: function(t, e) {
                        void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e, console.warn("Phaser.Loader - " + t.type + "[" + t.key + "]: " + e)), this.processLoadQueue()
                    },
                    processPack: function(t) {
                        var e = t.data[t.key];
                        if (e)
                            for (var s = 0; s < e.length; s++) {
                                var n = e[s];
                                switch (n.type) {
                                    case "image":
                                        this.image(n.key, n.url, n.overwrite);
                                        break;
                                    case "text":
                                        this.text(n.key, n.url, n.overwrite);
                                        break;
                                    case "json":
                                        this.json(n.key, n.url, n.overwrite);
                                        break;
                                    case "xml":
                                        this.xml(n.key, n.url, n.overwrite);
                                        break;
                                    case "script":
                                        this.script(n.key, n.url, n.callback, t.callbackContext || this);
                                        break;
                                    case "binary":
                                        this.binary(n.key, n.url, n.callback, t.callbackContext || this);
                                        break;
                                    case "spritesheet":
                                        this.spritesheet(n.key, n.url, n.frameWidth, n.frameHeight, n.frameMax, n.margin, n.spacing, n.skipFrames);
                                        break;
                                    case "video":
                                        this.video(n.key, n.urls);
                                        break;
                                    case "audio":
                                        this.audio(n.key, n.urls, n.autoDecode);
                                        break;
                                    case "audiosprite":
                                        this.audiosprite(n.key, n.urls, n.jsonURL, n.jsonData, n.autoDecode);
                                        break;
                                    case "tilemap":
                                        this.tilemap(n.key, n.url, n.data, i.Tilemap[n.format]);
                                        break;
                                    case "physics":
                                        this.physics(n.key, n.url, n.data, i.Loader[n.format]);
                                        break;
                                    case "bitmapFont":
                                        this.bitmapFont(n.key, n.textureURL, n.atlasURL, n.atlasData, n.xSpacing, n.ySpacing);
                                        break;
                                    case "atlasJSONArray":
                                        this.atlasJSONArray(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                        break;
                                    case "atlasJSONHash":
                                        this.atlasJSONHash(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                        break;
                                    case "atlasXML":
                                        this.atlasXML(n.key, n.textureURL, n.atlasURL, n.atlasData);
                                        break;
                                    case "atlas":
                                        this.atlas(n.key, n.textureURL, n.atlasURL, n.atlasData, i.Loader[n.format]);
                                        break;
                                    case "shader":
                                        this.shader(n.key, n.url, n.overwrite)
                                }
                            } else console.warn("Phaser.Loader - " + t.key + ": pack has data, but not for pack key")
                    },
                    transformUrl: function(t, e) {
                        return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
                    },
                    loadFile: function(t) {
                        switch (t.type) {
                            case "packfile":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                                break;
                            case "image":
                            case "spritesheet":
                            case "textureatlas":
                            case "bitmapfont":
                                this.loadImageTag(t);
                                break;
                            case "audio":
                                t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                                break;
                            case "video":
                                t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                                break;
                            case "json":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                                break;
                            case "xml":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                                break;
                            case "tilemap":
                                t.format === i.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === i.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                                break;
                            case "text":
                            case "script":
                            case "shader":
                            case "physics":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                                break;
                            case "texture":
                                "truecolor" === t.key.split("_").pop() ? this.loadImageTag(t) : this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete);
                                break;
                            case "binary":
                                this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                        }
                    },
                    loadImageTag: function(t) {
                        var e = this;
                        t.data = new Image, e.crossOrigin="Anonymous"; t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                            t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                        }, t.data.onerror = function() {
                            t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                        }, t.data.src = this.transformUrl(t.url, t), !this.game.device.firefox && t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
                    },
                    loadVideoTag: function(t) {
                        var e = this;
                        t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                        var s = function() {
                            t.data.removeEventListener(t.loadEvent, s, !1), t.data.onerror = null, t.data.canplay = !0, i.GAMES[e.game.id].load.fileComplete(t)
                        };
                        t.data.onerror = function() {
                            t.data.removeEventListener(t.loadEvent, s, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                        }, t.data.addEventListener(t.loadEvent, s, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
                    },
                    loadAudioTag: function(t) {
                        var e = this;
                        if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                        else {
                            t.data = new Audio, t.data.name = t.key;
                            var i = function() {
                                t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                            };
                            t.data.onerror = function() {
                                t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                            }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                        }
                    },
                    xhrLoad: function(t, e, i, s, n) {
                        var r = new XMLHttpRequest;
                        r.open("GET", e, !0), r.responseType = i, !1 !== this.headers.requestedWith && r.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && r.setRequestHeader("Accept", this.headers[t.type]), n = n || this.fileError;
                        var o = this;
                        r.onload = function() {
                            try {
                                return 4 === r.readyState && r.status >= 400 && r.status <= 599 ? n.call(o, t, r) : s.call(o, t, r)
                            } catch (e) {
                                o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                            }
                        }, r.onerror = function() {
                            try {
                                return n.call(o, t, r)
                            } catch (e) {
                                o.hasLoaded ? window.console && console.error(e) : o.asyncComplete(t, e.message || "Exception")
                            }
                        }, t.requestObject = r, t.requestUrl = e, r.send()
                    },
                    getVideoURL: function(t) {
                        for (var e = 0; e < t.length; e++) {
                            var i, s = t[e];
                            if (s.uri) {
                                if (i = s.type, s = s.uri, this.game.device.canPlayVideo(i)) return s
                            } else {
                                if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                                if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e]
                            }
                        }
                        return null
                    },
                    getAudioURL: function(t) {
                        if (this.game.sound.noAudio) return null;
                        for (var e = 0; e < t.length; e++) {
                            var i, s = t[e];
                            if (s.uri) {
                                if (i = s.type, s = s.uri, this.game.device.canPlayAudio(i)) return s
                            } else {
                                if (0 === s.indexOf("blob:") || 0 === s.indexOf("data:")) return s;
                                if (s.indexOf("?") >= 0 && (s = s.substr(0, s.indexOf("?"))), i = s.substr((Math.max(0, s.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e]
                            }
                        }
                        return null
                    },
                    fileError: function(t, e, i) {
                        var s = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));
                        !i && e && (i = e.status), i && (s = s + " (" + i + ")"), this.asyncComplete(t, s)
                    },
                    fileComplete: function(t, e) {
                        var s = !0;
                        switch (t.type) {
                            case "packfile":
                                r = JSON.parse(e.responseText);
                                t.data = r || {};
                                break;
                            case "texture":
                                var n = /\.([^.]+)$/.exec(t.url.split("?", 1)[0])[1].toLowerCase();
                                null !== t.data ? this.cache.addCompressedTextureMetaData(t.key, t.url, n, t.data) : this.cache.addCompressedTextureMetaData(t.key, t.url, n, e.response);
                                break;
                            case "image":
                                this.cache.addImage(t.key, t.url, t.data);
                                break;
                            case "spritesheet":
                                this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing, t.skipFrames);
                                break;
                            case "textureatlas":
                                if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                                else if (s = !1, t.format === i.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === i.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === i.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                                else {
                                    if (t.format !== i.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                                    this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                                }
                                break;
                            case "bitmapfont":
                                t.atlasURL ? (s = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                                    var i;
                                    try {
                                        i = JSON.parse(e.responseText)
                                    } catch (t) {}
                                    i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                                })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                                break;
                            case "video":
                                if (t.asBlob) try {
                                    t.data = e.response
                                } catch (e) {
                                    throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                                }
                                this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                                break;
                            case "audio":
                                this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                                break;
                            case "text":
                                t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                                break;
                            case "shader":
                                t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                                break;
                            case "physics":
                                var r = JSON.parse(e.responseText);
                                this.cache.addPhysicsData(t.key, t.url, r, t.format);
                                break;
                            case "script":
                                t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                                break;
                            case "binary":
                                t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                        }
                        s && this.asyncComplete(t)
                    },
                    jsonLoadComplete: function(t, e) {
                        var i = JSON.parse(e.responseText);
                        "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
                    },
                    csvLoadComplete: function(t, e) {
                        var i = e.responseText;
                        this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
                    },
                    xmlLoadComplete: function(t, e) {
                        var i = e.responseText,
                            s = this.parseXml(i);
                        if (!s) {
                            var n = e.responseType || e.contentType;
                            return console.warn("Phaser.Loader - " + t.key + ": invalid XML (" + n + ")"), void this.asyncComplete(t, "invalid XML")
                        }
                        "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
                    },
                    parseXml: function(t) {
                        var e;
                        try {
                            if (window.DOMParser) {
                                var i = new DOMParser;
                                e = i.parseFromString(t, "text/xml")
                            } else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t)
                        } catch (t) {
                            e = null
                        }
                        return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null
                    },
                    updateProgress: function() {
                        this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
                    },
                    totalLoadedFiles: function() {
                        return this._loadedFileCount
                    },
                    totalQueuedFiles: function() {
                        return this._totalFileCount - this._loadedFileCount
                    },
                    totalLoadedPacks: function() {
                        return this._totalPackCount
                    },
                    totalQueuedPacks: function() {
                        return this._totalPackCount - this._loadedPackCount
                    }
                }, Object.defineProperty(i.Loader.prototype, "progressFloat", {
                    get: function() {
                        var t = this._loadedFileCount / this._totalFileCount * 100;
                        return i.Math.clamp(t || 0, 0, 100)
                    }
                }), Object.defineProperty(i.Loader.prototype, "progress", {
                    get: function() {
                        return Math.round(this.progressFloat)
                    }
                }), i.Loader.prototype.constructor = i.Loader, i.LoaderParser = {
                    bitmapFont: function(t, e, i, s, n, r) {
                        return this.xmlBitmapFont(t, e, i, s, n, r)
                    },
                    xmlBitmapFont: function(t, e, i, s, n, r) {
                        null == r && (r = 1);
                        var o = {},
                            a = t.getElementsByTagName("info")[0],
                            h = t.getElementsByTagName("common")[0];
                        o.font = a.getAttribute("face"), o.size = parseInt(a.getAttribute("size"), 10), o.lineHeight = parseInt(h.getAttribute("lineHeight"), 10) + s, o.chars = {};
                        for (var u = t.getElementsByTagName("char"), l = n ? n.x : 0, c = n ? n.y : 0, d = 0; d < u.length; d++) {
                            var p = parseInt(u[d].getAttribute("id"), 10);
                            o.chars[p] = {
                                x: l + parseInt(u[d].getAttribute("x"), 10),
                                y: c + parseInt(u[d].getAttribute("y"), 10),
                                width: parseInt(u[d].getAttribute("width"), 10),
                                height: parseInt(u[d].getAttribute("height"), 10),
                                xOffset: parseInt(u[d].getAttribute("xoffset"), 10) / r,
                                yOffset: parseInt(u[d].getAttribute("yoffset"), 10) / r,
                                xAdvance: (parseInt(u[d].getAttribute("xadvance"), 10) + i) / r,
                                kerning: {}
                            }
                        }
                        var f = t.getElementsByTagName("kerning");
                        for (d = 0; d < f.length; d++) {
                            var g = parseInt(f[d].getAttribute("first"), 10),
                                m = parseInt(f[d].getAttribute("second"), 10),
                                y = parseInt(f[d].getAttribute("amount"), 10) / r;
                            o.chars[m].kerning[g] = y
                        }
                        return this.finalizeBitmapFont(e, o)
                    },
                    jsonBitmapFont: function(t, e, i, s, n, r) {
                        null == r && (r = 1);
                        var o = {
                                font: t.font.info._face,
                                size: parseInt(t.font.info._size, 10),
                                lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                                chars: {}
                            },
                            a = n ? n.x : 0,
                            h = n ? n.y : 0;
                        return t.font.chars.char.forEach(function(t) {
                            var e = parseInt(t._id, 10);
                            o.chars[e] = {
                                x: a + parseInt(t._x, 10),
                                y: h + parseInt(t._y, 10),
                                width: parseInt(t._width, 10),
                                height: parseInt(t._height, 10),
                                xOffset: parseInt(t._xoffset, 10) / r,
                                yOffset: parseInt(t._yoffset, 10) / r,
                                xAdvance: (parseInt(t._xadvance, 10) + i) / r,
                                kerning: {}
                            }
                        }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) {
                            o.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) / r
                        }), this.finalizeBitmapFont(e, o)
                    },
                    finalizeBitmapFont: function(t, e) {
                        return Object.keys(e.chars).forEach(function(s) {
                            var n = e.chars[s];
                            n.texture = new PIXI.Texture(t, new i.Rectangle(n.x, n.y, n.width, n.height))
                        }), e
                    },
                    pvr: function(t) {
                        var e, i = new Uint32Array(t.slice(0, 52)),
                            s = new Uint8Array(t),
                            n = null,
                            r = i[3] << 32 | i[2],
                            o = 0;
                        if (55727696 === i[0] && [0, 1, 2, 3, 6, 7, 9, 11].indexOf(r) >= 0) {
                            switch (r >= 0 && r <= 3 ? e = "PVRTC" : r >= 7 && r <= 11 ? e = "S3TC" : 6 === r && (e = "ETC1"), r) {
                                case 0:
                                    o = 35841;
                                    break;
                                case 1:
                                    o = 35843;
                                    break;
                                case 2:
                                    o = 35840;
                                    break;
                                case 3:
                                    o = 35842;
                                    break;
                                case 6:
                                    o = 36196;
                                    break;
                                case 7:
                                    o = 33777;
                                    break;
                                case 9:
                                    o = 33778;
                                    break;
                                case 11:
                                    o = 33779;
                                    break;
                                default:
                                    o = -1
                            }
                            n = {
                                complete: !0,
                                fileFormat: "PVR",
                                compressionAlgorithm: e,
                                flags: i[1],
                                pixelFormat: r,
                                colorSpace: i[4],
                                channelType: i[5],
                                height: i[6],
                                width: i[7],
                                depth: i[8],
                                numberOfSurfaces: i[9],
                                numberOfFaces: i[10],
                                numberOfMipmaps: i[11],
                                metaDataSize: i[12],
                                textureData: s.subarray(52 + i[12], s.byteLength),
                                glExtensionFormat: o
                            }
                        }
                        return n
                    },
                    dds: function(t) {
                        var e = new Uint8Array(t),
                            i = new Uint32Array(t),
                            s = null;
                        return 68 === e[0] && 68 === e[1] && 83 === e[2] && 32 === e[3] && "DX10" === (s = {
                            complete: !0,
                            fileFormat: "DDS",
                            compressionAlgorithm: "S3TC",
                            size: i[1],
                            flags: i[2],
                            height: i[3],
                            width: i[4],
                            pitch: i[5],
                            depth: i[6],
                            mipmapCount: i[7],
                            formatSize: i[19],
                            formatFlag: i[19],
                            formatFourCC: [String.fromCharCode(e[84]), String.fromCharCode(e[85]), String.fromCharCode(e[86]), String.fromCharCode(e[87])].join(""),
                            formatBitCount: i[21],
                            formatRBitMask: i[22],
                            formatGBitMask: i[23],
                            formatBBitMask: i[24],
                            formatABitMask: i[25],
                            caps1: i[26],
                            caps2: i[27],
                            caps3: i[28],
                            caps4: i[29],
                            reserved2: i[30],
                            DXGIFormat: null,
                            resourceDimension: null,
                            miscFlag: null,
                            arraySize: null,
                            textureData: e.subarray(i[1] + 4, e.byteLength)
                        }).formatFourCC && (s.DXGIFormat = i[31], s.resourceDimension = i[32], s.miscFlag = i[33], s.arraySize = i[34], s.miscFlag = i[35]), s
                    },
                    ktx: function(t) {
                        var e = new Uint8Array(t),
                            i = new Uint32Array(t),
                            s = null,
                            n = 16 + i[15] / 4 | 0,
                            r = i[n],
                            o = i[7],
                            a = 0;
                        if (171 === e[0] && 75 === e[1] && 84 === e[2] && 88 === e[3] && 32 === e[4] && 49 === e[5] && 49 === e[6] && 187 === e[7] && 13 === e[8] && 10 === e[9] && 26 === e[10] && 10 === e[11] && [36196, 35840, 35841, 35842, 35843, 33776, 33777, 33778, 33779].indexOf(o) >= 0) {
                            switch (o) {
                                case 36196:
                                    a = "ETC1";
                                    break;
                                case 35840:
                                case 35841:
                                case 35842:
                                case 35843:
                                    a = "PVRTC";
                                    break;
                                case 33776:
                                case 33777:
                                case 33778:
                                case 33779:
                                    a = "S3TC"
                            }
                            s = {
                                complete: !0,
                                fileFormat: "KTX",
                                compressionAlgorithm: a,
                                endianness: i[3],
                                glType: i[4],
                                glTypeSize: i[5],
                                glFormat: i[6],
                                glInternalFormat: i[7],
                                glBaseInternalFormat: i[8],
                                width: i[9],
                                height: i[10],
                                pixelDepth: i[11],
                                numberOfArrayElements: i[12],
                                numberOfFaces: i[13],
                                numberOfMipmapLevels: i[14],
                                bytesOfKeyValueData: i[15],
                                keyAndValueByteSize: i[16],
                                imageSize: r,
                                textureData: e.subarray(4 * (n + 1), r + 100)
                            }
                        }
                        return s
                    },
                    pkm: function(t) {
                        var e = new Uint8Array(t),
                            i = null;
                        return 80 === e[0] && 75 === e[1] && 77 === e[2] && 32 === e[3] && (i = {
                            complete: !0,
                            fileFormat: "PKM",
                            compressionAlgorithm: "ETC1",
                            format: 65535 & (e[6] << 8 | e[7]),
                            width: 65535 & (e[8] << 8 | e[9]),
                            height: 65535 & (e[10] << 8 | e[11]),
                            originalWidth: 65535 & (e[12] << 8 | e[13]),
                            originalHeight: 65535 & (e[14] << 8 | e[15]),
                            textureData: e.subarray(16, e.length)
                        }), i
                    }
                }, i.AudioSprite = function(t, e) {
                    this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
                    for (var i in this.config.spritemap) {
                        var s = this.config.spritemap[i],
                            n = this.game.add.sound(this.key);
                        n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
                    }
                    this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
                }, i.AudioSprite.prototype = {
                    play: function(t, e) {
                        return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
                    },
                    stop: function(t) {
                        if (t) this.sounds[t].stop();
                        else
                            for (var e in this.sounds) this.sounds[e].stop()
                    },
                    get: function(t) {
                        return this.sounds[t]
                    }
                }, i.AudioSprite.prototype.constructor = i.AudioSprite, i.Sound = function(t, e, s, n, r) {
                    void 0 === s && (s = 1), void 0 === n && (n = !1), void 0 === r && (r = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = n, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.playOnce = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this._globalVolume = 1, this._markedToDelete = !1, this._removeFromSoundManager = !1, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = s, r && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new i.Signal, this.onPlay = new i.Signal, this.onPause = new i.Signal, this.onResume = new i.Signal, this.onLoop = new i.Signal, this.onStop = new i.Signal, this.onMute = new i.Signal, this.onMarkerComplete = new i.Signal, this.onFadeComplete = new i.Signal, this._volume = s, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
                }, i.Sound.prototype = {
                    soundHasUnlocked: function(t) {
                        t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
                    },
                    addMarker: function(t, e, i, s, n) {
                        void 0 !== i && null !== i || (i = 1), void 0 !== s && null !== s || (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                            name: t,
                            start: e,
                            stop: e + i,
                            volume: s,
                            duration: i,
                            durationMS: 1e3 * i,
                            loop: n
                        }
                    },
                    removeMarker: function(t) {
                        delete this.markers[t]
                    },
                    onEndedHandler: function() {
                        this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop(), this.playOnce && (this._markedToDelete = !0, this._removeFromSoundManager = !0), this._markedToDelete && (this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode), this._removeFromSoundManager ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()))
                    },
                    update: function() {
                        this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy()
                    },
                    loopFull: function(t) {
                        return this.play(null, 0, t, !0)
                    },
                    play: function(t, e, i, s, n) {
                        if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
                        if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n)) {
                            if (this.usingWebAudio) {
                                if (void 0 === this._sound.stop) this._sound.noteOff(0);
                                else try {
                                    this._sound.stop(0)
                                } catch (t) {}
                                this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                            } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                            this.isPlaying = !1
                        }
                        if ("" === t && Object.keys(this.markers).length > 0) return this;
                        if ("" !== t) {
                            if (!this.markers[t]) return console.warn("Phaser.Sound.play: audio marker " + t + " doesn't exist"), this;
                            this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                        } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                        return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this.playOnce && (this.loop && console.warn("Phaser.Sound.play: audio clip " + this.name + " cannot be deleted while looping."), this._markedToDelete = !0, this._removeFromSoundManager = !0), this
                    },
                    restart: function(t, e, i, s) {
                        t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
                    },
                    pause: function() {
                        this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
                    },
                    resume: function() {
                        if (this.paused && this._sound) {
                            if (this.usingWebAudio) {
                                var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                                this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                                var e = this.duration - this.pausedPosition / 1e3;
                                void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                            } else this._sound.currentTime = this._tempPause, this._sound.play();
                            this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                        }
                    },
                    stop: function() {
                        if (this.isPlaying && this._sound)
                            if (this.usingWebAudio) {
                                if (void 0 === this._sound.stop) this._sound.noteOff(0);
                                else try {
                                    this._sound.stop(0)
                                } catch (t) {}
                                this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                            } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                        if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                            var t = this.currentMarker;
                            "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                        }
                    },
                    fadeIn: function(t, e, i) {
                        void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
                    },
                    fadeOut: function(t) {
                        this.fadeTo(t, 0)
                    },
                    fadeTo: function(t, e) {
                        this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e ? (this.fadeTween = this.game.add.tween(this).to({
                            volume: e
                        }, t, i.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)) : console.warn("Phaser.Sound.fadeTo: No Volume Specified."))
                    },
                    fadeComplete: function() {
                        this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
                    },
                    updateGlobalVolume: function(t) {
                        this.usingAudioTag && this._sound && (this._globalVolume = t, this._sound.volume = this._globalVolume * this._volume)
                    },
                    destroy: function(t) {
                        void 0 === t && (t = !0), this._markedToDelete = !0, this._removeFromSoundManager = t, this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
                    }
                }, i.Sound.prototype.constructor = i.Sound, Object.defineProperty(i.Sound.prototype, "isDecoding", {
                    get: function() {
                        return this.game.cache.getSound(this.key).isDecoding
                    }
                }), Object.defineProperty(i.Sound.prototype, "isDecoded", {
                    get: function() {
                        return this.game.cache.isSoundDecoded(this.key)
                    }
                }), Object.defineProperty(i.Sound.prototype, "mute", {
                    get: function() {
                        return this._muted || this.game.sound.mute
                    },
                    set: function(t) {
                        (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
                    }
                }), Object.defineProperty(i.Sound.prototype, "volume", {
                    get: function() {
                        return this._volume
                    },
                    set: function(t) {
                        this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = this._globalVolume * t))
                    }
                }), i.SoundManager = function(t) {
                    this.game = t, this.onSoundDecode = new i.Signal, this.onVolumeChange = new i.Signal, this.onMute = new i.Signal, this.onUnMute = new i.Signal, this.onTouchUnlock = new i.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new i.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
                }, i.SoundManager.prototype = {
                    boot: function() {
                        var t = this.game.device,
                            e = window.PhaserGlobal;
                        if (t.iOS && !1 === t.webAudio && (this.channels = 1), e) {
                            if (!0 === e.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                            if (!0 === e.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                        }
                        if (e && e.audioContext) this.context = e.audioContext;
                        else if (window.AudioContext) try {
                            this.context = new window.AudioContext
                        } catch (t) {
                            this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                        } else if (window.webkitAudioContext) try {
                            this.context = new window.webkitAudioContext
                        } catch (t) {
                            this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                        }
                        if (null === this.context) {
                            if (void 0 === window.Audio) return void(this.noAudio = !0);
                            this.usingAudioTag = !0
                        } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                        this.noAudio || t.needsTouchUnlock() && this.setTouchLock(), this.usingWebAudio && t.chrome && t.chromeVersion <= 65 && console.log('A "GainNode.gain.value setter smoothing is deprecated" notice in Chrome is normal. <https://github.com/photonstorm/phaser-ce/issues/385>')
                    },
                    setTouchLock: function() {
                        this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.input.addTouchLockCallback(this.unlock, this, !0), this.touchLocked = !0)
                    },
                    setTouchUnlock: function() {
                        this.touchLocked = !1, this._unlockSource = null, this.onTouchUnlock.dispatch()
                    },
                    unlock: function() {
                        if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                        if (this.usingAudioTag) this.setTouchUnlock();
                        else if (this.usingWebAudio) {
                            var t = this.context.createBuffer(1, 1, 22050);
                            this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), "suspended" === this._unlockSource.context.state && this._unlockSource.context.resume()
                        }
                        return !0
                    },
                    stopAll: function() {
                        if (!this.noAudio)
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
                    },
                    pauseAll: function() {
                        if (!this.noAudio)
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
                    },
                    resumeAll: function() {
                        if (!this.noAudio)
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
                    },
                    decode: function(t, e) {
                        e = e || null;
                        var i = this.game.cache.getSoundData(t);
                        if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                            this.game.cache.updateSound(t, "isDecoding", !0);
                            var s = this;
                            try {
                                this.context.decodeAudioData(i, function(i) {
                                    i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                                })
                            } catch (t) {}
                        }
                    },
                    setDecodedCallback: function(t, e, s) {
                        "string" == typeof t && (t = [t]), this._watchList.reset();
                        for (var n = 0; n < t.length; n++) t[n] instanceof i.Sound ? this.game.cache.isSoundDecoded(t[n].key) || this._watchList.add(t[n].key) : this.game.cache.isSoundDecoded(t[n]) || this._watchList.add(t[n]);
                        0 === this._watchList.total ? (this._watching = !1, e.call(s)) : (this._watching = !0, this._watchCallback = e, this._watchContext = s)
                    },
                    update: function() {
                        if (!this.noAudio) {
                            !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || this.setTouchUnlock();
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                            if (this._watching) {
                                for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                                0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                            }
                        }
                    },
                    add: function(t, e, s, n) {
                        void 0 === e && (e = 1), void 0 === s && (s = !1), void 0 === n && (n = this.connectToMaster);
                        var r = new i.Sound(this.game, t, e, s, n);
                        return this._sounds.push(r), r
                    },
                    addSprite: function(t) {
                        return new i.AudioSprite(this.game, t)
                    },
                    remove: function(t) {
                        for (var e = this._sounds.length; e--;)
                            if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                        return !1
                    },
                    removeAll: function() {
                        this.stopAll();
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                        this._sounds.length = 0
                    },
                    removeByKey: function(t) {
                        for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                        return i
                    },
                    play: function(t, e, i) {
                        if (!this.noAudio) {
                            var s = this.add(t, e, i);
                            return s.play(), s
                        }
                    },
                    setMute: function() {
                        if (!this._muted) {
                            this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                            this.onMute.dispatch()
                        }
                    },
                    unsetMute: function() {
                        if (this._muted && !this._codeMuted) {
                            this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                            for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                            this.onUnMute.dispatch()
                        }
                    },
                    destroy: function() {
                        this.removeAll(), this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
                    }
                }, i.SoundManager.prototype.constructor = i.SoundManager, Object.defineProperty(i.SoundManager.prototype, "mute", {
                    get: function() {
                        return this._muted
                    },
                    set: function(t) {
                        if (t = t || !1) {
                            if (this._muted) return;
                            this._codeMuted = !0, this.setMute()
                        } else {
                            if (!this._muted) return;
                            this._codeMuted = !1, this.unsetMute()
                        }
                    }
                }), Object.defineProperty(i.SoundManager.prototype, "volume", {
                    get: function() {
                        return this._volume
                    },
                    set: function(t) {
                        if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                            if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                            else
                                for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                            this.onVolumeChange.dispatch(t)
                        }
                    }
                }), i.ScaleManager = function(t, e, s) {
                    this.game = t, this.dom = i.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new i.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new i.Signal, this.enterIncorrectOrientation = new i.Signal, this.leaveIncorrectOrientation = new i.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new i.Signal, this.onFullScreenChange = new i.Signal, this.onFullScreenError = new i.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new i.Point(1, 1), this.scaleFactorInversed = new i.Point(1, 1), this.margin = {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0,
                        x: 0,
                        y: 0
                    }, this.bounds = new i.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                        right: "layout",
                        bottom: ""
                    }, this.compatibility = {
                        supportsFullScreen: !1,
                        orientationFallback: null,
                        noMargins: !1,
                        scrollTo: null,
                        forceMinimumDocumentHeight: !1,
                        canExpandParent: !0,
                        clickTrampoline: ""
                    }, this._scaleMode = i.ScaleManager.NO_SCALE, this._fullScreenScaleMode = i.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new i.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new i.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new i.Rectangle, this._userScaleFactor = new i.Point(1, 1), this._userScaleTrim = new i.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new i.Rectangle, this._tempBounds = new i.Rectangle, this._lastReportedCanvasSize = new i.Rectangle, this._lastReportedGameSize = new i.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, s)
                }, i.ScaleManager.EXACT_FIT = 0, i.ScaleManager.NO_SCALE = 1, i.ScaleManager.SHOW_ALL = 2, i.ScaleManager.RESIZE = 3, i.ScaleManager.USER_SCALE = 4, i.ScaleManager.MODES = ["EXACT_FIT", "NO_SCALE", "SHOW_ALL", "RESIZE", "USER_SCALE"], i.ScaleManager.prototype = {
                    boot: function() {
                        var t = this.compatibility;
                        t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new i.Point(0, 1) : t.scrollTo = new i.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                        var e = this;
                        this._orientationChange = function(t) {
                            return e.orientationChange(t)
                        }, this._windowResize = function(t) {
                            return e.windowResize(t)
                        }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                            return e.fullScreenChange(t)
                        }, this._fullScreenError = function(t) {
                            return e.fullScreenError(t)
                        }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), i.FlexGrid && (this.grid = new i.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
                    },
                    parseConfig: function(t) {
                        void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget), this.pageAlignHorizontally = t.alignH || !1, this.pageAlignVertically = t.alignV || !1, t.scaleH && t.scaleV && this.setUserScale(t.scaleH, t.scaleV, t.trimH, t.trimV)
                    },
                    setupScale: function(t, e) {
                        var s, n = new i.Rectangle;
                        "" !== this.game.parent && ("string" == typeof this.game.parent ? s = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (s = this.game.parent)), s ? (this.parentNode = s, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), n.width = this._parentBounds.width, n.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, n.width = this.dom.visualBounds.width, n.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                        var r = 0,
                            o = 0;
                        "number" == typeof t ? r = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, r = n.width * this.parentScaleFactor.x), "number" == typeof e ? o = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, o = n.height * this.parentScaleFactor.y), r = Math.floor(r), o = Math.floor(o), this._gameSize.setTo(0, 0, r, o), this.updateDimensions(r, o, !1)
                    },
                    _gameResumed: function() {
                        this.queueUpdate(!0)
                    },
                    setGameSize: function(t, e) {
                        this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== i.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
                    },
                    setUserScale: function(t, e, i, s, n, r) {
                        this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), void 0 === n && (n = !0), void 0 === r && (r = !0), n && this.queueUpdate(r)
                    },
                    setResizeCallback: function(t, e) {
                        this.onResize = t, this.onResizeContext = e
                    },
                    signalSizeChange: function() {
                        if (!i.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !i.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                            var t = this.width,
                                e = this.height;
                            this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === i.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                        }
                    },
                    setMinMax: function(t, e, i, s) {
                        this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
                    },
                    preUpdate: function() {
                        if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                            var t = this._updateThrottle;
                            this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                            var e = this._parentBounds.width,
                                s = this._parentBounds.height,
                                n = this.getParentBounds(this._parentBounds),
                                r = n.width !== e || n.height !== s,
                                o = this.updateOrientationState();
                            (r || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, n), this.updateLayout(), this.signalSizeChange());
                            var a = 2 * this._updateThrottle;
                            this._updateThrottle < t && (a = Math.min(t, this._updateThrottleReset)), this._updateThrottle = i.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                        }
                    },
                    pauseUpdate: function() {
                        this.preUpdate(), this._updateThrottle = this.trackParentInterval
                    },
                    updateDimensions: function(t, e, i) {
                        this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
                    },
                    updateScalingAndBounds: function() {
                        this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
                    },
                    forceOrientation: function(t, e) {
                        void 0 === e && (e = !1), !0 !== t || !0 !== e ? (this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)) : console.warn("Phaser.ScaleManager: forceLandscape and forcePortrait cannot both be true.")
                    },
                    classifyOrientation: function(t) {
                        return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
                    },
                    updateOrientationState: function() {
                        var t = this.screenOrientation,
                            e = this.incorrectOrientation;
                        this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                        var i = t !== this.screenOrientation,
                            s = e !== this.incorrectOrientation;
                        return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
                    },
                    orientationChange: function(t) {
                        this.event = t, this.queueUpdate(!0)
                    },
                    windowResize: function(t) {
                        this.event = t, this.queueUpdate(!0)
                    },
                    scrollTop: function() {
                        var t = this.compatibility.scrollTo;
                        t && window.scrollTo(t.x, t.y)
                    },
                    refresh: function() {
                        this.scrollTop(), this.queueUpdate(!0)
                    },
                    updateLayout: function() {
                        var t = this.currentScaleMode;
                        if (t !== i.ScaleManager.RESIZE) {
                            if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === i.ScaleManager.EXACT_FIT ? this.setExactFit() : t === i.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === i.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === i.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === i.ScaleManager.SHOW_ALL || t === i.ScaleManager.USER_SCALE)) {
                                var e = this.getParentBounds(this._tempBounds);
                                this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                            }
                            this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                        } else this.reflowGame()
                    },
                    getParentBounds: function(t) {
                        var e = t || new i.Rectangle,
                            s = this.boundingParent,
                            n = this.dom.visualBounds,
                            r = this.dom.layoutBounds;
                        if (s) {
                            var o = s.getBoundingClientRect(),
                                a = s.offsetParent ? s.offsetParent.getBoundingClientRect() : s.getBoundingClientRect();
                            e.setTo(o.left - a.left, o.top - a.top, o.width, o.height);
                            var h = this.windowConstraints;
                            if (h.right) {
                                u = "layout" === h.right ? r : n;
                                e.right = Math.min(e.right, u.width)
                            }
                            if (h.bottom) {
                                var u = "layout" === h.bottom ? r : n;
                                e.bottom = Math.min(e.bottom, u.height)
                            }
                        } else e.setTo(0, 0, n.width, n.height);
                        return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
                    },
                    align: function(t, e) {
                        null != t && (this.pageAlignHorizontally = t), null != e && (this.pageAlignVertically = e)
                    },
                    alignCanvas: function(t, e) {
                        var i = this.getParentBounds(this._tempBounds),
                            s = this.game.canvas,
                            n = this.margin;
                        if (t) {
                            n.left = n.right = 0;
                            h = s.getBoundingClientRect();
                            if (this.width < i.width && !this.incorrectOrientation) {
                                var r = h.left - i.x,
                                    o = i.width / 2 - this.width / 2,
                                    a = (o = Math.max(o, 0)) - r;
                                n.left = Math.round(a)
                            }
                            s.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - h.width - n.left), s.style.marginRight = n.right + "px")
                        }
                        if (e) {
                            n.top = n.bottom = 0;
                            var h = s.getBoundingClientRect();
                            if (this.height < i.height && !this.incorrectOrientation) {
                                var r = h.top - i.y,
                                    o = i.height / 2 - this.height / 2,
                                    a = (o = Math.max(o, 0)) - r;
                                n.top = Math.round(a)
                            }
                            s.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - h.height - n.top), s.style.marginBottom = n.bottom + "px")
                        }
                        n.x = n.left, n.y = n.top
                    },
                    reflowGame: function() {
                        this.resetCanvas("", "");
                        var t = this.getParentBounds(this._tempBounds);
                        this.updateDimensions(t.width, t.height, !0)
                    },
                    reflowCanvas: function() {
                        this.incorrectOrientation || (this.width = i.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = i.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
                    },
                    resetCanvas: function(t, e) {
                        void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                        var i = this.game.canvas;
                        this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
                    },
                    queueUpdate: function(t) {
                        t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
                    },
                    reset: function(t) {
                        t && this.grid && this.grid.reset()
                    },
                    setMaximum: function() {
                        this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
                    },
                    setShowAll: function(t) {
                        var e, i = this.getParentBounds(this._tempBounds),
                            s = i.width,
                            n = i.height;
                        e = t ? Math.max(n / this.game.height, s / this.game.width) : Math.min(n / this.game.height, s / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e)
                    },
                    setExactFit: function() {
                        var t = this.getParentBounds(this._tempBounds);
                        this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
                    },
                    createFullScreenTarget: function() {
                        var t = document.createElement("div");
                        return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
                    },
                    startFullScreen: function(t, e) {
                        if (this.isFullScreen) return !1; {
                            if (this.compatibility.supportsFullScreen) {
                                if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                                    var s = this.game.input;
                                    if (s.activePointer && s.activePointer !== s.mousePointer && (e || !1 !== e)) return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                                }
                                void 0 !== t && this.game.renderType === i.CANVAS && (this.game.stage.smoothed = t);
                                var n = this.fullScreenTarget;
                                n || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), n = this._createdFullScreenTarget);
                                var r = {
                                    targetElement: n
                                };
                                if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, r), this._createdFullScreenTarget) {
                                    var o = this.game.canvas;
                                    o.parentNode.insertBefore(n, o), n.appendChild(o)
                                }
                                return this.game.device.fullscreenKeyboard ? n[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : n[this.game.device.requestFullscreen](), !0
                            }
                            var a = this;
                            setTimeout(function() {
                                a.fullScreenError()
                            }, 10)
                        }
                    },
                    stopFullScreen: function() {
                        return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
                    },
                    cleanupCreatedTarget: function() {
                        var t = this._createdFullScreenTarget;
                        if (t && t.parentNode) {
                            var e = t.parentNode;
                            e.insertBefore(this.game.canvas, t), e.removeChild(t)
                        }
                        this._createdFullScreenTarget = null
                    },
                    prepScreenMode: function(t) {
                        var e = !!this._createdFullScreenTarget,
                            s = this._createdFullScreenTarget || this.fullScreenTarget;
                        t ? (e || this.fullScreenScaleMode === i.ScaleManager.EXACT_FIT) && s !== this.game.canvas && (this._fullScreenRestore = {
                            targetWidth: s.style.width,
                            targetHeight: s.style.height
                        }, s.style.width = "100%", s.style.height = "100%") : (this._fullScreenRestore && (s.style.width = this._fullScreenRestore.targetWidth, s.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
                    },
                    fullScreenChange: function(t) {
                        this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
                    },
                    fullScreenError: function(t) {
                        this.event = t, this.cleanupCreatedTarget(), console.warn("Phaser.ScaleManager: requestFullscreen failed or device does not support the Fullscreen API"), this.onFullScreenError.dispatch(this)
                    },
                    scaleSprite: function(t, e, i, s) {
                        if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                        if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                        var n = e,
                            r = t.height * e / t.width,
                            o = t.width * i / t.height,
                            a = i,
                            h = o > e;
                        return (h = h ? s : !s) ? (t.width = Math.floor(n), t.height = Math.floor(r)) : (t.width = Math.floor(o), t.height = Math.floor(a)), t
                    },
                    destroy: function() {
                        this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
                    }
                }, i.ScaleManager.prototype.constructor = i.ScaleManager, Object.defineProperty(i.ScaleManager.prototype, "boundingParent", {
                    get: function() {
                        return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "scaleMode", {
                    get: function() {
                        return this._scaleMode
                    },
                    set: function(t) {
                        return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "fullScreenScaleMode", {
                    get: function() {
                        return this._fullScreenScaleMode
                    },
                    set: function(t) {
                        return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "currentScaleMode", {
                    get: function() {
                        return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignHorizontally", {
                    get: function() {
                        return this._pageAlignHorizontally
                    },
                    set: function(t) {
                        t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignVertically", {
                    get: function() {
                        return this._pageAlignVertically
                    },
                    set: function(t) {
                        t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "isFullScreen", {
                    get: function() {
                        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "isPortrait", {
                    get: function() {
                        return "portrait" === this.classifyOrientation(this.screenOrientation)
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "isLandscape", {
                    get: function() {
                        return "landscape" === this.classifyOrientation(this.screenOrientation)
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "isGamePortrait", {
                    get: function() {
                        return this.height > this.width
                    }
                }), Object.defineProperty(i.ScaleManager.prototype, "isGameLandscape", {
                    get: function() {
                        return this.width > this.height
                    }
                }), i.Utils.Debug = function(t) {
                    this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.lineWidth = 1, this.renderShadow = !0, this.currentColor = null, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1, this.isDisabled = !1, this._line = null, this._rect = null
                }, i.Utils.Debug.prototype = {
                    boot: function() {
                        this.game.renderType === i.CANVAS ? this.context = this.game.context : (this.bmd = new i.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = i.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")), this._line = new i.Line, this._rect = new i.Rectangle
                    },
                    resize: function() {
                        this.bmd.resize(this.game.width, this.game.height), this.canvas.width = this.game.width, this.canvas.height = this.game.height
                    },
                    preUpdate: function() {
                        this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
                    },
                    reset: function() {
                        this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
                    },
                    start: function(t, e, i, s) {
                        "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
                    },
                    stop: function() {
                        this.context.restore()
                    },
                    line: function() {
                        for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                        this.currentY += this.lineHeight
                    },
                    sound: function(t, e, i) {
                        var s = this.game.sound;
                        this.start(t, e, i), s.noAudio ? this.line("Audio is disabled") : (this.line("Volume: " + s.volume.toFixed(2) + (s.mute ? " (Mute)" : "")), this.line("Mute on pause: " + s.muteOnPause), this.line("Using: " + (s.usingWebAudio ? "Web Audio - " + s.context.state : "Audio Tag")), this.line("Touch locked: " + s.touchLocked), this.line("Sounds: " + s._sounds.length)), this.stop()
                    },
                    soundInfo: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Sound: " + t.key + " Touch locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Playing: " + t.isPlaying + " Loop: " + t.loop), this.line("Time: " + t.currentTime + "ms Total: " + t.totalDuration.toFixed(3) + "s"), this.line("Volume: " + t.volume.toFixed(2) + (t.mute ? " (Mute)" : "")), this.line("Using: " + (t.usingWebAudio ? "Web Audio" : "Audio Tag")), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
                    },
                    camera: function(t, e, i) {
                        var s = t.deadzone,
                            n = t.target,
                            r = t.view;
                        s && (this._rect.setTo(r.x + s.x, r.y + s.y, s.width, s.height), this.rectangle(this._rect, e, i)), n && (this._line.setTo(r.centerX, r.centerY, n.x, n.y), this.geom(this._line, e, i), this.geom(n, e, !1, 3))
                    },
                    cameraInfo: function(t, e, i, s) {
                        var n = t.bounds,
                            r = t.deadzone,
                            o = t.target,
                            a = t.view;
                        this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("x: " + t.x + " y: " + t.y), this.line("Bounds: " + (n ? "x: " + n.x + " y: " + n.y + " w: " + n.width + " h: " + n.height : "none")), this.line("View: x: " + a.x + " y: " + a.y + " w: " + a.width + " h: " + a.height), this.line("Deadzone: " + (r ? "x: " + r.x + " y: " + r.y + " w: " + r.width + " h: " + r.height : r)), this.line("Total in view: " + t.totalInView), this.line("At limit: x: " + t.atLimit.x + " y: " + t.atLimit.y), this.line("Target: " + (o ? o.name || o : "none")), this.stop()
                    },
                    timer: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
                    },
                    pointer: function(t, e, i, s, n) {
                        null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = s, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
                    },
                    spriteInputInfo: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
                    },
                    key: function(t, e, i, s) {
                        this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
                    },
                    inputInfo: function(t, e, i) {
                        this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
                    },
                    spriteBounds: function(t, e, i) {
                        var s = t.getBounds();
                        s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
                    },
                    ropeSegments: function(t, e, i) {
                        var s = this;
                        t.segments.forEach(function(t) {
                            s.rectangle(t, e, i)
                        }, this)
                    },
                    spriteInfo: function(t, e, i, s) {
                        this.start(e, i, s), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
                    },
                    spriteCoords: function(t, e, i, s) {
                        this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
                    },
                    lineInfo: function(t, e, i, s) {
                        this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
                    },
                    pixel: function(t, e, i, s) {
                        s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
                    },
                    geom: function(t, e, s, n) {
                        void 0 === s && (s = !0), void 0 === n && (n = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, this.context.lineWidth = this.lineWidth, t instanceof i.Rectangle || 1 === n ? s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof i.Circle || 2 === n ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()) : t instanceof i.Point || 3 === n ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : t instanceof i.Line || 4 === n ? (this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()) : (t instanceof i.Ellipse || 5 === n) && (this.context.beginPath(), this.context.ellipse(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width / 2, t.height / 2, 0, 2 * Math.PI, !1), this.context.closePath(), s ? this.context.fill() : this.context.stroke()), this.stop()
                    },
                    rectangle: function(t, e, i) {
                        void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.lineWidth = this.lineWidth, this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
                    },
                    text: function(t, e, i, s, n) {
                        s = s || "rgb(255,255,255)", n = n || "16px Courier", this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
                    },
                    quadTree: function(t, e) {
                        e = e || "rgba(255,0,0,0.3)", this.start();
                        var i = t.bounds;
                        if (0 === t.nodes.length) {
                            this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                            for (s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                        } else
                            for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                        this.stop()
                    },
                    body: function(t, e, s) {
                        t.body && (this.start(), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.render(this.context, t.body, e, s, this.lineWidth) : t.body.type === i.Physics.NINJA ? i.Physics.Ninja.Body.render(this.context, t.body, e, s) : t.body.type === i.Physics.BOX2D && i.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
                    },
                    bodyInfo: function(t, e, s, n) {
                        t.body && (this.start(e, s, n, 210), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === i.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
                    },
                    box2dWorld: function() {
                        this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
                    },
                    box2dBody: function(t, e) {
                        this.start(), i.Physics.Box2D.renderBody(this.context, t, e), this.stop()
                    },
                    displayList: function(t) {
                        if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID") ? console.log("[" + t.renderOrderID + "]", t) : console.log("[]", t), t.children && t.children.length > 0)
                            for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
                    },
                    renderer: function(t, e, i) {
                        var s = this.game.renderer,
                            n = s.renderSession;
                        if (this.start(t, e, i), this.line((s.gl ? "WebGL" : "Canvas") + " Renderer (" + s.width + " x " + s.height + ")"), this.line("autoResize: " + s.autoResize), this.line("clearBeforeRender: " + s.clearBeforeRender), this.line("resolution: " + s.resolution), this.line("transparent: " + s.transparent), this.line("renderSession:"), s.gl) {
                            this.line("  currentBatchedTextures: (" + s.currentBatchedTextures.length + ")");
                            for (var r = 0; r < s.currentBatchedTextures.length; r++) this.line("    " + s.currentBatchedTextures[r]);
                            this.line("  drawCount: " + n.drawCount), this.line("  maxTextures: " + s.maxTextures), this.line("  maxTextureSize: " + s.maxTextureSize), this.line("  maxTextureAvailableSpace: " + n.maxTextureAvailableSpace), this.line("  roundPixels: " + n.roundPixels)
                        } else this.line("  roundPixels: " + n.roundPixels), this.line("  scaleMode: " + (0 === n.scaleMode ? "LINEAR" : 1 === n.scaleMode ? "NEAREST" : n.scaleMode));
                        this.stop()
                    },
                    canvasPool: function(t, e, s, n) {
                        var r = i.CanvasPool;
                        this.start(t, e, s, n || 100), this.line("Canvas Pool"), this.line("Used:", r.getTotal()), this.line("Free:", r.getFree()), this.line("Total:", r.length), this.stop()
                    },
                    physicsGroup: function(t, e, i, s) {
                        t.forEach(this.body, this, s, e, i)
                    },
                    phaser: function(t, e, s) {
                        this.text("Phaser v" + i.VERSION + " " + (this.game.renderType === i.WEBGL ? "WebGL" : "Canvas") + " " + (this.game.device.webAudio ? "WebAudio" : "HTML Audio"), t, e, s, this.font)
                    },
                    scale: function(t, e, s) {
                        this.start(t, e, s);
                        var n = this.game.scale,
                            r = n.scaleFactorInversed,
                            o = n._parentBounds,
                            t = " x ";
                        this.line("Game: " + this.game.width + t + this.game.height), this.line("Canvas: " + n.width + t + n.height + " (" + r.x.toFixed(2) + t + r.y.toFixed(2) + ") [" + n.aspectRatio.toFixed(2) + "]"), this.line("Mode: " + i.ScaleManager.MODES[n.currentScaleMode] + (n.currentScaleMode === i.ScaleManager.USER_SCALE ? " (" + n._userScaleFactor.x + t + n._userScaleFactor.y + ")" : "")), this.line("Parent: " + (n.parentIsWindow ? "window" : n.parentNode) + (o.empty ? "" : " (" + o.width + t + o.height + ")")), this.line("Screen: " + n.classifyOrientation(n.screenOrientation) + (n.incorrectOrientation ? " (incorrect)" : "")), this.stop()
                    },
                    loader: function(t, e, s, n) {
                        var r = i.Utils.pad;
                        this.start(e, s, n), t.hasLoaded ? this.line("Complete" + (t.resetLocked ? " [locked]" : "")) : t.isLoading ? this.line("Loading") : this.line("Not started"), t.hasLoaded && !t.resetLocked || (this.line("Progress: " + r(t.progress, 3) + "%"), this.line("Files: " + t._loadedFileCount + " of " + t._totalFileCount), this.line("Packs: " + t._loadedPackCount + " of " + t._loadedPackCount)), this.stop()
                    },
                    destroy: function() {
                        i.CanvasPool.remove(this)
                    }
                }, i.Utils.Debug.prototype.constructor = i.Utils.Debug, i.DOM = {
                    getOffset: function(t, e) {
                        e = e || new i.Point;
                        var s = t.getBoundingClientRect(),
                            n = i.DOM.scrollY,
                            r = i.DOM.scrollX,
                            o = document.documentElement.clientTop,
                            a = document.documentElement.clientLeft;
                        return e.x = s.left + r - a, e.y = s.top + n - o, e
                    },
                    getBounds: function(t, e) {
                        return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
                    },
                    calibrate: function(t, e) {
                        e = +e || 0;
                        var i = {
                            width: 0,
                            height: 0,
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        };
                        return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
                    },
                    getAspectRatio: function(t) {
                        var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                            i = t.height;
                        return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
                    },
                    inLayoutViewport: function(t, e) {
                        var i = this.getBounds(t, e);
                        return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
                    },
                    getScreenOrientation: function(t) {
                        var e = window.screen,
                            i = e.orientation || e.mozOrientation || e.msOrientation;
                        if (i && "string" == typeof i.type) return i.type;
                        if ("string" == typeof i) return i;
                        var s = "portrait-primary",
                            n = "landscape-primary";
                        if ("screen" === t) return e.height > e.width ? s : n;
                        if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : n;
                        if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : n;
                        if (window.matchMedia) {
                            if (window.matchMedia("(orientation: portrait)").matches) return s;
                            if (window.matchMedia("(orientation: landscape)").matches) return n
                        }
                        return this.visualBounds.height > this.visualBounds.width ? s : n
                    },
                    visualBounds: new i.Rectangle,
                    layoutBounds: new i.Rectangle,
                    documentBounds: new i.Rectangle
                }, i.Device.whenReady(function(t) {
                    var e = window && "pageXOffset" in window ? function() {
                            return window.pageXOffset
                        } : function() {
                            return document.documentElement.scrollLeft
                        },
                        s = window && "pageYOffset" in window ? function() {
                            return window.pageYOffset
                        } : function() {
                            return document.documentElement.scrollTop
                        };
                    if (Object.defineProperty(i.DOM, "scrollX", {
                            get: e
                        }), Object.defineProperty(i.DOM, "scrollY", {
                            get: s
                        }), Object.defineProperty(i.DOM.visualBounds, "x", {
                            get: e
                        }), Object.defineProperty(i.DOM.visualBounds, "y", {
                            get: s
                        }), Object.defineProperty(i.DOM.layoutBounds, "x", {
                            value: 0
                        }), Object.defineProperty(i.DOM.layoutBounds, "y", {
                            value: 0
                        }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                        var n = function() {
                                return Math.max(window.innerWidth, document.documentElement.clientWidth)
                            },
                            r = function() {
                                return Math.max(window.innerHeight, document.documentElement.clientHeight)
                            };
                        Object.defineProperty(i.DOM.visualBounds, "width", {
                            get: n
                        }), Object.defineProperty(i.DOM.visualBounds, "height", {
                            get: r
                        }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                            get: n
                        }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                            get: r
                        })
                    } else Object.defineProperty(i.DOM.visualBounds, "width", {
                        get: function() {
                            return window.innerWidth
                        }
                    }), Object.defineProperty(i.DOM.visualBounds, "height", {
                        get: function() {
                            return window.innerHeight
                        }
                    }), Object.defineProperty(i.DOM.layoutBounds, "width", {
                        get: function() {
                            var t = document.documentElement.clientWidth,
                                e = window.innerWidth;
                            return t < e ? e : t
                        }
                    }), Object.defineProperty(i.DOM.layoutBounds, "height", {
                        get: function() {
                            var t = document.documentElement.clientHeight,
                                e = window.innerHeight;
                            return t < e ? e : t
                        }
                    });
                    Object.defineProperty(i.DOM.documentBounds, "x", {
                        value: 0
                    }), Object.defineProperty(i.DOM.documentBounds, "y", {
                        value: 0
                    }), Object.defineProperty(i.DOM.documentBounds, "width", {
                        get: function() {
                            var t = document.documentElement;
                            return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                        }
                    }), Object.defineProperty(i.DOM.documentBounds, "height", {
                        get: function() {
                            var t = document.documentElement;
                            return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                        }
                    })
                }, null, !0), i.ArraySet = function(t) {
                    this.position = 0, this.list = t || []
                }, i.ArraySet.prototype = {
                    add: function(t) {
                        return this.exists(t) || this.list.push(t), t
                    },
                    getIndex: function(t) {
                        return this.list.indexOf(t)
                    },
                    getByKey: function(t, e) {
                        for (var i = this.list.length; i--;)
                            if (this.list[i][t] === e) return this.list[i];
                        return null
                    },
                    exists: function(t) {
                        return this.list.indexOf(t) > -1
                    },
                    reset: function() {
                        this.list.length = 0
                    },
                    remove: function(t) {
                        var e = this.list.indexOf(t);
                        if (e > -1) return this.list.splice(e, 1), t
                    },
                    setAll: function(t, e) {
                        for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
                    },
                    callAll: function(t) {
                        for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
                    },
                    removeAll: function(t) {
                        void 0 === t && (t = !1);
                        for (var e = this.list.length; e--;)
                            if (this.list[e]) {
                                var i = this.remove(this.list[e]);
                                t && i.destroy()
                            }
                        this.position = 0, this.list = []
                    }
                }, Object.defineProperty(i.ArraySet.prototype, "total", {
                    get: function() {
                        return this.list.length
                    }
                }), Object.defineProperty(i.ArraySet.prototype, "first", {
                    get: function() {
                        return this.position = 0, this.list.length > 0 ? this.list[0] : null
                    }
                }), Object.defineProperty(i.ArraySet.prototype, "next", {
                    get: function() {
                        return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
                    }
                }), i.ArraySet.prototype.constructor = i.ArraySet, i.ArrayUtils = {
                    getRandomItem: function(t, e, i) {
                        if (null === t) return null;
                        void 0 === e && (e = 0), void 0 === i && (i = t.length);
                        var s = e + Math.floor(Math.random() * i);
                        return void 0 === t[s] ? null : t[s]
                    },
                    removeRandomItem: function(t, e, i) {
                        if (null == t) return null;
                        void 0 === e && (e = 0), void 0 === i && (i = t.length);
                        var s = e + Math.floor(Math.random() * i);
                        if (s < t.length) {
                            var n = t.splice(s, 1);
                            return void 0 === n[0] ? null : n[0]
                        }
                        return null
                    },
                    remove: function(t, e, i) {
                        var s = t.length;
                        if (!(e >= s || 0 === i)) {
                            null == i && (i = 1);
                            for (var n = s - i, r = e; r < n; ++r) t[r] = t[r + i];
                            t.length = n
                        }
                    },
                    shuffle: function(t) {
                        for (var e = t.length - 1; e > 0; e--) {
                            var i = Math.floor(Math.random() * (e + 1)),
                                s = t[e];
                            t[e] = t[i], t[i] = s
                        }
                        return t
                    },
                    transposeMatrix: function(t) {
                        for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                            s[n] = new Array(e);
                            for (var r = e - 1; r > -1; r--) s[n][r] = t[r][n]
                        }
                        return s
                    },
                    rotateMatrix: function(t, e) {
                        if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = i.ArrayUtils.transposeMatrix(t)).reverse();
                        else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = i.ArrayUtils.transposeMatrix(t);
                        else if (180 === Math.abs(e) || "rotate180" === e) {
                            for (var s = 0; s < t.length; s++) t[s].reverse();
                            t = t.reverse()
                        }
                        return t
                    },
                    findClosest: function(t, e) {
                        if (!e.length) return NaN;
                        if (1 === e.length || t < e[0]) return e[0];
                        for (var i = 1; e[i] < t;) i++;
                        var s = e[i - 1],
                            n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                        return n - t <= t - s ? n : s
                    },
                    rotateRight: function(t) {
                        var e = t.pop();
                        return t.unshift(e), e
                    },
                    rotateLeft: function(t) {
                        var e = t.shift();
                        return t.push(e), e
                    },
                    numberArray: function(t, e) {
                        void 0 !== e && null !== e || (e = t, t = 0);
                        for (var i = [], s = t; s <= e; s++) i.push(s);
                        return i
                    },
                    numberArrayStep: function(t, e, s) {
                        void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === s && (s = 1);
                        for (var n = [], r = Math.max(i.Math.roundAwayFromZero((e - t) / (s || 1)), 0), o = 0; o < r; o++) n.push(t), t += s;
                        return n
                    }
                }, i.LinkedList = function() {
                    this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
                }, i.LinkedList.prototype = {
                    add: function(t) {
                        return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
                    },
                    reset: function() {
                        this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
                    },
                    remove: function(t) {
                        if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                        t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
                    },
                    callAll: function(t) {
                        if (this.first && this.last) {
                            var e = this.first;
                            do {
                                e && e[t] && e[t].call(e), e = e.next
                            } while (e !== this.last.next)
                        }
                    }
                }, i.LinkedList.prototype.constructor = i.LinkedList, i.Create = function(t) {
                    this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                        0: "#000",
                        1: "#9D9D9D",
                        2: "#FFF",
                        3: "#BE2633",
                        4: "#E06F8B",
                        5: "#493C2B",
                        6: "#A46422",
                        7: "#EB8931",
                        8: "#F7E26B",
                        9: "#2F484E",
                        A: "#44891A",
                        B: "#A3CE27",
                        C: "#1B2632",
                        D: "#005784",
                        E: "#31A2F2",
                        F: "#B2DCEF"
                    }, {
                        0: "#000",
                        1: "#191028",
                        2: "#46af45",
                        3: "#a1d685",
                        4: "#453e78",
                        5: "#7664fe",
                        6: "#833129",
                        7: "#9ec2e8",
                        8: "#dc534b",
                        9: "#e18d79",
                        A: "#d6b97b",
                        B: "#e9d8a1",
                        C: "#216c4b",
                        D: "#d365c8",
                        E: "#afaab9",
                        F: "#f5f4eb"
                    }, {
                        0: "#000",
                        1: "#2234d1",
                        2: "#0c7e45",
                        3: "#44aacc",
                        4: "#8a3622",
                        5: "#5c2e78",
                        6: "#aa5c3d",
                        7: "#b5b5b5",
                        8: "#5e606e",
                        9: "#4c81fb",
                        A: "#6cd947",
                        B: "#7be2f9",
                        C: "#eb8a60",
                        D: "#e23d69",
                        E: "#ffd93f",
                        F: "#fff"
                    }, {
                        0: "#000",
                        1: "#fff",
                        2: "#8b4131",
                        3: "#7bbdc5",
                        4: "#8b41ac",
                        5: "#6aac41",
                        6: "#3931a4",
                        7: "#d5de73",
                        8: "#945a20",
                        9: "#5a4100",
                        A: "#bd736a",
                        B: "#525252",
                        C: "#838383",
                        D: "#acee8b",
                        E: "#7b73de",
                        F: "#acacac"
                    }, {
                        0: "#000",
                        1: "#191028",
                        2: "#46af45",
                        3: "#a1d685",
                        4: "#453e78",
                        5: "#7664fe",
                        6: "#833129",
                        7: "#9ec2e8",
                        8: "#dc534b",
                        9: "#e18d79",
                        A: "#d6b97b",
                        B: "#e9d8a1",
                        C: "#216c4b",
                        D: "#d365c8",
                        E: "#afaab9",
                        F: "#fff"
                    }]
                }, i.Create.PALETTE_ARNE = 0, i.Create.PALETTE_JMP = 1, i.Create.PALETTE_CGA = 2, i.Create.PALETTE_C64 = 3, i.Create.PALETTE_JAPANESE_MACHINE = 4, i.Create.prototype = {
                    texture: function(t, e, i, s, n, r, o, a) {
                        void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0), void 0 === r && (r = !0);
                        var h = e[0].length * i,
                            u = e.length * s;
                        null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(h, u), this.bmd.clear();
                        for (var l = 0; l < e.length; l++)
                            for (var c = e[l], d = 0; d < c.length; d++) {
                                var p = c[d];
                                "." !== p && " " !== p && (this.ctx.fillStyle = this.palettes[n][p], this.ctx.fillRect(d * i, l * s, i, s))
                            }
                        return r ? this.bmd.generateTexture(t, o, a) : this.copy()
                    },
                    grid: function(t, e, i, s, n, r, o, a, h) {
                        void 0 === o && (o = !0), null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = r;
                        for (var u = 0; u < i; u += n) this.ctx.fillRect(0, u, e, 1);
                        for (var l = 0; l < e; l += s) this.ctx.fillRect(l, 0, 1, i);
                        return o ? this.bmd.generateTexture(t, a, h) : this.copy()
                    },
                    copy: function(t, e, i, s, n, r, o) {
                        return null == t && (t = this.game.make.bitmapData()), t.resize(this.bmd.width, this.bmd.height), t.draw(this.bmd, e, i, s, n, r, o)
                    }
                }, i.Create.prototype.constructor = i.Create, i.FlexGrid = function(t, e, s) {
                    this.game = t.game, this.manager = t, this.width = e, this.height = s, this.boundsCustom = new i.Rectangle(0, 0, e, s), this.boundsFluid = new i.Rectangle(0, 0, e, s), this.boundsFull = new i.Rectangle(0, 0, e, s), this.boundsNone = new i.Rectangle(0, 0, e, s), this.positionCustom = new i.Point(0, 0), this.positionFluid = new i.Point(0, 0), this.positionFull = new i.Point(0, 0), this.positionNone = new i.Point(0, 0), this.scaleCustom = new i.Point(1, 1), this.scaleFluid = new i.Point(1, 1), this.scaleFluidInversed = new i.Point(1, 1), this.scaleFull = new i.Point(1, 1), this.scaleNone = new i.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / s, this.ratioV = s / e, this.multiplier = 0, this.layers = []
                }, i.FlexGrid.prototype = {
                    setSize: function(t, e) {
                        this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new i.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
                    },
                    createCustomLayer: function(t, e, s, n) {
                        void 0 === n && (n = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                        var r = new i.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                        return n && this.game.world.add(r), this.layers.push(r), void 0 !== s && null !== typeof s && r.addMultiple(s), r
                    },
                    createFluidLayer: function(t, e) {
                        void 0 === e && (e = !0);
                        var s = new i.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                        return e && this.game.world.add(s), this.layers.push(s), void 0 !== t && null !== typeof t && s.addMultiple(t), s
                    },
                    createFullLayer: function(t) {
                        var e = new i.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                        return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                    },
                    createFixedLayer: function(t) {
                        var e = new i.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                        return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                    },
                    reset: function() {
                        for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
                    },
                    onResize: function(t, e) {
                        this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
                    },
                    refresh: function() {
                        this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
                    },
                    fitSprite: function(t) {
                        this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
                    },
                    debug: function() {
                        this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
                    }
                }, i.FlexGrid.prototype.constructor = i.FlexGrid, i.FlexLayer = function(t, e, s, n) {
                    i.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = s, this.scale = n, this.topLeft = s.topLeft, this.topMiddle = new i.Point(s.halfWidth, 0), this.topRight = s.topRight, this.bottomLeft = s.bottomLeft, this.bottomMiddle = new i.Point(s.halfWidth, s.bottom), this.bottomRight = s.bottomRight
                }, i.FlexLayer.prototype = Object.create(i.Group.prototype), i.FlexLayer.prototype.constructor = i.FlexLayer, i.FlexLayer.prototype.resize = function() {}, i.FlexLayer.prototype.debug = function() {
                    this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
                }, i.Color = {
                    RED: 16711680,
                    ORANGE: 16750848,
                    YELLOW: 16776960,
                    GREEN: 65280,
                    AQUA: 65535,
                    BLUE: 255,
                    VIOLET: 16711935,
                    WHITE: 16777215,
                    BLACK: 0,
                    GRAY: 6710886,
                    packPixel: function(t, e, s, n) {
                        return i.Device.LITTLE_ENDIAN ? (n << 24 | s << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | s << 8 | n) >>> 0
                    },
                    unpackPixel: function(t, e, s, n) {
                        return void 0 !== e && null !== e || (e = i.Color.createColor()), void 0 !== s && null !== s || (s = !1), void 0 !== n && null !== n || (n = !1), i.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", s && i.Color.RGBtoHSL(e.r, e.g, e.b, e), n && i.Color.RGBtoHSV(e.r, e.g, e.b, e), e
                    },
                    fromRGBA: function(t, e) {
                        return e || (e = i.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
                    },
                    toRGBA: function(t, e, i, s) {
                        return t << 24 | e << 16 | i << 8 | s
                    },
                    toABGR: function(t, e, i, s) {
                        return (s << 24 | i << 16 | e << 8 | t) >>> 0
                    },
                    hexToRGBArray: function(t) {
                        return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
                    },
                    RGBArrayToHex: function(t) {
                        return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
                    },
                    RGBtoHSL: function(t, e, s, n) {
                        n || (n = i.Color.createColor(t, e, s, 1)), t /= 255, e /= 255, s /= 255;
                        var r = Math.min(t, e, s),
                            o = Math.max(t, e, s);
                        if (n.h = 0, n.s = 0, n.l = (o + r) / 2, o !== r) {
                            var a = o - r;
                            n.s = n.l > .5 ? a / (2 - o - r) : a / (o + r), o === t ? n.h = (e - s) / a + (e < s ? 6 : 0) : o === e ? n.h = (s - t) / a + 2 : o === s && (n.h = (t - e) / a + 4), n.h /= 6
                        }
                        return n
                    },
                    HSLtoRGB: function(t, e, s, n) {
                        if (n ? (n.r = s, n.g = s, n.b = s) : n = i.Color.createColor(s, s, s), 0 !== e) {
                            var r = s < .5 ? s * (1 + e) : s + e - s * e,
                                o = 2 * s - r;
                            n.r = i.Color.hueToColor(o, r, t + 1 / 3), n.g = i.Color.hueToColor(o, r, t), n.b = i.Color.hueToColor(o, r, t - 1 / 3)
                        }
                        return n.r = Math.floor(255 * n.r | 0), n.g = Math.floor(255 * n.g | 0), n.b = Math.floor(255 * n.b | 0), i.Color.updateColor(n), n
                    },
                    RGBtoHSV: function(t, e, s, n) {
                        n || (n = i.Color.createColor(t, e, s, 255)), t /= 255, e /= 255, s /= 255;
                        var r = Math.min(t, e, s),
                            o = Math.max(t, e, s),
                            a = o - r;
                        return n.h = 0, n.s = 0 === o ? 0 : a / o, n.v = o, o !== r && (o === t ? n.h = (e - s) / a + (e < s ? 6 : 0) : o === e ? n.h = (s - t) / a + 2 : o === s && (n.h = (t - e) / a + 4), n.h /= 6), n
                    },
                    HSVtoRGB: function(t, e, s, n) {
                        void 0 === n && (n = i.Color.createColor(0, 0, 0, 1, t, e, 0, s));
                        var r, o, a, h = Math.floor(6 * t),
                            u = 6 * t - h,
                            l = s * (1 - e),
                            c = s * (1 - u * e),
                            d = s * (1 - (1 - u) * e);
                        switch (h % 6) {
                            case 0:
                                r = s, o = d, a = l;
                                break;
                            case 1:
                                r = c, o = s, a = l;
                                break;
                            case 2:
                                r = l, o = s, a = d;
                                break;
                            case 3:
                                r = l, o = c, a = s;
                                break;
                            case 4:
                                r = d, o = l, a = s;
                                break;
                            case 5:
                                r = s, o = l, a = c
                        }
                        return n.r = Math.floor(255 * r), n.g = Math.floor(255 * o), n.b = Math.floor(255 * a), i.Color.updateColor(n), n
                    },
                    hueToColor: function(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                    },
                    createColor: function(t, e, s, n, r, o, a, h) {
                        var u = {
                            r: t || 0,
                            g: e || 0,
                            b: s || 0,
                            a: n || 1,
                            h: r || 0,
                            s: o || 0,
                            l: a || 0,
                            v: h || 0,
                            color: 0,
                            color32: 0,
                            rgba: ""
                        };
                        return i.Color.updateColor(u)
                    },
                    updateColor: function(t) {
                        return t.rgba = "rgba(" + t.r.toFixed() + "," + t.g.toFixed() + "," + t.b.toFixed() + "," + t.a.toString() + ")", t.color = i.Color.getColor(t.r, t.g, t.b), t.color32 = i.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
                    },
                    getColor32: function(t, e, i, s) {
                        return t << 24 | e << 16 | i << 8 | s
                    },
                    getColor: function(t, e, i) {
                        return t << 16 | e << 8 | i
                    },
                    RGBtoString: function(t, e, s, n, r) {
                        return void 0 === n && (n = 255), void 0 === r && (r = "#"), "#" === r ? "#" + ((1 << 24) + (t << 16) + (e << 8) + s).toString(16).slice(1) : "0x" + i.Color.componentToHex(n) + i.Color.componentToHex(t) + i.Color.componentToHex(e) + i.Color.componentToHex(s)
                    },
                    hexToRGB: function(t) {
                        var e = i.Color.hexToColor(t);
                        if (e) return i.Color.getColor32(e.a, e.r, e.g, e.b)
                    },
                    hexToColor: function(t, e) {
                        t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                            return e + e + i + i + s + s
                        });
                        var s = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                        if (s) {
                            var n = parseInt(s[1], 16),
                                r = parseInt(s[2], 16),
                                o = parseInt(s[3], 16);
                            e ? (e.r = n, e.g = r, e.b = o) : e = i.Color.createColor(n, r, o)
                        }
                        return e
                    },
                    webToColor: function(t, e) {
                        e || (e = i.Color.createColor());
                        var s = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                        return s && (e.r = ~~Number(s[1]), e.g = ~~Number(s[2]), e.b = ~~Number(s[3]), e.a = void 0 !== s[4] ? Number(s[4]) : 1, i.Color.updateColor(e)), e
                    },
                    valueToColor: function(t, e) {
                        if (e || (e = i.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? i.Color.webToColor(t, e) : (e.a = 1, i.Color.hexToColor(t, e));
                        if ("number" == typeof t) {
                            var s = i.Color.getRGB(t);
                            return e.r = s.r, e.g = s.g, e.b = s.b, e.a = s.a / 255, e
                        }
                        return e
                    },
                    componentToHex: function(t) {
                        var e = t.toString(16);
                        return 1 === e.length ? "0" + e : e
                    },
                    HSVColorWheel: function(t, e) {
                        void 0 === t && (t = 1), void 0 === e && (e = 1);
                        for (var s = [], n = 0; n <= 359; n++) s.push(i.Color.HSVtoRGB(n / 359, t, e));
                        return s
                    },
                    HSLColorWheel: function(t, e) {
                        void 0 === t && (t = .5), void 0 === e && (e = .5);
                        for (var s = [], n = 0; n <= 359; n++) s.push(i.Color.HSLtoRGB(n / 359, t, e));
                        return s
                    },
                    interpolateColor: function(t, e, s, n, r, o) {
                        void 0 === r && (r = 255), void 0 === o && (o = 0);
                        var a = i.Color.getRGB(t),
                            h = i.Color.getRGB(e);
                        if (0 === o) var u = (h.red - a.red) * n / s + a.red,
                            l = (h.green - a.green) * n / s + a.green,
                            c = (h.blue - a.blue) * n / s + a.blue;
                        if (1 === o) {
                            var d, p = i.Color.RGBtoHSV(a.r, a.g, a.b),
                                f = i.Color.RGBtoHSV(h.r, h.g, h.b),
                                g = f.h - p.h;
                            if (p.h > f.h) {
                                var m = f.h;
                                f.h = p.h, p.h = m, g = -g, n = s - n
                            }
                            g > .5 && (p.h = p.h + 1, d = ((f.h - p.h) * n / s + p.h) % 1), g <= .5 && (d = (f.h - p.h) * n / s + p.h);
                            var y = (f.s - p.s) * n / s + p.s,
                                v = (f.v - p.v) * n / s + p.v,
                                x = i.Color.HSVtoRGB(d, y, v, x),
                                u = x.r,
                                l = x.g,
                                c = x.b
                        }
                        return i.Color.getColor32(r, u, l, c)
                    },
                    interpolateColorWithRGB: function(t, e, s, n, r, o) {
                        var a = i.Color.getRGB(t),
                            h = (e - a.red) * o / r + a.red,
                            u = (s - a.green) * o / r + a.green,
                            l = (n - a.blue) * o / r + a.blue;
                        return i.Color.getColor(h, u, l)
                    },
                    interpolateRGB: function(t, e, s, n, r, o, a, h) {
                        var u = (n - t) * h / a + t,
                            l = (r - e) * h / a + e,
                            c = (o - s) * h / a + s;
                        return i.Color.getColor(u, l, c)
                    },
                    linear: function(t, e, i) {
                        return this.interpolateColor(t, e, 1, i)
                    },
                    linearInterpolation: function(t, e) {
                        var s = i.Math.linear(0, t.length - 1, e),
                            n = t[Math.floor(s)],
                            r = t[Math.ceil(s)];
                        return this.linear(n, r, s % 1)
                    },
                    getRandomColor: function(t, e, s) {
                        if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === s && (s = 255), e > 255 || t > e) return i.Color.getColor(255, 255, 255);
                        var n = t + Math.round(Math.random() * (e - t)),
                            r = t + Math.round(Math.random() * (e - t)),
                            o = t + Math.round(Math.random() * (e - t));
                        return i.Color.getColor32(s, n, r, o)
                    },
                    getRGB: function(t) {
                        return t > 16777215 ? {
                            alpha: t >>> 24,
                            red: t >> 16 & 255,
                            green: t >> 8 & 255,
                            blue: 255 & t,
                            a: t >>> 24,
                            r: t >> 16 & 255,
                            g: t >> 8 & 255,
                            b: 255 & t
                        } : {
                            alpha: 255,
                            red: t >> 16 & 255,
                            green: t >> 8 & 255,
                            blue: 255 & t,
                            a: 255,
                            r: t >> 16 & 255,
                            g: t >> 8 & 255,
                            b: 255 & t
                        }
                    },
                    getWebRGB: function(t) {
                        if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")";
                        var e = i.Color.getRGB(t);
                        return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")"
                    },
                    getAlpha: function(t) {
                        return t >>> 24
                    },
                    getAlphaFloat: function(t) {
                        return (t >>> 24) / 255
                    },
                    getRed: function(t) {
                        return t >> 16 & 255
                    },
                    getGreen: function(t) {
                        return t >> 8 & 255
                    },
                    getBlue: function(t) {
                        return 255 & t
                    },
                    blendNormal: function(t) {
                        return t
                    },
                    blendLighten: function(t, e) {
                        return e > t ? e : t
                    },
                    blendDarken: function(t, e) {
                        return e > t ? t : e
                    },
                    blendMultiply: function(t, e) {
                        return t * e / 255
                    },
                    blendAverage: function(t, e) {
                        return (t + e) / 2
                    },
                    blendAdd: function(t, e) {
                        return Math.min(255, t + e)
                    },
                    blendSubtract: function(t, e) {
                        return Math.max(0, t + e - 255)
                    },
                    blendDifference: function(t, e) {
                        return Math.abs(t - e)
                    },
                    blendNegation: function(t, e) {
                        return 255 - Math.abs(255 - t - e)
                    },
                    blendScreen: function(t, e) {
                        return 255 - ((255 - t) * (255 - e) >> 8)
                    },
                    blendExclusion: function(t, e) {
                        return t + e - 2 * t * e / 255
                    },
                    blendOverlay: function(t, e) {
                        return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
                    },
                    blendSoftLight: function(t, e) {
                        return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
                    },
                    blendHardLight: function(t, e) {
                        return i.Color.blendOverlay(e, t)
                    },
                    blendColorDodge: function(t, e) {
                        return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
                    },
                    blendColorBurn: function(t, e) {
                        return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
                    },
                    blendLinearDodge: function(t, e) {
                        return i.Color.blendAdd(t, e)
                    },
                    blendLinearBurn: function(t, e) {
                        return i.Color.blendSubtract(t, e)
                    },
                    blendLinearLight: function(t, e) {
                        return e < 128 ? i.Color.blendLinearBurn(t, 2 * e) : i.Color.blendLinearDodge(t, 2 * (e - 128))
                    },
                    blendVividLight: function(t, e) {
                        return e < 128 ? i.Color.blendColorBurn(t, 2 * e) : i.Color.blendColorDodge(t, 2 * (e - 128))
                    },
                    blendPinLight: function(t, e) {
                        return e < 128 ? i.Color.blendDarken(t, 2 * e) : i.Color.blendLighten(t, 2 * (e - 128))
                    },
                    blendHardMix: function(t, e) {
                        return i.Color.blendVividLight(t, e) < 128 ? 0 : 255
                    },
                    blendReflect: function(t, e) {
                        return 255 === e ? e : Math.min(255, t * t / (255 - e))
                    },
                    blendGlow: function(t, e) {
                        return i.Color.blendReflect(e, t)
                    },
                    blendPhoenix: function(t, e) {
                        return Math.min(t, e) - Math.max(t, e) + 255
                    }
                }, i.Physics = function(t, e) {
                    e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
                }, i.Physics.ARCADE = 0, i.Physics.P2JS = 1, i.Physics.NINJA = 2, i.Physics.BOX2D = 3, i.Physics.CHIPMUNK = 4, i.Physics.MATTERJS = 5, i.Physics.prototype = {
                    parseConfig: function() {
                        this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !i.Physics.hasOwnProperty("Arcade") || (this.arcade = new i.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && i.Physics.hasOwnProperty("Ninja") && (this.ninja = new i.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && i.Physics.hasOwnProperty("P2") && (this.p2 = new i.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && i.Physics.hasOwnProperty("BOX2D") && (this.box2d = new i.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && i.Physics.hasOwnProperty("Matter") && (this.matter = new i.Physics.Matter(this.game, this.config))
                    },
                    startSystem: function(t) {
                        t === i.Physics.ARCADE ? this.arcade = new i.Physics.Arcade(this.game) : t === i.Physics.P2JS ? null === this.p2 ? this.p2 = new i.Physics.P2(this.game, this.config) : this.p2.reset() : t === i.Physics.NINJA ? this.ninja = new i.Physics.Ninja(this.game) : t === i.Physics.BOX2D ? null === this.box2d ? this.box2d = new i.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === i.Physics.MATTERJS && (null === this.matter ? this.matter = new i.Physics.Matter(this.game, this.config) : this.matter.reset())
                    },
                    enable: function(t, e, s) {
                        void 0 === e && (e = i.Physics.ARCADE), void 0 === s && (s = !1), e === i.Physics.ARCADE ? this.arcade.enable(t) : e === i.Physics.P2JS && this.p2 ? this.p2.enable(t, s) : e === i.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === i.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === i.Physics.MATTERJS && this.matter ? this.matter.enable(t) : console.warn(t.key + " is attempting to enable a physics body using an unknown physics system.")
                    },
                    preUpdate: function() {
                        this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
                    },
                    update: function() {
                        this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
                    },
                    setBoundsToWorld: function() {
                        this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
                    },
                    clear: function() {
                        this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
                    },
                    reset: function() {
                        this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
                    },
                    destroy: function() {
                        this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
                    }
                }, i.Physics.prototype.constructor = i.Physics, i.Particles = function(t) {
                    this.game = t, this.emitters = {}, this.ID = 0
                }, i.Particles.prototype = {
                    add: function(t) {
                        return this.emitters[t.id] = t, t
                    },
                    remove: function(t) {
                        delete this.emitters[t.id]
                    }
                }, i.Particles.prototype.constructor = i.Particles, void 0 === PIXI.blendModes && (PIXI.blendModes = i.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = i.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new i.Matrix), PIXI.TextureSilentFail = !0, PIXI.canUseNewCanvasBlendModes = function() {
                    return i.Device.canUseMultiply
                }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.Phaser = i) : "undefined" != typeof define && define.amd ? define("Phaser", e.Phaser = i) : e.Phaser = i, i
            }.call(this);
        //# sourceMappingURL=phaser-custom.map</script>
    <script>! function() {
        var G = {};
        window.G = G, window.gameG = G, G.BuildEnvironment = {
            production: !1,
            APP_ID: "candy-crush",
            GAGK: "5ea9840366027cf0654b6ca2a8a91507",
            GASK: "d8aecfb6d7fae18491893b5057e826699bb77646"
        }, void 0 === G && (G = {}), console.log = function() {}, AnbycookGP = function() {
            window.parent.postMessage("okvid", "*")
        }, G.ExtLoader = function() {
            Phaser.Loader.call(this, game), game.state.onStateChange.add(this.reset, this), this.imagesToRemoveOnStateChange = [], this.loadedUrls = {}
        }, G.ExtLoader.prototype = Object.create(Phaser.Loader.prototype), G.ExtLoader.prototype.reset = function(a, b) {
            this.imagesToRemoveOnStateChange.forEach(function(a) {
                this.cache.removeImage(a)
            }, this), this.imagesToRemoveOnStateChange = [], Phaser.Loader.prototype.reset.call(this, a, b)
        }, G.ExtLoader.prototype.addToFileList = function(a, b, c, d, e, f) {
            if (void 0 === e && (e = !1), void 0 === b || "" === b) return console.warn("Phaser.Loader: Invalid or no key given of type " + a), this;
            if (null == c) {
                if (!f) return console.warn("Phaser.Loader: No URL given for file type: " + a + " key: " + b), this;
                c = b + f
            }
            var g = {
                type: a,
                key: b,
                path: this.path,
                url: c,
                syncPoint: 0 < this._withSyncPointDepth,
                data: null,
                loading: !1,
                loaded: !1,
                error: !1
            };
            if (d)
                for (var h in d) g[h] = d[h];
            var i = this.getAssetIndex(a, b);
            if (e && -1 < i) {
                var j = this._fileList[i];
                j.loading || j.loaded ? (this._fileList.push(g), this._totalFileCount++) : this._fileList[i] = g
            } else -1 === i && (this._fileList.push(g), this._totalFileCount++);
            return this.loadFile(this._fileList.shift()), this
        }, G.ExtLoader.prototype.asyncComplete = function(a, b) {
            void 0 === b && (b = ""), a.loaded = !0, a.error = !!b, b && (a.errorMessage = b, console.warn("Phaser.Loader - " + a.type + "[" + a.key + "]: " + b))
        }, G.ExtLoader.prototype.fileComplete = function(a, b) {
            switch (a.type) {
                case "packfile":
                    var c = JSON.parse(b.responseText);
                    a.data = c || {};
                    break;
                case "image":
                    this.cache.addImage(a.key, a.url, a.data);
                    break;
                case "spritesheet":
                    this.cache.addSpriteSheet(a.key, a.url, a.data, a.frameWidth, a.frameHeight, a.frameMax, a.margin, a.spacing);
                    break;
                case "textureatlas":
                    if (null == a.atlasURL) this.cache.addTextureAtlas(a.key, a.url, a.data, a.atlasData, a.format);
                    else if (a.format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || a.format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH || a.format == Phaser.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.jsonLoadComplete);
                    else {
                        if (a.format != Phaser.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + a.format);
                        this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", this.xmlLoadComplete)
                    }
                    break;
                case "bitmapfont":
                    a.atlasURL ? this.xhrLoad(a, this.transformUrl(a.atlasURL, a), "text", function(a, b) {
                        var c;
                        try {
                            c = JSON.parse(b.responseText)
                        } catch (a) {}
                        c ? (a.atlasType = "json", this.jsonLoadComplete(a, b)) : (a.atlasType = "xml", this.xmlLoadComplete(a, b))
                    }) : this.cache.addBitmapFont(a.key, a.url, a.data, a.atlasData, a.atlasType, a.xSpacing, a.ySpacing);
                    break;
                case "video":
                    if (a.asBlob) try {
                        a.data = b.response
                    } catch (b) {
                        throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + a.key)
                    }
                    this.cache.addVideo(a.key, a.url, a.data, a.asBlob);
                    break;
                case "audio":
                    this.game.sound.usingWebAudio ? (a.data = b.response, this.cache.addSound(a.key, a.url, a.data, !0, !1), a.autoDecode && this.game.sound.decode(a.key)) : this.cache.addSound(a.key, a.url, a.data, !1, !0);
                    break;
                case "text":
                    a.data = b.responseText, this.cache.addText(a.key, a.url, a.data);
                    break;
                case "shader":
                    a.data = b.responseText, this.cache.addShader(a.key, a.url, a.data);
                    break;
                case "physics":
                    c = JSON.parse(b.responseText), this.cache.addPhysicsData(a.key, a.url, c, a.format);
                    break;
                case "script":
                    a.data = document.createElement("script"), a.data.language = "javascript", a.data.type = "text/javascript", a.data.defer = !1, a.data.text = b.responseText, document.head.appendChild(a.data), a.callback && (a.data = a.callback.call(a.callbackContext, a.key, b.responseText));
                    break;
                case "binary":
                    a.data = a.callback ? a.callback.call(a.callbackContext, a.key, b.response) : b.response, this.cache.addBinary(a.key, a.data)
            }
            this.onFileComplete.dispatch(0, a.key, !a.error)
        };
        var saveAs = saveAs || function(a) {
            "use strict";
            if (!(void 0 === a || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
                var b = a.document,
                    c = function() {
                        return a.URL || a.webkitURL || a
                    },
                    d = b.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                    e = "download" in d,
                    f = /constructor/i.test(a.HTMLElement) || a.safari,
                    g = /CriOS\/[\d]+/.test(navigator.userAgent),
                    h = function(b) {
                        (a.setImmediate || a.setTimeout)(function() {
                            throw b
                        }, 0)
                    },
                    i = function(a) {
                        setTimeout(function() {
                            "string" == typeof a ? c().revokeObjectURL(a) : a.remove()
                        }, 4e4)
                    },
                    j = function(a) {
                        return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([String.fromCharCode(65279), a], {
                            type: a.type
                        }) : a
                    },
                    k = function(b, k, l) {
                        function m() {
                            ! function(a, b, c) {
                                for (var d = (b = [].concat(b)).length; d--;) {
                                    var e = a["on" + b[d]];
                                    if ("function" == typeof e) try {
                                        e.call(a, c || a)
                                    } catch (a) {
                                        h(a)
                                    }
                                }
                            }(o, "writestart progress write writeend".split(" "))
                        }
                        l || (b = j(b));
                        var n, o = this,
                            p = "application/octet-stream" === b.type;
                        return o.readyState = o.INIT, e ? (n = c().createObjectURL(b), void setTimeout(function() {
                            d.href = n, d.download = k,
                                function(a) {
                                    var b = new MouseEvent("click");
                                    a.dispatchEvent(b)
                                }(d), m(), i(n), o.readyState = o.DONE
                        })) : void! function() {
                            if ((g || p && f) && a.FileReader) {
                                var d = new FileReader;
                                return d.onloadend = function() {
                                    var b = g ? d.result : d.result.replace(/^data:[^;]*;/, "data:attachment/file;");
                                    a.open(b, "_blank") || (a.location.href = b), b = void 0, o.readyState = o.DONE, m()
                                }, d.readAsDataURL(b), o.readyState = o.INIT
                            }
                            n = n || c().createObjectURL(b), p ? a.location.href = n : a.open(n, "_blank") || (a.location.href = n), o.readyState = o.DONE, m(), i(n)
                        }()
                    },
                    l = k.prototype;
                return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(a, b, c) {
                    return b = b || a.name || "download", c || (a = j(a)), navigator.msSaveOrOpenBlob(a, b)
                } : (l.abort = function() {}, l.readyState = l.INIT = 0, l.WRITING = 1, l.DONE = 2, l.error = l.onwritestart = l.onprogress = l.onwrite = l.onabort = l.onerror = l.onwriteend = null, function(a, b, c) {
                    return new k(a, b || a.name || "download", c)
                })
            }
        }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
        "undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null !== define.amd && define("FileSaver.js", function() {
            return saveAs
        }), void 0 === G && (G = {}), G.Button = function(a, b, c, d, e) {
            Phaser.Button.call(this, game, G.l(a), G.l(b), null), this.state = game.state.getCurrentState(), G.changeTexture(this, c), this.anchor.setTo(.5), this.sfx = G.sfx.pop, this.active = !0, this.onClick = new Phaser.Signal, d && this.onClick.add(d, e || this), this.onInputDown.add(this.click, this), this.terms = [], this.IMMEDIATE = !1, this.scaleOnClick = !0, this.targetAlphaTermsNotFulfilled = .5, this.targetAlpha = 1, this.refractorPeriod = 400, this.scaleChange = .1, this.pulsing = !1
        }, G.Button.prototype = Object.create(Phaser.Button.prototype), G.Button.constructor = G.Button, G.Button.prototype.update = function() {
            this.targetAlpha = this.checkTerms() ? 1 : this.targetAlphaTermsNotFulfilled, this.alpha = G.lerp(this.alpha, this.targetAlpha, .2, .05), this.updateChildren()
        }, G.Button.prototype.pulse = function(a) {
            this.pulsing = !0, this.pulsingTween = game.add.tween(this.scale).to({
                x: a || 1.1,
                y: a || 1.1
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.Button.prototype.stopPulse = function(a) {
            this.pulsingTween && this.pulsingTween.stop(), this.scale.setTo(a || 1), this.pulsing = !1
        }, G.Button.prototype.click = function() {
            if (this.active && this.checkTerms()) {
                this.active = !1, this.onClick.dispatch(), this.sfx && this.sfx.play();
                var a = this.scale.x,
                    b = this.scale.y;
                this.IMMEDIATE ? this.active = !0 : this.pulsing || !this.scaleOnClick ? game.time.events.add(this.refractorPeriod, function() {
                    this.active = !0
                }, this) : game.add.tween(this.scale).to({
                    x: a + this.scaleChange,
                    y: b + this.scaleChange
                }, Math.floor(.5 * this.refractorPeriod), Phaser.Easing.Quadratic.Out, !0).onComplete.add(function() {
                    game.add.tween(this.scale).to({
                        x: a,
                        y: b
                    }, Math.floor(.5 * this.refractorPeriod), Phaser.Easing.Quadratic.Out, !0).onComplete.add(function() {
                        this.active = !0
                    }, this)
                }, this)
            }
        }, G.Button.prototype.checkTerms = function() {
            for (var a = 0; a < this.terms.length; a++)
                if (!this.terms[a][0].call(this.terms[a][1])) return !1;
            return !0
        }, G.Button.prototype.addTerm = function(a, b) {
            this.terms.push([a, b])
        }, G.Button.prototype.addImageLabel = function(a) {
            this.label = game.make.image(0, 0, "ssheet", a), this.label.anchor.setTo(.5), this.addChild(this.label)
        }, G.Button.prototype.addTextLabel = function(a, b, c) {
            var d = 1 / G.Loader.currentConfigMulti;
            this.label = new G.OneLineText(-7, -6, a, b, c || Math.floor(this.height * d * .7), this.width * d * .9, .5, .5), this.addChild(this.label)
        }, G.Button.prototype.addTextLabelMultiline = function(a, b) {
            var c = 1 / G.Loader.currentConfigMulti;
            this.label = new G.MultiLineText(0, 0, a, b, Math.floor(this.height * c * .5), this.width * c * .8, this.height * c * .7, "center", .5, .5), this.addChild(this.label)
        }, G.Button.prototype.addGTextLabel = function(a, b) {
            this.label = new G.Text(0, 0, a, b, .5, .9 * this.width, .9 * this.height, !0, "center"), this.addChild(this.label)
        }, G.Button.prototype.stopTweens = function() {
            G.stopTweens(this)
        }, G.Button.prototype.changeTexture = function(a) {
            G.changeTexture(this, a)
        }, G.Button.prototype.add = function(a) {
            return this.addChild(a)
        }, G.Button.prototype.updateChildren = function() {
            for (var a = this.children.length; a--;) this.children[a].update()
        }, void 0 === G && (G = {}), G.FrameAnimation = function(a, b, c, d, e) {
            Phaser.Image.call(this, game, G.l(a), G.l(b)), this.anchor.setTo(.5), this.frameNamePrefix = c, this.animFramesLen = this.getAnimationLength(this.frameNamePrefix), this.timerEvery = d ? 60 / d : 1, this.animDir = 1, G.changeTexture(this, this.frameNamePrefix + "_0"), this.currentTimer = 0, this.currentIndex = 0, this.onFinish = new Phaser.Signal, this.active = e || !1
        }, G.FrameAnimation.prototype = Object.create(Phaser.Image.prototype), G.FrameAnimation.prototype.play = function(a, b, c) {
            return this.currentTimer = 0, this.currentIndex = c || 0, this.active = !0, this.loop = a - 1 || 0, this.animDir = 1, this.bounce = b || !1, G.changeTexture(this, this.frameNamePrefix + "_" + this.currentIndex), this
        }, G.FrameAnimation.prototype.update = function() {
            if (this.active && (this.currentTimer += G.deltaTime, this.currentTimer >= this.timerEvery)) {
                if (this.currentTimer = this.currentTimer - this.timerEvery, this.currentIndex += this.animDir, this.bounce) {
                    if (this.currentIndex == this.animFramesLen || 0 == this.currentIndex) {
                        if (0 == this.loop && 0 == this.currentIndex) return this.onFinish.dispatch(), this.active = !1;
                        0 < this.loop && 0 == this.currentIndex && this.loop--, this.currentIndex == this.animFramesLen && (this.currentIndex = this.animFramesLen - 1), this.animDir *= -1
                    }
                } else if (this.currentIndex == this.animFramesLen) {
                    if (0 == this.loop) return this.onFinish.dispatch(), this.active = !1;
                    0 < this.loop && this.loop--, this.currentIndex = 0
                }
                G.changeTexture(this, this.frameNamePrefix + "_" + this.currentIndex)
            }
        }, G.FrameAnimation.prototype.getAnimationLength = function(a) {
            if (G.FrameAnimation.CacheAnimLength[a]) return G.FrameAnimation.CacheAnimLength[a];
            for (var b = 0, c = 0; c < 1e3 && G.isImageInCache(a + "_" + c); c++) b++;
            return G.FrameAnimation.CacheAnimLength[a] = b
        }, G.FrameAnimation.CacheAnimLength = {}, G.gift = {}, G.gift.getGift = function(a) {
            a = a || "normals";
            var b = G.json.settings.gifts[a],
                c = b.boosterMaxNr || G.json.settings.gifts.boosterMaxNr,
                d = b.boosterChance || G.json.settings.gifts.boosterChance,
                e = [];
            b.list.forEach(function(a) {
                "coin" == a[0] ? e.push(a) : -1 !== a[0].indexOf("booster") && G.saveState.isBoosterUnlocked(parseInt(a[0][8])) && G.saveState.getBoosterAmount(parseInt(a[0][8])) < c && e.push(a)
            }), Phaser.ArrayUtils.shuffle(e);
            for (var f = Math.random() < d, g = 0; g < e.length; g++) {
                var h = e[g];
                if (-1 === h[0].indexOf("booster")) return h.slice();
                if (f) return h.slice()
            }
            return ["coin", 50]
        }, G.gift.getLabelString = function(a) {
            return a[1] + " @" + G.json.settings.gifts.icons[a[0]] + "@"
        }, G.gift.applyGift = function(a) {
            "coin" == a[0] ? G.saveState.changeCoins(a[1]) : G.saveState.changeBoosterAmount(parseInt(a[0][8]), a[1])
        }, G.gift.getIcon = function(a) {
            return G.json.settings.gifts.icons[a[0]]
        }, void 0 === G && (G = {}), G.GridArray = function(b) {
            "number" == typeof b ? this.createGrid.apply(this, arguments) : "string" == typeof b ? (this.data = JSON.parse(b), this.width = this.data.length, this.height = this.data[0].length) : Array.isArray(b) && (a = b, this.data = b, this.width = this.data.length, this.height = this.data[0].length)
        }, G.GridArray.prototype = {
            createGrid: function(a, b, c) {
                this.data = [], this.width = a, this.height = b;
                for (var d = 0; d < a; d++) {
                    this.data[d] = [];
                    for (var e = 0; e < b; e++) this.data[d][e] = c
                }
            },
            set: function(a, b, c) {
                return this.isInGrid(a, b) ? this.data[a][b] = c : (this.dbg && console.log("setValue OUT OF RANGE"), !1)
            },
            get: function(a, b) {
                return this.isInGrid(a, b) ? this.data[a][b] : (this.dbg && console.log("getValue OUT OF RANGE"), !1)
            },
            swapValues: function(a, b, c, d) {
                if (!this.isInGrid(a, b) || !this.isInGrid(c, d)) return this.dbg && console.log("swapValues OUT OF RANGE"), !1;
                var e = this.data[a][b];
                this.data[a][b] = this.data[c][d], this.data[c][d] = e
            },
            isInGrid: function(a, b) {
                return !(a < 0 || a >= this.width || b < 0 || b >= this.height)
            },
            find: function(a, b) {
                for (var c = 0; c < this.width; c++)
                    for (var d = 0; d < this.height; d++)
                        if (a.call(b, this.data[c][d], c, d, this.data)) return this.data[c][d];
                return !1
            },
            filter: function(a, b) {
                for (var c = [], d = 0; d < this.width; d++)
                    for (var e = 0; e < this.height; e++) a.call(b, this.data[d][e], d, e, this.data) && c.push(this.data[d][e]);
                return c
            },
            loop: function(a, b) {
                for (var c = 0; c < this.width; c++)
                    for (var d = 0; d < this.height; d++) a.call(b, this.data[c][d], c, d, this.data)
            },
            clear: function(a) {
                this.loop(function(b, c, d, e) {
                    e[c][d] = a || !1
                })
            },
            findPattern: function(a, b) {
                var c = !1,
                    d = a.length;
                return this.loop(function(e, f, g) {
                    if (e == b && !c) {
                        for (var i = 0; i < d; i += 2) {
                            if (!this.get(f + a[i], g + a[i + 1])) return;
                            if (this.get(f + a[i], g + a[i + 1]) !== b) return
                        }
                        c = [];
                        for (var j = 0; j < d; j += 2) c.push(f + a[j], g + a[j + 1])
                    }
                }, this), c
            },
            count: function() {
                for (var a = 0, b = 0; b < this.width; b++)
                    for (var c = 0; c < this.height; c++) this.data[b][c] && a++;
                return a
            },
            getAllElements: function() {
                for (var a = [], b = 0; b < this.width; b++)
                    for (var c = 0; c < this.height; c++) this.data[b][c] && a.push(this.data[b][c]);
                return a
            }
        }, G.Image = function(a, b, c, d, e) {
            Phaser.Image.call(this, game, G.l(a), G.l(b), null), this.state = game.state.getCurrentState(), this.changeTexture(c), d && ("number" == typeof d ? this.anchor.setTo(d) : this.anchor.setTo(d[0], d[1])), e ? (e.add || e.addChild).call(e, this) : null !== e && game.world.add(this)
        }, G.Image.prototype = Object.create(Phaser.Image.prototype), G.Image.prototype.stopTweens = function() {
            G.stopTweens(this)
        }, G.Image.prototype.changeTexture = function(a) {
            G.changeTexture(this, a)
        }, Phaser.Image.prototype.changeTexture = function(a) {
            G.changeTexture(this, a)
        }, G.Image.prototype.add = function(a) {
            return this.addChild(a)
        }, G.LabelGroupT = function(a, b, c, d, e, f, g) {
            Phaser.Group.call(this, game), this.str = a, this.tagArray = G.LabelParser.changeIntoTagArray(a), this.x = b, this.y = c, this.textStyle = d, this.fontSize = parseInt(d.fontSize), this.distanceBetween = g || 0, "number" == typeof e ? this.anchorX = this.anchorY = e : (this.anchorX = e[0], this.anchorY = e[1]), this.maxWidth = f || 0, this.processTagArray()
        }, G.LabelGroupT.prototype = Object.create(Phaser.Group.prototype), G.LabelGroupT.prototype.processTagArray = function() {
            for (var a = 0; a < this.tagArray.length; a++)
                if ("img" == this.tagArray[a].type)(b = G.makeImage(0, 0, this.tagArray[a].content, 0, this)).tagScale = this.tagArray[a].scale;
                else if ("separator" == this.tagArray[a].type) {
                var b;
                (b = G.makeImage(0, 0, null, 0, this)).SEPARATOR = !0, b.SEP_LENGTH = this.tagArray[a].length
            } else this.add(new G.Text(0, 0, this.tagArray[a].content, this.textStyle));
            this.refresh()
        }, G.LabelGroupT.prototype.refresh = function() {
            if (this.applySizeAndAnchor(), 0 < this.maxWidth && this.getWholeWidth() > this.maxWidth)
                for (; this.getWholeWidth() > this.maxWidth;) this.distanceBetween = Math.floor(.9 * this.distanceBetween), this.fontSize = Math.floor(.9 * this.fontSize), this.applySizeAndAnchor();
            this.spreadElements()
        }, G.LabelGroupT.prototype.applySizeAndAnchor = function() {
            this.children.forEach(function(a) {
                a.anchor.setTo(this.anchorX, this.anchorY), a.fontSize ? (a.fontSize = this.fontSize, a.updateTransform()) : (a.height = this.fontSize * (a.tagScale || 1), a.scale.x = a.scale.y), a.SEPARATOR && (a.width = this.fontSize * a.SEP_LENGTH)
            }, this)
        }, G.LabelGroupT.prototype.getWholeWidth = function() {
            var a = (this.children.length - 1) * this.distanceBetween,
                b = 0;
            return this.children.forEach(function(a) {
                b += a.width
            }), a + b
        }, G.LabelGroupT.prototype.spreadElements = function() {
            var a = this.getWholeWidth() * this.anchorX * -1;
            this.children.forEach(function(b, c, d) {
                b.left = 0 == c ? a : d[c - 1].right + this.distanceBetween
            }, this)
        }, G.LabelParser = {
            specialChars: ["$", "@", "%", "^"],
            changeIntoTagArray: function(a, b) {
                for (var c = [], d = 0; 0 < a.length && !(20 < d++);) {
                    var e = this.findFirstSpecialChar(a);
                    if (-1 === e) {
                        c.push(a);
                        break
                    }
                    0 < e[0] && (c.push(a.slice(0, e[0])), a = a.slice(e[0])), a = this.cutOffTag(a, c, e[1])
                }
                var f = [];
                for (d = 0; d < c.length; d++) f.push(this.processTag(c[d], b));
                return this.mergeTextTagsInArray(f)
            },
            mergeTextTagsInArray: function(a) {
                for (var b = [], c = null, d = 0; d < a.length; d++) "text" !== a[d].type ? (null !== c && (b.push(this.mergeTextTags(a, c, d)), c = null), b.push(a[d])) : null == c && (c = d);
                return null !== c && b.push(this.mergeTextTags(a, c, d)), b
            },
            mergeTextTags: function(a, b, c) {
                for (var d = {
                        type: "text",
                        content: []
                    }; b < c; b++) d.content.push(a[b].content);
                return d.content = d.content.join(" "), d
            },
            processTag: function(a, b) {
                if ("@" != a[0]) return "%" == a[0] ? {
                    type: "text",
                    content: b[a.slice(1, -1)]
                } : "$" == a[0] ? {
                    type: "text",
                    content: G.txt(a.slice(1, -1))
                } : "^" == a[0] ? {
                    type: "text",
                    content: a.slice(1, -1)
                } : this.isStringJustSpaces(a) ? {
                    type: "separator",
                    content: a,
                    length: a.length
                } : {
                    type: "text",
                    content: a
                };
                var c = 1;
                return "*" == a[1] && a.indexOf("*", 2) && (c = parseFloat(a.slice(a.indexOf("*") + 1, a.indexOf("*", 2))), a = a.slice(a.indexOf("*", 2))), {
                    type: "img",
                    content: a.slice(1, -1),
                    scale: c
                }
            },
            isStringJustSpaces: function(a) {
                for (var b = 0; b < a.length; b++)
                    if (" " !== a[b]) return !1;
                return !0
            },
            cutOffTag: function(a, b, c) {
                var d = a.indexOf(c),
                    e = a.indexOf(c, d + 1);
                return b.push(a.slice(d, e + 1)), a.slice(0, d) + a.slice(e + 1)
            },
            findFirstSpecialChar: function(a) {
                var b = 1 / 0,
                    c = !1;
                return this.specialChars.forEach(function(d) {
                    var e = a.indexOf(d); - 1 < e && e < b && (c = d, b = Math.min(e, b))
                }), b === 1 / 0 ? -1 : [b, c]
            },
            createLabel: function(a, b, c, d, e, f, g, h, i, j) {
                return this.changeIntoTagArray(a, b), new G.LabelGroup(c, d, f, i, g, h, j)
            }
        }, G.LabelGroup = function(a, b, c, d, e, f, g, h) {
            Phaser.Group.call(this, game), this.fontData = game.cache.getBitmapFont(d).font, this.fontBaseSize = this.fontData.size, this.fontSpaceOffset = this.fontData.chars[32].xOffset + this.fontData.chars[32].xAdvance, this.str = a, this.tagArray = G.LabelParser.changeIntoTagArray(a), this.x = void 0 === b ? 0 : G.l(b), this.y = void 0 === c ? 0 : G.l(c), this.font = d, this.fontSize = G.l(void 0 === e ? 30 : e), this.distanceBetween = 0, this.anchorX = void 0 === f ? .5 : f, this.anchorY = void 0 === g ? .5 : g, this.maxWidth = h || 0, this.processTagArray()
        }, G.LabelGroup.prototype = Object.create(Phaser.Group.prototype), G.LabelGroup.prototype.processTagArray = function() {
            for (var a = 0; a < this.tagArray.length; a++)
                if ("img" == this.tagArray[a].type)(b = G.makeImage(0, 0, this.tagArray[a].content, 0, this)).tagScale = this.tagArray[a].scale;
                else if ("separator" == this.tagArray[a].type) {
                var b;
                (b = G.makeImage(0, 0, null, 0, this)).SEPARATOR = !0, b.SEP_LENGTH = this.tagArray[a].length
            } else this.add(game.add.bitmapText(0, 0, this.font, this.tagArray[a].content, this.fontSize));
            this.refresh()
        }, G.LabelGroup.prototype.refresh = function() {
            if (this.applySizeAndAnchor(), 0 < this.maxWidth && this.getWholeWidth() > this.maxWidth)
                for (; this.getWholeWidth() > this.maxWidth;) this.distanceBetween *= .9, this.fontSize *= .9, this.applySizeAndAnchor();
            this.spreadElements()
        }, G.LabelGroup.prototype.applySizeAndAnchor = function() {
            this.children.forEach(function(a) {
                a.anchor.setTo(this.anchorX, this.anchorY), a.fontSize ? (a.fontSize = this.fontSize, a.updateText()) : (a.height = this.fontSize * (a.tagScale || 1), a.scale.x = a.scale.y), a.SEPARATOR && (a.width = this.fontSize / this.fontBaseSize * this.fontSpaceOffset * a.SEP_LENGTH)
            }, this)
        }, G.LabelGroup.prototype.getWholeWidth = function() {
            var a = (this.children.length - 1) * this.distanceBetween,
                b = 0;
            return this.children.forEach(function(a) {
                b += a.width
            }), a + b
        }, G.LabelGroup.prototype.spreadElements = function() {
            var a = this.getWholeWidth() * this.anchorX * -1;
            this.children.forEach(function(b, c, d) {
                b.left = 0 == c ? a : d[c - 1].right + this.distanceBetween
            }, this)
        }, G.LineEditor = function() {
            Phaser.Group.call(this, game), this.gfx = game.add.graphics(), this.gfx.fixedToCamera = !0, this.points = {
                x: [],
                y: []
            }, this.currentIndex = null, this.pointerStart = new Phaser.Point(0, 0), this.interpolation = "linearInterpolation", game.input.onDown.add(function(a) {
                this.currentIndex = this.findCurrentIndex(a), null !== this.currentIndex && (this.pointerStart.x = a.x, this.pointerStart.y = a.y)
            }, this), game.input.onUp.add(function() {
                this.currentIndex = null
            }, this), this.keys = game.input.keyboard.addKeys({
                Z: Phaser.Keyboard.Z,
                X: Phaser.Keyboard.X,
                C: Phaser.Keyboard.C,
                A: Phaser.Keyboard.A,
                S: Phaser.Keyboard.S,
                D: Phaser.Keyboard.D
            }), this.keys.Z.onDown.add(function() {
                this.interpolation = "catmullRomInterpolation"
            }, this), this.keys.X.onDown.add(function() {
                this.interpolation = "bezierInterpolation"
            }, this), this.keys.C.onDown.add(function() {
                this.interpolation = "linearInterpolation"
            }, this), this.keys.A.onDown.add(function() {
                var a = game.input.activePointer;
                this.points.x.push(a.x), this.points.y.push(a.y)
            }, this), this.keys.S.onDown.add(function() {
                this.currentIndex && (this.points.x.splice(this.currentIndex, 1), this.points.y.splice(this.currentIndex, 1))
            }, this), this.keys.D.onDown.add(function() {
                this.points.x.pop(), this.points.y.pop()
            }, this)
        }, G.LineEditor.prototype = Object.create(Phaser.Group.prototype), G.LineEditor.prototype.update = function() {
            if (this.currentIndex) {
                var a = game.input.activePointer,
                    b = this.pointerStart.x - a.x,
                    c = this.pointerStart.y - a.y;
                this.pointerStart.x = a.x, this.pointerStart.y = a.y, this.points.x[this.currentIndex] -= b, this.points.y[this.currentIndex] -= c
            }
            this.redraw()
        }, G.LineEditor.prototype.findCurrentIndex = function(a) {
            for (var b = null, c = 1 / 0, d = 0; d < this.points.x.length; d++) {
                var e = game.math.distance(a.x, a.y, this.points.x[d], this.points.y[d]);
                e < c && (b = d, c = e)
            }
            return b
        }, G.LineEditor.prototype.redraw = function() {
            this.gfx.clear(), this.drawLine(), this.drawPoints()
        }, G.LineEditor.prototype.drawPoints = function() {
            this.gfx.lineStyle(2, 255, 1), this.gfx.beginFill(255, .5);
            for (var a = 0; a < this.points.x.length; a++) this.gfx.drawCircle(this.points.x[a], this.points.y[a], 10)
        }, G.LineEditor.prototype.drawLine = function() {
            if (0 != this.points.x.length) {
                this.gfx.lineStyle(2, 16711680, 1), this.gfx.moveTo(this.points.x[0], this.points.y[0]);
                for (var a = 0; a < 1; a += .001) {
                    var b = game.math[this.interpolation](this.points.x, a),
                        c = game.math[this.interpolation](this.points.y, a);
                    this.gfx.lineTo(b, c)
                }
            }
        }, void 0 === G && (G = {}), G.Loader = {
            currentConfig: "hd",
            currentConfigMulti: 1,
            loadingScreenActive: !1,
            lang: !1,
            passConfigs: function(a) {
                this.configs = a
            },
            setConfig: function(a) {
                this.currentConfig = a, this.currentConfigMulti = this.configs[a]
            },
            killLoadingScreen: function() {
                G.imgRotate && (G.whiteOverlay.destroy(), G.imgRotate.fadeOut = !0, G.imgRotate = !1, this.loadingScreenActive = !1)
            },
            loadPOSTImage: function(a) {
                void 0 !== a && (game.cache.checkImageKey(a) || (this.makeLoadingScreen(), game.load.image(a, "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/imagesPOST/" + a)))
            },
            loadBootAssets: function(a) {
                a && (this.lang = a.toUpperCase()), G.ASSETS.images.forEach(function(a) {
                    this.checkIfLoad(a, !0) && game.load.image(this.removeExt(this.cutOffPrefixes(a)), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/images/" + a)
                }, this), G.ASSETS.spritesheets.forEach(function(a) {
                    this.checkIfLoad(a, !0) && game.load.atlasJSONHash(this.cutOffPrefixes(a), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/spritesheets/" + a + ".png", "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/spritesheets/" + a + ".json")
                }, this), game.load.onLoadComplete.addOnce(function() {
                    this.createSpritesheetMap(!0)
                }, this)
            },
            loadAssets: function(a) {
                a && (this.lang = a.toUpperCase()), game.load.onLoadComplete.addOnce(this.processAssets, this), 0 == (null !== navigator.appVersion.match(/Chrome\/3[0-9]\./)) && this.loadSFX(G.ASSETS.sfx), this.loadImages(G.ASSETS.images), this.loadSpritesheets(G.ASSETS.spritesheets), this.loadJson(G.ASSETS.json), this.loadFonts(G.ASSETS.fonts)
            },
            processAssets: function() {
                this.processJson(G.ASSETS.json), this.processSFX(G.ASSETS.sfx), this.createSpritesheetMap()
            },
            createSpritesheetMap: function(a) {
                G.spritesheetMap || (G.spritesheetMap = {});
                for (var b = 0, c = G.ASSETS.spritesheets.length; b < c; b++)
                    if (this.checkIfLoad(G.ASSETS.spritesheets[b], a)) {
                        var d = this.cutOffPrefixes(G.ASSETS.spritesheets[b]);
                        if (game.cache.checkImageKey(d))
                            for (var e = game.cache.getFrameData(d), f = 0; f < e._frames.length; f++) {
                                var g = e._frames[f];
                                G.spritesheetMap[g.name] && console.warn("Images name collision: " + g.name), G.spritesheetMap[g.name] = d
                            }
                    }
            },
            loadSFX: function(a) {
                a.forEach(function(a) {
                    game.load.audio(this.removeExt(a), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/sfx/" + a)
                }, this)
            },
            loadFonts: function(a) {
                for (var b in a) {
                    if (!this.checkIfLoad(b)) return;
                    game.load.bitmapFont(this.cutOffPrefixes(b), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/fonts/" + a[b].frame, "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/fonts/" + a[b].data)
                }
            },
            loadImages: function(a) {
                a.forEach(function(a) {
                    this.checkIfLoad(a) && game.load.image(this.removeExt(this.cutOffPrefixes(a)), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/images/" + a)
                }, this)
            },
            loadJson: function(a) {
                a.forEach(function(a) {
                    game.load.json(this.removeExt(a), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/json/" + a)
                }, this)
            },
            loadSpritesheets: function(a) {
                a.forEach(function(a) {
                    this.checkIfLoad(a) && game.load.atlasJSONHash(this.cutOffPrefixes(a), "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/spritesheets/" + a + ".png", "https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/assets/" + this.currentConfig + "/spritesheets/" + a + ".json")
                }, this)
            },
            checkIfLoad: function(a, b) {
                return (!b || -1 != a.indexOf("BOOT-")) && !(!b && -1 !== a.indexOf("BOOT-")) && (-1 === a.indexOf("MOBILE-") || !game.device.desktop) && !(-1 !== a.indexOf("DESKTOP-") && !game.device.desktop) && (!this.lang || !a.match(/^[A-Z]{2}\-/) || 0 == a.indexOf(this.lang + "-"))
            },
            cutOffPrefixes: function(a) {
                return a = (a = (a = (a = a.replace(/^[A-Z]{2}\-/, "")).replace("BOOT-", "")).replace("MOBILE-", "")).replace("DESKTOP-", "")
            },
            removeExt: function(a) {
                return a.slice(0, a.lastIndexOf("."))
            },
            processJson: function(a) {
                G.json = {}, a.forEach(function(a) {
                    a = this.removeExt(a), G.json[a] = game.cache.getJSON(a)
                }, this)
            },
            processSFX: function(a) {
                G.sfx = {}, game.sfx = G.sfx;
                var b = {};
                a.forEach(function(a) {
                    a = this.removeExt(a), G.sfx[a] = game.add.audio(a);
                    var c = a.lastIndexOf("_");
                    if (-1 !== c && !isNaN(a.slice(c + 1))) {
                        parseInt(a.slice(c + 1));
                        var d = a.slice(0, c);
                        b[d] || (b[d] = []), b[d].push(G.sfx[a])
                    }
                }, this), Object.keys(b).forEach(function(a) {
                    G.sfx[a] = {
                        sfxArray: b[a],
                        play: function(a, b, c) {
                            game.rnd.pick(this.sfxArray).play("", 0, a, b, c)
                        }
                    }
                })
            }
        }, G.MultiLineText = function(a, b, c, d, e, f, g, h, i, j) {
            if (a = G.l(a), b = G.l(b), e = G.l(e), f = G.l(f), g = G.l(g), this.maxUserWidth = f, this.maxUserHeight = g, Phaser.BitmapText.call(this, game, a, b, c, "", e), this.splitText(d, f), this.align = h || "center", g)
                for (; this.height > g && (this.fontSize -= 2, this.splitText(d, f), this.updateText(), !(this.fontSize < 5)););
            this.anchor.setTo(i, j), this.cacheAsBitmap = !0
        }, G.MultiLineText.prototype = Object.create(Phaser.BitmapText.prototype), G.MultiLineText.prototype.constructor = G.MultiLineText, G.MultiLineText.prototype.splitText = function(a, b) {
            for (var c = a, d = [], e = 0, f = 0; 0 < c.length;)
                if (e = f, this.setText(-1 == (f = c.indexOf(" ", f + 1)) ? c : c.substring(0, f)), this.updateText(), this.width > b) {
                    if (0 == e && -1 == f) {
                        d.push(c), c = "", f = 0;
                        continue
                    }
                    if (0 == e) {
                        d.push(c.substring(0, f)), c = c.substring(f + 1), f = 0;
                        continue
                    }
                    d.push(c.substring(0, e)), c = c.substring(e + 1), f = 0
                } else -1 == f && (d.push(c), c = "");
            this.setText(d.join("\n"))
        }, G.MultiLineText.prototype.popUpAnimation = function() {
            this.cacheAsBitmap = !1;
            for (var a = this.children.length, b = [], c = 0; c < a; c++) b[c] = c;
            b = Phaser.ArrayUtils.shuffle(b), delay_index = 0, this.activeTweens = 0, this.children.forEach(function(a) {
                0 == a.anchor.x && (a.x = a.x + .5 * a.width, a.y = a.y + a.height, a.anchor.setTo(.5, 1));
                var c = a.scale.x;
                a.scale.setTo(0, 0), this.activeTweens++;
                var d = game.add.tween(a.scale).to({
                    x: 1.5 * c,
                    y: 1.5 * c
                }, 200, Phaser.Easing.Quadratic.In, !1, 25 * b[delay_index]).to({
                    x: c,
                    y: c
                }, 200, Phaser.Easing.Sinusoidal.In);
                d.onComplete.add(function() {
                    this.activeTweens--, 0 == this.activeTweens && this.alive && (this.cacheAsBitmap = !0)
                }, this), d.start(), delay_index++
            }, this)
        }, G.OneLineText = function(a, b, c, d, e, f, g, h) {
            if (Phaser.BitmapText.call(this, game, G.l(a), G.l(b), c, d, G.l(e), G.l(f)), f)
                for (; this.width > G.l(f) && (this.fontSize -= 2, this.updateText(), !(this.fontSize < 5)););
            this.orgFontSize = G.l(e), this.maxUserWidth = G.l(f), this.skipCaching = G.skipOneLineTextCaching || !1, this.hAnchor = g, this.vAnchor = h, this.anchor.setTo(this.hAnchor, this.vAnchor), this.updateText(), this.insertCoin(this.fontSize), this.skipCaching || (this.cacheAsBitmap = !0, this.updateCache())
        }, G.OneLineText.prototype = Object.create(Phaser.BitmapText.prototype), G.OneLineText.prototype.constructor = G.OneLineText, G.OneLineText.prototype.insertCoin = function(a) {
            -1 != this.text.indexOf("$$") && this.children.forEach(function(b, c, d) {
                if (b.name && "$" == b.name && b.visible && c + 1 <= d.length - 1 && "$" == d[c].name) {
                    var e = b,
                        f = d[c + 1];
                    e.visible = !1, f.visible = !1, coin = G.makeImage(e.x + .05 * a, e.y - .05 * a, "coin"), coin.width = a, coin.height = a, e.parent.addChild(coin)
                }
            })
        }, G.OneLineText.prototype.setText = function(a) {
            Phaser.BitmapText.prototype.setText.call(this, a.toString());
            var b = this.scale.x,
                c = this.scale.y,
                d = this.alpha,
                e = this.angle;
            if (this.alpha = 1, this.scale.setTo(1), this.maxUserWidth)
                for (this.fontSize = this.orgFontSize, this.updateText(); this.width > this.maxUserWidth && (this.fontSize -= 1, this.updateText(), !(this.fontSize < 5)););
            !this.skipCaching && this.cacheAsBitmap && this.updateCache(), this.scale.setTo(b, c), this.alpha = d, this.angle = e
        }, G.OneLineText.prototype.popUpAnimation = function() {
            this.cacheAsBitmap = !1;
            for (var a = this.children.length, b = [], c = 0; c < a; c++) b[c] = c;
            b = Phaser.ArrayUtils.shuffle(b), delay_index = 0, this.activeTweens = 0, this.children.forEach(function(a) {
                0 == a.anchor.x && (a.x = a.x + .5 * a.width, a.y = a.y + a.height, a.anchor.setTo(.5, 1));
                var c = a.scale.x;
                a.scale.setTo(0, 0), this.activeTweens++;
                var d = game.add.tween(a.scale).to({
                    x: 1.5 * c,
                    y: 1.5 * c
                }, 200, Phaser.Easing.Quadratic.In, !1, 25 * b[delay_index]).to({
                    x: c,
                    y: c
                }, 200, Phaser.Easing.Sinusoidal.In);
                d.onComplete.add(function() {
                    this.activeTweens--, 0 == this.activeTweens && this.alive && !this.skipCaching && (this.cacheAsBitmap = !0)
                }, this), d.start(), delay_index++
            }, this)
        }, G.OneLineText.prototype.scaleOut = function() {
            this.cacheAsBitmap = !1, this.activeTweens = 0, this.children.forEach(function(a, b) {
                0 == a.anchor.x && (a.x = a.x + .5 * a.width, a.y = a.y + .5 * a.height, a.anchor.setTo(.5, .5)), this.activeTweens++, a.scale.setTo(a.scale.x, a.scale.y);
                var c = game.add.tween(a.scale).to({
                    x: 0,
                    y: 0
                }, 400, Phaser.Easing.Cubic.In, !1, 20 * b);
                c.onComplete.add(function() {
                    this.activeTweens--, 0 == this.activeTweens && this.destroy()
                }, this), c.start()
            }, this)
        }, G.OneLineCounter = function(a, b, c, d, e, f, g, h, i, j) {
            G.OneLineText.call(this, a, b, c, "", e, f, g, h), this.amount = d, this.amountDisplayed = d, this.amountMaxInterval = 5, this.amountMaxNegInterval = -5, this.absoluteDisplay = !1, this.fixedToDecimal = 0, this.stepCurrent = 0, this.step = 0, this.preText = i || "", this.postText = j || "", this.setText(this.preText + d + this.postText)
        }, G.OneLineCounter.prototype = Object.create(G.OneLineText.prototype), G.OneLineCounter.prototype.update = function() {
            if (this.lerp) this.lerpUpdate();
            else if (this.amountDisplayed != this.amount && this.stepCurrent-- <= 0 && (this.stepCurrent = this.step, this.amountDisplayed != this.amount)) {
                var a = this.amount - this.amountDisplayed;
                this.amountDisplayed += game.math.clamp(a, this.amountMaxNegInterval, this.amountMaxInterval);
                var b = this.amountDisplayed;
                this.absoluteDisplay && (b = Math.abs(b)), 0 != this.fixedTo && (b = b.toFixed(this.fixedToDecimal)), this.setText(this.preText + b + this.postText)
            }
        }, G.OneLineCounter.prototype.changeAmount = function(a) {
            this.amount = a
        }, G.OneLineCounter.prototype.increaseAmount = function(a) {
            this.amount += a
        }, G.OneLineCounter.prototype.changeIntervals = function(a, b) {
            void 0 === b ? (this.amountMaxInterval = a, this.amountMaxNegInterval = -a) : (this.amountMaxInterval = a, this.amountMaxNegInterval = b)
        }, G.OneLineCounter.prototype.lerpUpdate = function() {
            this.amountDisplayed != this.amount && this.stepCurrent-- <= 0 && (this.stepCurrent = this.step, this.amountDisplayed = Math.round(G.lerp(this.amountDisplayed, this.amount, .5, .6)), this.setText(this.amountDisplayed.toString()))
        }, G.PartCacher = function() {
            Phaser.Group.call(this, game), this.active = !1, this.every = 1, this.rt = game.add.renderTexture(10, 10), this.frameCounter = 0, this.framesToRecord = null
        }, G.PartCacher.prototype = Object.create(Phaser.Group.prototype), G.PartCacher.prototype.update = function() {
            if (this.active) {
                if (this.stepForward(), !this.checkChildren()) return this.active = !1, void this.removeAll(!0, !0);
                this.frameCounter % this.frameRate == 0 && (this.saveFrame(), this.frameNr++, null !== this.framesToRecord && (this.framesToRecord--, 0 == this.framesToRecord && (this.active = !1))), this.frameCounter++
            }
        }, G.PartCacher.prototype.stepForward = function() {
            for (var a = this.children.length; a--;) this.children[a].update()
        }, G.PartCacher.prototype.start = function(a, b, c) {
            this.fileName = a, this.frameNr = 0, this.frameRate = 60 / b, this.active = !0, this.frameCounter = 0, this.framesToRecord = c || null
        }, G.PartCacher.prototype.saveFrame = function() {
            var a = this.getBounds(),
                b = Math.max(this.x - a.x, a.x + a.width - this.x, 400),
                c = Math.max(this.y - a.y, a.y + a.height - this.y, 400);
            this.rt.resize(2 * b, 2 * c, !0), this.rt.renderXY(this, b, c, !0);
            var d = this.rt.getCanvas(),
                e = this.fileName + "_" + this.frameNr;
            d.toBlob(function(a) {
                saveAs(a, e)
            })
        }, G.PartCacher.prototype.checkChildren = function() {
            var a = this.children.filter(function(a) {
                return !a.alive || 0 === a.alpha || 0 == a.scale.x || 0 == a.scale.y
            });
            return this.children.length !== a.length
        }, G.PoolGroup = function(a, b, c, d) {
            if (Phaser.Group.call(this, game), this._deadArray = [], this._elementConstructor = a, this._argumentsArray = b || [], this._argumentsArray.unshift(null), c && G.sb(c).add(this.init, this), d)
                for (var e = 0; e < d; e++) element = new(Function.prototype.bind.apply(this._elementConstructor, this._argumentsArray)), this.add(element), element.events.onKilled.add(this._onElementKilled, this), element.kill()
        }, G.PoolGroup.prototype = Object.create(Phaser.Group.prototype), G.PoolGroup.prototype.getFreeElement = function() {
            var a;
            return 0 < this._deadArray.length ? a = this._deadArray.pop() : (a = new(Function.prototype.bind.apply(this._elementConstructor, this._argumentsArray))).events.onKilled.add(this._onElementKilled, this), this.add(a), a
        }, G.PoolGroup.prototype._onElementKilled = function(a) {
            this === a.parent && (this._deadArray.push(a), this.removeChild(a))
        }, G.PoolGroup.prototype.init = function() {
            var a = this.getFreeElement();
            return a.init.apply(a, arguments), a
        }, G.PoolGroup.prototype.initBatch = function(a) {
            for (var b = 0; b < a; b++) this.init.apply(this, [].slice.call(arguments, 1))
        }, G.PreloaderBar = function() {
            Phaser.Group.call(this, game), this.fixedToCamera = !0, this.softgamesBtn = game.add.button(0, 200, "sg_logo", function() {
                SG_Hooks.triggerMoreGames()
            }, this), this.softgamesBtn.anchor.setTo(.5, .5), this.add(this.softgamesBtn), this.gfx = game.add.graphics(), this.add(this.gfx), this.drawProgress(0), G.sb("onScreenResize").add(this.onResize, this), this.onResize(), game.load.onFileComplete.add(this.drawProgress, this)
        }, G.PreloaderBar.prototype = Object.create(Phaser.Group.prototype), G.PreloaderBar.prototype.onResize = function() {
            this.cameraOffset.x = .5 * game.width, this.cameraOffset.y = .4 * game.height
        }, G.PreloaderBar.prototype.drawProgress = function(a) {
            this.gfx.clear(), this.gfx.lineStyle(2, 16777215, 1), this.gfx.beginFill(0, 1), this.gfx.drawRect(-150, 0, 300, 50), this.gfx.beginFill(16777215, 1), this.gfx.drawRect(-145, 5, a / 100 * 290, 40)
        }, G.ProgressBar = function(a, b, c, d, e, f, g) {
            G.Image.call(this, a, b, c + "_empty", 0, null), f = void 0 === f ? 0 : f, g = void 0 === g ? 0 : f, this.fill = G.makeImage(f, g, c + "_full", 0, this), this.fillFullWidth = this.fill.width, this.fillOverlay = G.makeImage(f, g, c + "_full_overlay", this.fill, this), this.fillOverlay.alpha = 0, this.fill.cropRect = new Phaser.Rectangle(0, 0, 0, this.fill.height), this.fill.updateCrop(), this.currentValue = d, this.prevCurrentValue = d, this.targetValue = d, this.maxValue = e, this.lerpValue = .05, this.updateBarCrop(), this.onTargetReached = new Phaser.Signal, this.onBarFilled = new Phaser.Signal
        }, G.ProgressBar.prototype = Object.create(G.Image.prototype), G.ProgressBar.prototype.update = function() {
            this.currentValue !== this.targetValue && (this.currentValue = G.lerp(this.currentValue, this.targetValue, this.lerpValue, .005 * this.maxValue), this.currentValue === this.targetValue && this.onTargetReached.dispatch()), this.currentValue !== this.prevCurrentValue && (this.updateBarCrop(), this.currentValue === this.maxValue && (game.add.tween(this.fillOverlay).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0), this.onBarFilled.dispatch(), this.label && game.add.tween(this.label).to({
                alpha: 0
            }, 600, Phaser.Easing.Sinusoidal.InOut, !0)), this.label && Math.floor(this.currentValue) !== Math.floor(this.prevCurrentValue) && (console.log("updating label"), this.label.updateValue(Math.floor(this.currentValue)))), this.prevCurrentValue = this.currentValue
        }, G.ProgressBar.prototype.updateBarCrop = function() {
            var a = this.fill.cropRect.width,
                b = Math.round(this.fillFullWidth * (this.currentValue / this.maxValue));
            a !== b && (this.fill.cropRect.width = b, this.fill.updateCrop())
        }, G.ProgressBar.prototype.changeCurrentValue = function(a, b) {
            this.targetValue = game.math.clamp(a, 0, this.maxValue), this.lerpValue = b || this.lerpValue
        }, G.ProgressBar.prototype.increaseCurrentValue = function(a) {
            this.changeCurrentValue(this.targetValue + (a || 1))
        }, G.ProgressBar.prototype.decreaseCurrentValue = function(a) {
            this.changeCurrentValue(this.targetValue - (a || 1))
        }, G.ProgressBar.prototype.changeValues = function(a, b) {
            this.currentValue = a, this.prevCurrentValue = a, this.targetValue = a, this.maxValue = b, this.label && this.label.changeValues(a, b), this.updateBarCrop()
        }, G.ProgressBar.prototype.addLabel = function(a, b) {
            this.label = new G.ProgressBar.Label(G.rl(.5 * this.width), G.rl(.5 * this.height), this.currentValue, this.maxValue, Math.floor(.6 * G.rl(this.height)), G.rl(.7 * this.width), a, b), this.add(this.label)
        }, G.ProgressBar.Label = function(a, b, c, d, e, f, g, h) {
            G.OneLineText.call(this, a, b, "font", "", e, f, .5, .5), this.labelType = g || 0, this.labelType1Text = G.txt("%AMOUNT% left"), this.currentValue = c, this.maxValue = d, this.animationOnIncrease = h || !1, this.updateValue(this.currentValue, !0)
        }, G.ProgressBar.Label.prototype = Object.create(G.OneLineText.prototype), G.ProgressBar.Label.prototype.updateValue = function(a, b) {
            !b && Math.min(a, this.maxValue) === this.currentValue || (this.currentValue = a, this.updateLabelText(), !b && this.animationOnIncrease && (G.stopTweens(this), this.scale.setTo(1), game.add.tween(this.scale).to({
                x: 1.2,
                y: 1.2
            }, 200, Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0)))
        }, G.ProgressBar.Label.prototype.changeValues = function(a, b) {
            this.currentValue = a, this.maxValue = b, this.alpha = this.currentValue < this.maxValue ? 1 : 0, this.updateLabelText()
        }, G.ProgressBar.Label.prototype.updateLabelText = function() {
            this.setText(0 == this.labelType ? this.currentValue + "/" + this.maxValue : this.labelType1Text.replace("%AMOUNT%", this.maxValue - this.currentValue))
        }, void 0 === G && (G = {}), G.SignalBox = function() {
            function b() {
                Object.keys(a).forEach(function(b) {
                    a[b].removeNonPermanent()
                })
            }
    
            function c(c) {
                return game.state.onStateChange.add(b, this), a[c] || (a[c] = new Phaser.Signal), a[c]
            }
            Phaser.Signal.prototype.addPermanent || (Phaser.Signal.prototype.addPermanent = function() {
                var a = this.add.apply(this, arguments);
                return a._PERMANENT = !0, a
            }, Phaser.Signal.prototype.removeNonPermanent = function() {
                if (this._bindings)
                    for (var a = this._bindings.length; a--;) this._bindings[a]._PERMANENT || (this._bindings[a]._destroy(), this._bindings.splice(a, 1))
            });
            var a = {};
            return c.signals = a, c.clearNonPermanent = b, c.clearAll = function() {
                Object.keys(a).forEach(function(b) {
                    a[b].removeAll()
                })
            }, c
        }(), G.Slider = function(a, b, c, d) {
            Phaser.Graphics.call(this, game, a, b), this.sliderWidth = c, this.pos = d, this.beginFill(0, 1), this.drawRect(0, -2, this.sliderWidth, 4), this.circleGfx = this.addChild(game.make.graphics(c * d, 0)), this.circleGfx.clear(), this.circleGfx.lineStyle(1, 0, 1), this.circleGfx.beginFill(10066329, 1), this.circleGfx.drawCircle(0, 0, 32), this.circleGfx.sliderWidth = c, this.circleGfx.inputEnabled = !0, this.circleGfx.input.useHandCursor = !0, this.circleGfx.input.draggable = !0, this.circleGfx.input.setDragLock(!0, !1)
        }, G.Slider.prototype = Object.create(Phaser.Graphics.prototype), G.Slider.prototype.update = function() {
            this.circleGfx.x = game.math.clamp(this.circleGfx.x, 0, this.sliderWidth), this.pos = this.circleGfx.x / this.sliderWidth
        }, G.SliderPanel = function(a, b, c, d, e, f) {
            Phaser.Group.call(this, game), this.sliderWidth = G.l(c), this.sliderHeight = G.l(d), this.x = a + -.5 * this.sliderWidth, this.y = b + -.5 * this.sliderHeight, this.gfxMask = game.add.graphics(), this.gfxMask.beginFill(0, 1), this.gfxMask.drawRect(0, 0, c, d), this.clickableObjects = [], this.config = f, this.applyConfig(this.config), this.addContent(e), this.add(this.gfxMask), this.contentGroup.mask = this.gfxMask, this.slideY = 0, this.inputSprite = G.makeImage(0, 0, null, 0, this), this.inputSprite.inputEnabled = !0, this.inputSprite.hitArea = new Phaser.Rectangle(0, 0, c, d), this.inputSpriteDown = !1, this.inputData = {
                x: null,
                y: null,
                velX: 0,
                velY: 0,
                xStart: null,
                yStart: null,
                startFrameStamp: null,
                clickDistanceWindow: 10,
                clickTimeWindow: 10
            }, this.inputSprite.events.onInputDown.add(function() {
                var b = game.input.activePointer;
                this.inputSpriteDown = !0, this.inputData.x = this.inputData.xStart = b.worldX, this.inputData.y = this.inputData.yStart = b.worldY, this.inputData.startFrameStamp = this.frameCounter
            }, this), this.inputSprite.events.onInputUp.add(function() {
                var a = game.input.activePointer;
                this.inputSpriteDown = !1;
                var b = game.math.distance(this.inputData.xStart, this.inputData.yStart, a.worldX, a.worldY),
                    c = this.frameCounter - this.inputData.startFrameStamp;
                b <= this.inputData.clickDistanceWindow && c <= this.inputData.clickTimeWindow && (this.propagateClick(a.x, a.y), this.inputData.velX = 0, this.inputData.velY = 0)
            }, this), this.frameCounter = 0
        }, G.SliderPanel.prototype = Object.create(Phaser.Group.prototype), G.SliderPanel.prototype.applyConfig = function(a) {
            this.horizontal = a.horizontal || !1, this.horizontalLerp = a.horizontalLerp || !1, this.vertical = a.vertical || !0, this.verticalLerp = a.verticalLerp
        }, G.SliderPanel.prototype.addContent = function(a) {
            this.changeInputSettings(a), this.contentGroup = a, this.add(a), this.contentGroup.x = 0, this.contentGroupMinY = -this.contentGroup.height + this.sliderHeight, this.contentGroupMaxY = 0, this.contentGroupMinX = this.sliderWidth - this.contentGroup.width, this.contentGroupMaxX = 0
        }, G.SliderPanel.prototype.changeInputSettings = function(a) {
            for (var b = a.children.length; b--;) {
                var c = a.children[b];
                c.inputEnabled && (this.clickableObjects.push(c), c.inputEnabled = !1), 0 < c.children.length && this.changeInputSettings(c)
            }
        }, G.SliderPanel.prototype.update = function() {
            if (this.frameCounter++, this.inputSpriteDown && game.input.activePointer.isDown) {
                var a = this.inputData.x - game.input.activePointer.worldX,
                    b = this.inputData.y - game.input.activePointer.worldY;
                this.inputData.x = game.input.activePointer.worldX, this.inputData.y = game.input.activePointer.worldY, this.inputData.velX = .8 * a + .2 * this.inputData.velX, this.inputData.velY = .8 * b + .2 * this.inputData.velY, this.horizontal && (this.contentGroup.x -= this.inputData.velX), this.vertical && (this.contentGroup.y -= this.inputData.velY)
            } else this.horizontal && (this.contentGroup.x -= this.inputData.velX, this.inputData.velX *= .95, Math.abs(this.inputData.velX) < 1 && (this.inputData.velX = 0)), this.vertical && (this.contentGroup.y -= this.inputData.velY, this.inputData.velY *= .95, Math.abs(this.inputData.velY) < 1 && (this.inputData.velY = 0));
            this.vertical && this.boundRestrict("y", this.verticalLerp, this.contentGroupMinY, this.contentGroupMaxY), this.horizontal && this.boundRestrict("x", this.horizontalLerp, this.contentGroupMinX, this.contentGroupMaxX), this.boundRestrict()
        }, G.SliderPanel.prototype.propagateClick = function(a, b) {
            for (var c = 0; c < this.clickableObjects.length; c++)
                if (this.clickableObjects[c].visible && this.clickableObjects[c].getBounds().contains(a, b)) {
                    this.clickableObjects[c].onInputDown.dispatch();
                    break
                }
        }, G.SliderPanel.prototype.boundRestrict = function(a, b, c, d) {
            b ? (this.contentGroup[a] > d && (this.contentGroup[a] = G.lerp(this.contentGroup[a], d, .5), this.contentGroup[a] < d + 1 && (this.contentGroup[a] = d)), this.contentGroup[a] < c && (this.contentGroup[a] = G.lerp(this.contentGroup[a], c, .2), this.contentGroup[a] > c - 1 && (this.contentGroup[a] = c))) : this.contentGroup[a] = game.math.clamp(this.contentGroup[a], c, d)
        }, G.StrObjGroup = function(a, b, c) {
            Phaser.Group.call(this, game), this.x = a || 0, this.y = b || 0, this.importObj = "string" == typeof c ? JSON.parse(c) : c, this.parseImportObj(this.importObj)
        }, G.StrObjGroup.prototype = Object.create(Phaser.Group.prototype), G.StrObjGroup.prototype.parseImportObj = function(a) {
            for (var b = 0; b < a.length; b++) {
                var c = a[b],
                    d = G.makeImage(c.x, c.y, c.frame, c.anchor, this);
                d.scale.setTo(c.scale[0], c.scale[1]), d.angle = c.angle
            }
        }, G.Text = function(a, b, c, d, e, f, g, h, i) {
            "object" != typeof d && (d = JSON.parse(JSON.stringify(G.Text.styles[d]))), this.userMaxWidth = f || 1 / 0, this.userMaxHeight = g || 1 / 0, h && (d.wordWrap = !0, d.wordWrapWidth = f, d.align = i || "left"), Phaser.Text.call(this, game, a, b, c, d), d.lineSpacing && (this.lineSpacing = d.lineSpacing), e && ("number" == typeof e ? this.anchor.setTo(e) : this.anchor.setTo(e[0], e[1])), this.width = Math.min(this.width, this.userMaxWidth), this.height = Math.min(this.height, this.userMaxHeight)
        }, G.Text.prototype = Object.create(Phaser.Text.prototype), G.Text.styles = {}, G.Text.addStyle = function(a, b) {
            G.Text.styles[a] = b
        }, G.Text.prototype.setText = function(a) {
            Phaser.Text.prototype.setText.call(this, a), this.scale.setTo(1), this.width = Math.min(this.width, this.userMaxWidth), this.height = Math.min(this.height, this.userMaxHeight)
        }, G.TextCounter = function(a, b, c, d, e, f, g) {
            this.amount = c, this.amountDisplayed = c, G.Text.call(this, a, b, null === c ? "..." : c.toString(), d, e, f), g = g || {
                lerpValue: .5
            }, this.lerp = !0, this.lerpValue = g.lerpValue, this.stepCurrent = 0, this.step = 0
        }, G.TextCounter.prototype = Object.create(G.Text.prototype), G.TextCounter.prototype.setAmount = function(a, b) {
            this.amount = a, b && (this.amountDisplayed = a, this.setText(this.amountDisplayed.toString()))
        }, G.TextCounter.prototype.changeAmount = function(a, b) {
            this.amount += a, b && (this.amountDisplayed = this.amount, this.setText(this.amountDisplayed.toString()))
        }, G.TextCounter.prototype.update = function() {
            this.amountDisplayed != this.amount && this.stepCurrent-- <= 0 && (this.stepCurrent = this.step, this.lerp && this.lerpUpdate())
        }, G.TextCounter.prototype.lerpUpdate = function() {
            this.amountDisplayed = G.lerp(this.amountDisplayed, this.amount, this.lerpValue, .2), this.setText(Math.round(this.amountDisplayed).toString())
        }, G.TextRTCacher = function() {}, G.TextRTCacher.prototype.cacheText = function(a, b, c, d, e) {
            this.txt || (this.txt = game.make.bitmapText(0, 0, a, "", 80)), this.txt.fontSize = c, this.txt.setText(b), this.txt.tint = e || 16777215, this.txt.updateCache(), game.make.renderTexture(this.txt.width, this.txt.height, d, !0).render(this.txt)
        }, G.TextRTCacher.prototype.cachePhaserText = function(a, b, c) {
            var d = game.make.text(0, 0, a, c);
            game.make.renderTexture(d.width, d.height, b, !0).render(d), d.destroy()
        }, G.Timer = function(a, b, c, d, e, f, g) {
            G.OneLineText.call(this, a, b, c, "???", d, e, f, g), this.secLeft = 0, this.active = !1, this.timerBinding = G.sb("onWallClockTimeUpdate").add(this.updateTimer, this), this.events.onDestroy.add(function() {
                this.timerBinding.detach()
            }, this)
        }, G.Timer.prototype = Object.create(G.OneLineText.prototype), G.Timer.prototype.updateTimer = function() {
            this.active && (G.sfx.clock_tick.play(), this.secLeft = Math.max(0, this.secLeft - 1), this.setText(G.changeSecToTimerFormat(this.secLeft)))
        }, G.Timer.prototype.setSecLeft = function(a) {
            this.secLeft = a, this.setText(G.changeSecToTimerFormat(this.secLeft))
        }, G.Timer.prototype.start = function() {
            this.active = !0
        }, G.TimerT = function(a, b, c, d, e, f, g, h) {
            G.Text.call(this, a, b, "???", d, e, f), this.secLeft = 0, this.active = !1, this.timerFormat = g, this.dots = !0, this.sfx = h ? G.sfx[sfs] : null, this.timerBinding = G.sb("onWallClockTimeUpdate").add(this.updateTimer, this), this.events.onDestroy.add(function() {
                this.timerBinding.detach()
            }, this), c && this.setDate(c)
        }, G.TimerT.prototype = Object.create(G.Text.prototype), G.TimerT.prototype.updateTimer = function() {
            this.active && (this.sfx && this.sfx.play(), this.secLeft = Math.max(0, this.secLeft - 1), this.updateTimerText(this.secLeft, this.dots), this.dots = !this.dots)
        }, G.TimerT.prototype.setSecLeft = function(a) {
            this.secLeft = Math.max(0, a), this.updateTimerText(this.secLeft, !0)
        }, G.TimerT.prototype.updateTimerText = function(a, b) {
            var c = G.changeSecToDHMS(this.secLeft),
                d = []; - 1 < this.timerFormat.indexOf("d") && d.push(c[0]), -1 < this.timerFormat.indexOf("h") && d.push(c[1]), -1 < this.timerFormat.indexOf("m") && d.push(c[2]), -1 < this.timerFormat.indexOf("s") && d.push(c[3]), this.setText(d.join(b ? ":" : " "))
        }, G.TimerT.prototype.start = function() {
            this.active = !0
        }, G.TimerT.prototype.setDate = function(a) {
            var b = new Date(a).getTime(),
                c = Date.now(),
                d = Math.ceil((b - c) / 1e3);
            this.setSecLeft(d), this.active = !0
        }, G.UITargetParticles = function() {
            G.PoolGroup.call(this, G.UITargetParticle), this.fixedToCamera = !0
        }, G.UITargetParticles.prototype = Object.create(G.PoolGroup.prototype), G.UITargetParticles.prototype.initPart = function(a, b, c, d, e) {
            return this.init(a, b, c, d, e)
        }, G.UITargetParticles.prototype.createDividedBatch = function(a, b, c, d, e, f) {
            var g = new G.UITargetParticles.BatchObj,
                h = h || 25;
            h < e / f && (f = Math.ceil(e / h));
            for (var i = Math.floor(e / f) + Math.sign(e % f), j = 0; j < i; j++) {
                var k = this.init(a, b, c, d, Math.min(f, e));
                e -= f, g.add(k)
            }
            return g
        }, G.UITargetParticles.prototype.createBatch = function(a, b, c, d, e, f) {
            for (var g = new G.UITargetParticles.BatchObj, h = Array.isArray(a), i = 0; i < f; i++) {
                if (h) var j = this.init(a[i].x, a[i].y, c, d, e);
                else j = this.init(a, b, c, d, e);
                g.add(j)
            }
            return g
        }, G.UITargetParticles.BatchObj = function() {
            this.parts = [], this.nrOfParts = 0, this.nrOfFinished = 0, this.onFinish = new Phaser.Signal
        }, G.UITargetParticles.BatchObj.prototype.add = function(a) {
            this.parts.push(a), a.onFinish.addOnce(this.onPartFinish, this), this.nrOfParts++
        }, G.UITargetParticles.BatchObj.prototype.onPartFinish = function() {
            this.nrOfFinished++, this.nrOfFinished == this.nrOfParts && this.onFinish.dispatch()
        }, G.UITargetParticles.BatchObj.prototype.addOnPartStart = function(a, b) {
            this.parts.forEach(function(c) {
                c.onStart.addOnce(a, b || c, 1)
            })
        }, G.UITargetParticles.BatchObj.prototype.addOnPartFinish = function(a, b) {
            this.parts.forEach(function(c) {
                c.onFinish.addOnce(a, b || c, 1)
            })
        }, G.UITargetParticles.BatchObj.prototype.start = function(a) {
            var b = 0;
            this.parts.forEach(function(c) {
                c.start(b), b += a || 0
            })
        }, G.UITargetParticle = function() {
            G.Image.call(this, 0, 0, null, .5), this.onStart = new Phaser.Signal, this.onFinish = new Phaser.Signal, this.speed = 0, this.speedMax = 30, this.speedDelta = .75, this.vel = new Phaser.Point(0, 0), this.velInit = new Phaser.Point(0, 0), this.kill()
        }, G.UITargetParticle.prototype = Object.create(G.Image.prototype), G.UITargetParticle.prototype.init = function(a, b, c, d, e) {
            this.position.setTo(a, b), this.changeTexture(c), this.onStart.removeAll(), this.onFinish.removeAll(), this.carriedValue = e || 1, this.targetObj = d, this.stopTweens(this), this.scale.setTo(1), this.alpha = 1, this.speed = 0, this.vel.setTo(0, 0)
        }, G.UITargetParticle.prototype.start = function(a) {
            a ? game.time.events.add(a, this.start, this) : (this.revive(), this.onStart.dispatch(this, this.carriedValue))
        }, G.UITargetParticle.prototype.update = function() {
            if (this.alive) {
                this.position.add(this.vel.x, this.vel.y), this.vel.x *= .95, this.vel.y *= .95, this.speed += this.speedDelta, this.speed = Math.min(this.speed, this.speedMax);
                var a = Phaser.Point.distance(this.worldPosition, this.targetObj.worldPosition),
                    b = Phaser.Point.angle(this.targetObj.worldPosition, this.worldPosition);
                this.position.add(G.lengthDirX(b, Math.min(a, this.speed), !0), G.lengthDirY(b, Math.min(a, this.speed), !0)), a < 1.2 * this.speedMax && (this.onFinish.dispatch(this, this.carriedValue), this.kill())
            }
        }, void 0 === G && (G = {}), Math.sign = Math.sign || function(a) {
            return 0 === (a = +a) || isNaN(a) ? a : 0 < a ? 1 : -1
        }, G.isImageInCache = function(a) {
            return "" != this.checkSheet(a) || game.cache.checkImageKey(a)
        }, G.checkSheet = function(a) {
            return G.spritesheetMap ? G.spritesheetMap[a] || "" : this.checkSheetOld()
        }, G.checkSheetOld = function() {
            for (var a = 0, b = G.ASSETS.spritesheets.length; a < b; a++)
                if (G.ASSETS.spritesheets[a], game.cache.checkImageKey(G.ASSETS.spritesheets[a]) && game.cache.getFrameData(G.ASSETS.spritesheets[a]).getFrameByName(frame)) return G.ASSETS.spritesheets[a];
            return ""
        }, G.lerp = function(a, b, c, d) {
            return d && Math.abs(a - b) <= d ? b : a + c * (b - a)
        }, G.l = function(a) {
            return Math.floor(a * G.Loader.currentConfigMulti)
        }, G.rl = function(a) {
            return Math.floor(a * (1 / G.Loader.currentConfigMulti))
        }, G.lnf = function(a) {
            return a * G.Loader.currentConfigMulti
        }, G.rnd = function(a, b) {
            return game.rnd.realInRange(a || 0, b || 1)
        }, G.rndInt = function(a, b) {
            return game.rnd.between(a, b)
        }, G.changeTexture = function(a, b) {
            if ("string" != typeof b) return a.loadTexture(b);
            var c = this.checkSheet(b);
            "" == c ? a.loadTexture(b) : a.loadTexture(c, b)
        }, G.txt = function(a) {
            return G.lang || (G.lang = "en"), G.json.languages[G.lang] || (G.lang = "en"), G.json.languages[G.lang][a] || a + "***"
        }, G.deltaTime = 1, G.delta = function() {
            G.deltaTime = Math.min(1.5, game.time.elapsedMS / 16), 17 == game.time.elapsedMS && (G.deltaTime = 1)
        }, G.rotatePositions = function(a) {
            for (var b = [], c = 0, d = a.length; c < d; c += 2) b.push(-1 * a[c + 1], a[c]);
            return b
        }, G.loadTexture = G.changeTexture, G.makeImage = function(a, b, c, d, e) {
            var f, g = this.checkSheet(c);
            return f = "" == g ? game.make.image(this.l(a), this.l(b), c) : game.make.image(this.l(a), this.l(b), g, c), d && ("number" == typeof d ? f.anchor.setTo(d) : f.anchor.setTo(d[0], d[1])), e ? (e.add || e.addChild).call(e, f) : null !== e && game.world.add(f), f
        }, G.capitalize = function(a) {
            return a.charAt(0).toUpperCase() + a.slice(1)
        }, G.lengthDirX = function(a, b, c) {
            return (c = c || !1) ? Math.cos(a) * b : Math.cos(game.math.degToRad(a)) * b
        }, G.lengthDirY = function(a, b, c) {
            return (c = c || !1) ? Math.sin(a) * b : Math.sin(game.math.degToRad(a)) * b
        }, G.stopTweens = function(a) {
            game.tweens._add.forEach(function(b) {
                a.scale && b.target == a.scale && b.stop(), b.target == a && b.stop()
            }), game.tweens._tweens.forEach(function(b) {
                a.scale && b.target == a.scale && b.stop(), b.target == a && b.stop()
            })
        }, G.makeExtImage = function(a, b, c, d, e, f, g, h) {
            var i;
            if (G.extLoader || (G.extLoader = new G.ExtLoader(game)), G.extLoader.loadedUrls[c]) return i = G.makeImage(a, b, G.extLoader.loadedUrls[c], e, f), h.call(i), i;
            (i = G.makeImage(a, b, d, e, f)).onImgLoaded = new Phaser.Signal, G.extImagesKeys || (G.extImagesKeys = []);
            var j = "extImgBlankName" + G.extImagesKeys.length;
            G.extImagesKeys.push(j);
            var k = G.extLoader.onFileComplete.add(function(a, b, d) {
                b == j && d && (G.extLoader.loadedUrls[c] = j, null !== i.game && (G.changeTexture(i, j), h && h.call(i)), k.detach())
            });
            return G.extLoader.image(j, c, !0), i
        }, G.drawCircleSegment = function(a, b, c, d, e, f, g) {
            if (e === f) return a;
            void 0 === g && (g = 10);
            var h = (f - e) / g;
            a.moveTo(b, c);
            for (var i = a.currentPath.shape.points; e <= f; e += h) i.push(Math.floor(b + G.lengthDirX(e, d, !1)), Math.floor(c + G.lengthDirY(e, d, !1)));
            return i.push(Math.floor(b + G.lengthDirX(f, d, !1)), Math.floor(c + G.lengthDirY(f, d, !1))), a.dirty = !0, a._boundsDirty = !0, a
        }, G.centerElements = function(a, b, c) {
            void 0 === c && (c = 0), void 0 === b && (b = []);
            var d = 0,
                e = Array.isArray(b);
            a.forEach(function(a, c) {
                d += a.width, (e ? b[c - 1] : void 0 !== b) && (d += G.l(e ? b[c - 1] : b))
            });
            var f = c + -.5 * d;
            a.forEach(function(a, c) {
                a.x = f, a.x += a.width * a.anchor.x, f += a.width, (e ? b[c - 1] : void 0 !== b) && (f += G.l(e ? b[c] : b))
            })
        }, G.centerElements2 = function(a, b, c) {
            void 0 === c && (c = 0), void 0 === b && (b = 0);
            var d = 0;
            a.forEach(function(a) {
                d += a.width
            }), d += b * (a.length - 1), a.forEach(function(a, e, f) {
                a.left = 0 == e ? c + -.5 * d : f[e - 1].right + b
            })
        }, G.makeMover = function(a) {
            void 0 !== G.activeMover && (G.activeMover.destroy(), G.activeMover.eKey.onDown.removeAll()), G.activeMover = game.add.image(), G.activeMover.obj = a, G.activeMover.cursors = game.input.keyboard.createCursorKeys(), G.activeMover.shiftKey = game.input.keyboard.addKey(Phaser.Keyboard.SHIFT), G.activeMover.eKey = game.input.keyboard.addKey(Phaser.Keyboard.E), G.activeMover.eKey.onDown.add(function() {}, G.activeMover), G.activeMover.update = function() {
                var b = this.shiftKey.isDown ? 10 : 2;
                this.cursors.down.isDown && (a.y += b), this.cursors.up.isDown && (a.y -= b), this.cursors.left.isDown && (a.x -= b), this.cursors.right.isDown && (a.x += b)
            }
        }, G.makeLineEditor = function(a) {
            var b = game.add.group();
            return b.interpolation = a || "linear", b.pointsX = [0], b.pointsY = [0], b.gfx = b.add(game.make.graphics()), b.shiftKey = game.input.keyboard.addKey(Phaser.Keyboard.SHIFT), b.wKey = game.input.keyboard.addKey(Phaser.Keyboard.W), b.wKey.onDown.add(function() {
                var a, b;
                b = 2 < this.children.length ? (a = this.children[this.children.length - 1].x, this.children[this.children.length - 1].y) : a = 0;
                var c = G.makeImage(a, b, "candy_1");
                c.anchor.setTo(.5), c.scale.setTo(.1), this.add(c), this.activeObject = c, this.changed = !0
            }, b), b.qKey = game.input.keyboard.addKey(Phaser.Keyboard.Q), b.qKey.onDown.add(function() {
                this.children.length <= 2 || (this.removeChildAt(this.children.length - 1), this.activeObject = 3 < this.children.length ? this.children[this.children.length - 1] : null, this.changed = !0)
            }, b), b.aKey = game.input.keyboard.addKey(Phaser.Keyboard.A), b.aKey.onDown.add(function() {
                if (this.activeObject) {
                    var a = this.getChildIndex(this.activeObject);
                    2 != a && (this.activeObject = this.getChildAt(a - 1))
                }
            }, b), b.sKey = game.input.keyboard.addKey(Phaser.Keyboard.S), b.sKey.onDown.add(function() {
                if (this.activeObject) {
                    var a = this.getChildIndex(this.activeObject);
                    a != this.children.length - 1 && (this.activeObject = this.getChildAt(a + 1))
                }
            }, b), b.eKey = game.input.keyboard.addKey(Phaser.Keyboard.E), b.eKey.onDown.add(function() {
                console.log(JSON.stringify([this.pointsX, this.pointsY]))
            }, b), b.cursors = game.input.keyboard.createCursorKeys(), b.activeObject = null, b.preview = G.makeImage(0, 0, "candy_2", .5, b), b.preview.width = 8, b.preview.height = 8, b.preview.progress = 0, b.update = function() {
                if (null !== this.activeObject && (this.forEach(function(a) {
                        a.alpha = a == this.activeObject ? 1 : .5
                    }, this), 0 != this.children.length)) {
                    var a = this.shiftKey.isDown ? 3 : 1;
                    if (this.cursors.down.isDown && (this.activeObject.y += a, this.changed = !0), this.cursors.up.isDown && (this.activeObject.y -= a, this.changed = !0), this.cursors.left.isDown && (this.activeObject.x -= a, this.changed = !0), this.cursors.right.isDown && (this.activeObject.x += a, this.changed = !0), b.preview.progress += .01, 1 < b.preview.progress && (b.preview.progress = 0), b.preview.x = game.math[this.interpolation + "Interpolation"](this.pointsX, b.preview.progress), b.preview.y = game.math[this.interpolation + "Interpolation"](this.pointsY, b.preview.progress), this.changed) {
                        var c = [],
                            d = [];
                        this.pointsX = c, this.pointsY = d, this.children.forEach(function(a, b) {
                            b <= 1 || (c.push(a.x), d.push(a.y))
                        }), this.gfx.clear(), this.gfx.beginFill(16711680, 1);
                        for (var e = 0; e < 200; e++) this.gfx.drawRect(game.math[this.interpolation + "Interpolation"](c, e / 200), game.math[this.interpolation + "Interpolation"](d, e / 200), 3, 3)
                    }
                }
            }, b
        }, G.lineUtils = {
            getWholeDistance: function(a, b) {
                for (var c = 0, d = 1; d < a.length; d++) c += game.math.distance(a[d - 1], b[d - 1], a[d], b[d]);
                return c
            },
            findPointAtDitance: function(a, b, c) {
                for (var d = 0, e = 1; e < a.length; e++) {
                    var f = game.math.distance(a[e - 1], b[e - 1], a[e], b[e]);
                    if (c < f + d) {
                        var g = game.math.angleBetween(a[e - 1], b[e - 1], a[e], b[e]);
                        return [a[e - 1] + G.lengthDirX(g, c - d, !0), b[e - 1] + G.lengthDirY(g, c - d, !0)]
                    }
                    d += f
                }
                return [a[a.length - 1], b[b.length - 1]]
            },
            spreadAcrossLine: function(a, b, c, d, e) {
                for (var f = this.getWholeDistance(a, b) / (c.length - 1), g = 0; g < c.length; g++) {
                    var h = this.findPointAtDitance(a, b, f * g);
                    c[g][d || "x"] = h[0], c[g][e || "y"] = h[1]
                }
            },
            spreadOnNodes: function(a, b, c, d, e) {
                for (var f = 0; f < a.length; f++) {
                    if (void 0 === c[f]) return;
                    c[f][d || "x"] = a[f], c[f][e || "y"] = b[f]
                }
            }
        }, G.changeSecToTimerFormat = function(a, b) {
            var c = parseInt(a, 10),
                d = !!b && -1 !== b.toUpperCase().indexOf("D"),
                e = !!b && -1 !== b.toUpperCase().indexOf("H"),
                f = Math.floor(c / 86400),
                g = Math.floor((c - 86400 * f) / 3600),
                h = Math.floor((c - 86400 * f - 3600 * g) / 60),
                i = c - 86400 * f - 3600 * g - 60 * h,
                j = G.zeroPad(h) + ":" + G.zeroPad(i);
            return (0 < g || 0 < f || e) && (j = G.zeroPad(g) + ":" + j), (0 < f || d) && (j = G.zeroPad(f) + ":" + j), j
        }, G.changeSecToDHMS = function(a, b) {
            var c = parseInt(a, 10),
                d = (!b || b.toUpperCase().indexOf("D"), !b || b.toUpperCase().indexOf("H"), Math.floor(c / 86400)),
                e = Math.floor((c - 86400 * d) / 3600),
                f = Math.floor((c - 86400 * d - 3600 * e) / 60),
                g = c - 86400 * d - 3600 * e - 60 * f;
            return [G.zeroPad(d), G.zeroPad(e), G.zeroPad(f), G.zeroPad(g)]
        }, G.zeroPad = function(a) {
            return a < 10 ? "0" + a : a
        }, G.arrayJoin = function(a, b) {
            return a.reduce(function(a, c) {
                return c ? a ? a + b + c : c : a
            }, "")
        }, G.makeTextButton = function(a, b, c, d, e, f) {
            var g = game.make.text(a, b, c, d);
            return g.inputEnabled = !0, g.input.useHandCursor = !0, g.hitArea = new Phaser.Rectangle(0, 0, g.width, g.height), g.events.onInputDown.add(e, f || null), g
        }, G.setObjProp = function(a, b, c) {
            var d = a;
            "string" == typeof b && b.split(".");
            try {
                for (var e = 0; e < this.refreshProp.length - 1; e++) d = d[this.refreshProp[e]];
                d[this.refreshProp[this.refreshProp.length - 1]] = c
            } catch (a) {
                console.warn("cant set prop")
            }
        }, G.getObjProp = function(a, b) {
            var c = a;
            "string" == typeof b && (b = b.split("."));
            try {
                for (var d = 0; d < b.length; d++) c = c[b[d]]
            } catch (a) {
                return
            }
            return c
        }, void 0 === G && (G = {}), G.Utils = {
            cacheText: function(a, b, c, d, e) {
                (b = game.make.bitmapText(0, 0, c, b, d)).tint = e || 16777215, b.updateCache(), game.make.renderTexture(b.width, b.height, a, !0).render(b), b.destroy()
            },
            cacheGText: function(a, b, c) {
                b = new G.Text(0, 0, b, c, 0), game.make.renderTexture(b.width, b.height, a, !0).render(b), b.destroy()
            },
            lerp: function(a, b, c, d) {
                return d && Math.abs(a - b) <= d ? b : a + c * (b - a)
            },
            copyToClipboard: function(a) {
                this.copyArea || (this.copyArea = document.createElement("textarea"), this.copyArea.style.positon = "fixed", this.copyArea.style.opacity = 0, document.body.appendChild(this.copyArea)), this.copyArea.value = a, this.copyArea.select(), document.execCommand("copy")
            },
            getObjProp: function(a, b) {
                var c = a;
                "string" == typeof b && (b = b.split("."));
                try {
                    for (var d = 0; d < b.length; d++) c = c[b[d]]
                } catch (a) {
                    return
                }
                return c
            },
            setObjProp: function(a, b, c) {
                var d = a;
                "string" == typeof b && (b = b.split("."));
                try {
                    for (var e = 0; e < b.length - 1; e++) d = d[b[e]];
                    d[b[b.length - 1]] = c
                } catch (a) {
                    return null
                }
            },
            replaceAll: function(a, b, c) {
                return a.split(b).join(c)
            },
            removeDuplicates: function(a) {
                var b = [];
                return a.forEach(function(a) {
                    -1 === b.indexOf(a) && b.push(a)
                }), b
            },
            getParentsScaleX: function(a, b) {
                return a == game.stage ? 1 : G.Utils.getParentsScaleX(a.parent, !0) * (b ? a.scale.x : 1)
            },
            getParentsScaleY: function(a, b) {
                return a == game.stage ? 1 : G.Utils.getParentsScaleY(a.parent, !0) * (b ? a.scale.y : 1)
            },
            makeTextButton: function(a, b, c, d, e, f) {
                var g = game.add.text(a, b, c, f);
                return g.inputEnabled = !0, g.input.useHandCursor = !0, g.hitArea = new Phaser.Rectangle(0, 0, g.width, g.height), g.events.onInputDown.add(d, e), g
            },
            injectCSS: function(a) {
                var b = document.createElement("style");
                b.type = "text/css", b.innerHTML = a, document.getElementsByTagName("head")[0].appendChild(b)
            },
            toClientX: function(a) {
                return (parseInt(game.canvas.style.marginLeft) || 0) + a / game.width * game.canvas.clientWidth
            },
            toClientY: function(a) {
                return (parseInt(game.canvas.style.marginTop) || 0) + a / game.height * game.canvas.clientHeight
            },
            clientXToWorldX: function(a) {
                a -= parseInt(game.canvas.style.marginLeft) || 0;
                var b = parseInt(game.canvas.style.width),
                    c = (parseInt(game.canvas.style.height), parseInt(game.canvas.width));
                return parseInt(game.canvas.height), a * (c / b)
            },
            clientYToWorldY: function(a) {
                a -= parseInt(game.canvas.style.marginTop) || 0, parseInt(game.canvas.style.width);
                var b = parseInt(game.canvas.style.height);
                return parseInt(game.canvas.width), a * (parseInt(game.canvas.height) / b)
            },
            getImageURI: function(a) {
                return this._bmpMarker || (this._bmpMarker = G.makeImage(0, 0, null, 0, null)), this._bmp || (this._bmp = game.make.bitmapData()), this._bmp.clear(), G.changeTexture(this._bmpMarker, a), this._bmp.resize(this._bmpMarker.width, this._bmpMarker.height), this._bmp.draw(this._bmpMarker), this._bmp.canvas.toDataURL()
            },
            getRT: function(a) {
                return game.cache.getRenderTexture(a).texture
            },
            arraysEqual: function(a, b) {
                if (a === b) return !0;
                if (null == a || null == b) return !1;
                if (a.length != b.length) return !1;
                for (var c = 0; c < a.length; ++c)
                    if (a[c] !== b[c]) return !1;
                return !0
            }
        }, G.lineCircleColl = function(a, b, c) {
            var d = a.start,
                e = a.end,
                f = Math.sqrt(Math.pow(e.x - d.x, 2) + Math.pow(e.y - d.y, 2)),
                g = (e.x - d.x) / f,
                h = (e.y - d.y) / f,
                i = g * (b.x - d.x) + h * (b.y - d.y),
                j = i * g + d.x,
                k = i * h + d.y,
                l = Math.sqrt(Math.pow(j - b.x, 2) + Math.pow(k - b.y, 2));
            if (l < b.radius) {
                var m = Math.sqrt(b.radius * b.radius - l * l),
                    n = (i - m) * g + d.x,
                    o = (i - m) * h + d.y,
                    p = (i + m) * g + d.x,
                    q = (i + m) * h + d.y,
                    r = game.math.distance(d.x, d.y, n, o),
                    s = game.math.distance(d.x, d.y, p, q);
                return r < s ? a.length > r && (c.setTo(n, o), c) : a.length > s && (c.setTo(p, q), c)
            }
            return !1
        }, G.getRT = function(a) {
            var b = game.cache.getRenderTexture(a);
            return b ? b.texture : null
        }, G.numberDot = function(a) {
            for (var b = "", c = 0, d = (a = a.toString()).length - 1; 0 <= d; d--) b = a[d] + b, 3 == ++c && 0 !== d && (b = "." + b, c = 0);
            return b
        }, G.guid = function() {
            function a() {
                return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1)
            }
            return a() + a() + "-" + a() + "-" + a() + "-" + a() + "-" + a() + a() + a()
        }, G.AnimationElement = function(a, b, c, d) {
            G.Image.call(this, a, b, null), this.ANIMATIONELEMENT = !0, this.SPR = new G.Image(0, 0, null, .5, this), this.frameCounter = 0, this.data = c, this.currentAnimationData = null, this.currentAnimationName = null, this.playing = void 0 === d || d
        }, G.AnimationElement.prototype = Object.create(G.Image.prototype), G.AnimationElement.prototype.update = function() {
            this.currentAnimationName && this.playing && (this.frameCounter++, this.updateAnimation(this.frameCounter))
        }, G.AnimationElement.prototype.pause = function() {
            this.playing = !1
        }, G.AnimationElement.prototype.resume = function() {
            this.playing = !0
        }, G.AnimationElement.prototype.play = function() {
            this.playing = !0
        }, G.AnimationElement.prototype.stop = function() {
            this.playing = !1, this.updateAnimation(0)
        };
        var testObj = {
            normal: {
                eventTL: [],
                frameTL: [{
                    f: 0,
                    v: "candy_1"
                }],
                propTLS: {
                    alpha: [{
                        f: 0,
                        v: 1
                    }],
                    x: [{
                        f: 0,
                        v: 0
                    }],
                    y: [{
                        f: 0,
                        v: 0
                    }],
                    angle: [{
                        f: 0,
                        v: 0
                    }],
                    "scale.x": [{
                        f: 0,
                        v: 1
                    }],
                    "scale.y": [{
                        f: 0,
                        v: 1
                    }],
                    "anchor.x": [{
                        f: 0,
                        v: .5
                    }],
                    "anchor.y": [{
                        f: 0,
                        v: 1
                    }]
                }
            },
            jump: {
                eventTL: [],
                frameTL: [{
                    f: 0,
                    v: null
                }],
                propTLS: {
                    alpha: [{
                        f: 0,
                        v: 1
                    }],
                    x: [{
                        f: 0,
                        v: 0
                    }],
                    y: [{
                        f: 0,
                        v: 0
                    }, {
                        f: 120,
                        v: -300
                    }],
                    angle: [{
                        f: 0,
                        v: 0,
                        e: ["Linear", "None"]
                    }, {
                        f: 400,
                        v: 360
                    }],
                    "scale.x": [{
                        f: 0,
                        v: 1
                    }],
                    "scale.y": [{
                        f: 0,
                        v: 1
                    }],
                    "anchor.x": [{
                        f: 0,
                        v: .5
                    }],
                    "anchor.y": [{
                        f: 0,
                        v: 1
                    }]
                }
            }
        };
        G.AnimationElement.prototype.changeAnimationData = function(a) {
            this.data[a] || (a = Object.keys(this.data)[0]), this.eventTL = this.data[a].eventTL, this.frameTL = this.data[a].frameTL, this.propTLS = this.data[a].propTLS, this.propKeys = Object.keys(this.propTLS), this.currentAnimationData = this.data[a], this.currentAnimationName = a, this.updateAnimation(0)
        }, G.AnimationElement.prototype.playAnimation = function(a) {
            this.changeAnimationData(a), this.playing = !0
        }, G.AnimationElement.prototype.getLastKeyFrame = function(a, b) {
            for (var c = a.length, d = 0; d < c; d++) {
                if (a[d].f == b || d == c - 1) return a[d];
                if (a[d].f < b && b < a[d + 1].f) return a[d]
            }
        }, G.AnimationElement.prototype.getNextKeyFrame = function(a) {
            for (var c = a.length, d = 0; d < c; d++)
                if (a[d].f > a || d == c - 1) return a[d]
        }, G.AnimationElement.prototype.getKeyFrameAt = function(a, b) {
            if (!this.currentAnimationName) return null;
            for (var c = 0; c < a.length; c++) {
                var d = a[c];
                if (d.f === b) return d
            }
            return null
        }, G.AnimationElement.prototype.isAnyKeyFrameAt = function(a) {
            if (!this.currentAnimationName) return !1;
            if (this.getKeyFrameAt(this.eventTL, a)) return !0;
            if (this.getKeyFrameAt(this.frameTL, a)) return !0;
            for (var b = 0; b < this.propKeys.length; b++) {
                var c = this.propKeys[b];
                if (this.getKeyFrameAt(this.propTLS[c], a)) return !0
            }
            return !1
        }, G.AnimationElement.prototype.getFrameValue = function(a, b) {
            var c = this.getLastKeyFrame(a, b),
                d = this.getNextKeyFrame(a, b);
            if (c.e) {
                var e = d.f - c.f,
                    f = d.v - c.v,
                    g = Phaser.Easing[c.e[0]][c.e[1]]((b - c.f) / e);
                return c.v + f * g
            }
            return c.v
        }, G.AnimationElement.prototype.updateAnimation = function(a) {
            if (this.currentAnimationName) {
                this.frameCounter = a, this.updateFromPropTLS(a);
                var b = this.getTextureFrameValue(this.frameTL, a);
                this.SPR.key != b && this.SPR.frameName != b && G.changeTexture(this.SPR, b)
            }
        }, G.AnimationElement.prototype.updateFromPropTLS = function(a) {
            for (var b = 0; b < this.propKeys.length; b++) {
                var c = this.propKeys[b];
                this.setProp(c, this.getFrameValue(this.propTLS[c], a))
            }
        }, G.AnimationElement.prototype.setProp = function(a, b) {
            "scale.x" == a ? this.SPR.scale.x = b : "scale.y" == a ? this.SPR.scale.y = b : "anchor.x" == a ? this.SPR.anchor.x = b : "anchor.y" == a ? this.SPR.anchor.y = b : this.SPR[a] = b
        }, G.AnimationElement.prototype.getTextureFrameValue = function(a, b) {
            var c = this.getLastKeyFrame(a, b),
                d = c.frameSkip || 1,
                e = b - c.f;
            if (e = Math.floor(e / d), !c.animation) return c.v;
            var f = c.v.length;
            return c.loop ? c.refraction || c.reverse ? c.refraction && !c.reverse ? c.v[Math.min(f - 1, e % (f + c.refraction))] : void 0 : c.v[e % f] : c.v[Math.min(f - 1, e)]
        }, G.GroupColliderLineLine = function(a, b, c, d) {
            G.Image.call(this, 0, 0, null), this.group1 = a, this.group2 = b, this.callback = c, this.context = d || null, this.collPoint = new Phaser.Point(0, 0)
        }, G.GroupColliderLineLine.prototype = Object.create(G.Image.prototype), G.GroupColliderLineLine.prototype.update = function() {
            for (var a = this.group1.length, b = this.group2.length, c = 0; c < a; c++)
                for (var d = this.group1.children[c], e = 0; e < b; e++) {
                    var f = this.group2.children[e];
                    d !== f && d.collLine.intersects(f.collLine, !0, this.collPoint) && this.callback.call(this.context, d, f, this.collPoint, this.group1, this.group2)
                }
        }, G.GroupColliderLineCircle = function(a, b, c, d) {
            G.Image.call(this, 0, 0, null), this.group1 = a, this.group2 = b, this.callback = c, this.context = d || null, this.collPoint = new Phaser.Point(0, 0)
        }, G.GroupColliderLineCircle.prototype = Object.create(G.Image.prototype), G.GroupColliderLineCircle.prototype.update = function() {
            this.group1.length, this.group2.length;
            for (var a = this.group1.length; a--;)
                for (var b = this.group1.children[a], c = this.group2.length; c--;) {
                    var d = this.group2.children[c];
                    b !== d && G.lineCircleColl(b.collLine, d.collCircle, this.collPoint) && this.callback.call(this.context, b, d, this.collPoint, this.group1, this.group2)
                }
        }, Phaser.Group.prototype.destroy = function(a, b) {
            null === this.game || this.ignoreDestroy || (void 0 === a && (a = !0), void 0 === b && (b = !1), this.onDestroy.dispatch(this, a, b), this.removeAll(a), this.cursor = null, this.filters = null, this.alive = !1, this.pendingDestroy = !1, b || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
        }, Phaser.exportChildren = function(a) {
            for (var b = [], c = 0; c < a.children.length; c++) {
                var d = a.children[c];
                d.exportToString && b.push(d.exportToString())
            }
            return b
        }, Phaser.Group.prototype.exportToString = function() {
            return {
                type: "GROUP",
                x: this.x,
                y: this.y,
                scale: [this.scale.x, this.scale.y],
                angle: this.angle,
                children: Phaser.exportChildren(this)
            }
        }, Phaser.Image.prototype.exportToString = function() {
            return exportObj = {
                type: "IMG",
                x: this.x,
                y: this.y,
                frame: this.frameName,
                anchor: [this.anchor.x, this.anchor.y],
                scale: [this.scale.x, this.scale.y],
                angle: this.angle,
                children: Phaser.exportChildren(this)
            }
        }, void 0 === G && (G = {}), G.Board = function(a, b, c) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.MAX_NUMBER_OF_REGULAR_CANDY = G.lvlData.nrOfTypes, this.collectCells = a.collectCells || !1, this.tilesize = b, this.offsetX = 0, this.offsetY = 0, this.editorMode = c, this.borderSize = G.l(8), this.tweenObj = {
                a: .6
            }, game.add.tween(this.tweenObj).to({
                a: 1
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.levelData = new G.GridArray(a.levelData), this.boardData = new G.GridArray(this.levelData.width, this.levelData.height), this.checkMatchList = [], this.checkSpecialMatchList = [], this.checkAfterFall = [], this.fallCheckList = [], this.duringAnimation = 0, this.duringFall = 0, G.sb("onCandyFallStart").add(function() {
                this.duringFall++
            }, this), G.sb("onCandyFallFinish").add(function(a) {
                this.duringFall--, -1 == this.fallCheckList.indexOf(a) && this.fallCheckList.push(a)
            }, this), G.sb("onCandyAnimationStart").add(function() {
                this.duringAnimation++
            }, this), G.sb("onCandyAnimationFinish").add(function() {
                this.duringAnimation--
            }, this), G.sb("onScreenResize").add(this.onResize, this), this.matcher = new G.BoardMatcher(this), this.boardBackground = new G.BoardBackground(this), this.background = game.make.image(0, 0, this.boardBackground.renderTexture), this.background.x = -this.tilesize, this.background.y = -this.tilesize, this.add(this.background), this.tileShade = G.makeImage(0, 0, "tile_shade", .5, this), this.tileShade.visible = !1, this.boardDirt = new G.BoardDirt(this), this.boardDirtS = new G.BoardDirtS(this), this.candySelection = new G.CandySelection(this), this.boardCandies = new G.BoardCandies(this, this.boardData, a), this.boardJam = new G.BoardJam(this), this.boardIce = new G.BoardIce(this), this.boardCage = new G.BoardConcrete(this), this.boardCandies.secondFloor.parent.bringToTop(this.boardCandies.secondFloor), this.boardCandies.fxGroup.parent.bringToTop(this.boardCandies.fxGroup), this.boardCandies.boosterFxGroup.parent.bringToTop(this.boardCandies.boosterFxGroup), this.boardCandies.thirdFloor.parent.bringToTop(this.boardCandies.thirdFloor), this.boardCandies.fxTopGroup.parent.bringToTop(this.boardCandies.fxTopGroup), this.layers = [this.boardDirt, this.boardDirtS, this.boardCandies, this.boardJam, this.boardCage, this.boardIce], this.layersNoCandies = [this.boardDirt, this.boardDirtS, this.boardJam, this.boardCage, this.boardIce], this.inputController = new G.InputController(this), this.actionManager = new G.BoardActionManager(this), this.refiller = new G.Refiller(a, this), this.fallMgr = new G.BoardFallMgr(this, this.refiller), this.goalCandies = G.json.specialCandies.goalCandies, this.import(this.levelData), this.boardBackground.redraw(), this.lastRowInCollumn = this.getLastRowInCollumn(), this.onResize(), G.sb("onActionFinish").add(function() {
                if (!(1 < this.actionManager.actionList.length)) {
                    for (var a = !1, b = 0; b < this.boardData.width; b++) {
                        var c = this.getCandy(b, this.boardData.height - 1);
                        c && -1 !== this.goalCandies.indexOf(c.candyType) && (this.boardCandies.removeCandy(b, this.boardData.height - 1), G.sfx.xylophone_positive6.play(), a = !0)
                    }
                    a && this.actionManager.newAction("processFall")
                }
            }, this)
        }, G.Board.prototype = Object.create(Phaser.Group.prototype), G.Board.prototype.getLastRowInCollumn = function() {
            for (var a = [], b = 0; b < this.boardData.width; b++) a.push(this.getLastCellInCollumn(b));
            return a
        }, G.Board.prototype.pushToFallCheckList = function(a) {
            !1 !== a && -1 == this.fallCheckList.indexOf(a) && this.fallCheckList.push(a)
        }, G.Board.prototype.onResize = function() {
            this.center()
        }, G.Board.prototype.destroyBoard = function() {
            this.boardDirt.destroy(), this.boardCandies.destroy(), this.boardCage.destroy(), this.boardIce.destroy(), this.destroy()
        }, G.Board.prototype.clearBoard = function() {
            this.boardData.loop(function(a, b, c) {
                this.boardCandies.goalCandies = [], this.boardCandies.rabbitCandy = !1;
                var d = this.boardCandies.getCandy(b, c);
                d && this.boardCandies.removeCandy(d), this.boardIce.destroyCell(b, c), this.boardDirt.destroyCell(b, c)
            }, this)
        }, G.Board.prototype.center = function() {
            var a, b, c, d = this.tilesize * this.boardData.width,
                e = this.tilesize * this.boardData.height;
            G.horizontal ? (a = Math.min(1, 580 / d), b = Math.min(1, (game.height - 100) / e), c = Math.min(a, b), this.scale.setTo(c), this.x = G.l(80) - .5 * (580 - d * c), this.y = .5 * game.height - e * c * .5) : (a = Math.min(1, 640 / d), b = Math.min(1, (game.height - 220 - 150) / e), c = Math.min(a, b), this.scale.setTo(c), this.x = G.l(320) - d * c * .5, this.y = G.l(220) + .5 * (game.height - 220 - 150 - e * c)), this.x = Math.floor(this.x), this.y = Math.floor(this.y)
        }, G.Board.prototype.update = function() {
            this.actionManager.update()
        }, G.Board.prototype.isIdle = function() {
            return 0 === this.actionManager.actionList.length
        }, G.Board.prototype.checkGoalCandy = function() {
            for (var a = !1, b = 0; b < this.boardData.width; b++) {
                var c = this.getCandy(b, this.lastRowInCollumn[b]);
                if (c && -1 !== this.goalCandies.indexOf(c.candyType)) {
                    var d = !0;
                    this.collectCells && (this.isCandyOnCollectCell(c) || (d = !1)), d && (this.boardCandies.removeCandy(b, this.lastRowInCollumn[b]), G.sfx.xylophone_positive6.play(), a = !0)
                }
            }
            return a ? (this.actionManager.newAction("processFall"), !0) : void 0
        }, G.Board.prototype.isCandyOnCollectCell = function(a) {
            return this.collectCells && this.collectCells.find(function(b) {
                return b.x === a.cellX && b.y === a.cellY
            }) ? !0 : !1
        }, G.Board.prototype.makeMove = function(a, b, c) {
            this.actionManager.newAction("move", a, b, c)
        }, G.Board.prototype.hitCell = function(a, b) {
            for (var c = this.layers.length; c--;)
                if (!this.layers[c].onHit(a, b)) return
        }, G.Board.prototype.isMoveable = function(a, b) {
            return "number" != typeof a && (b = a[1], a = a[0]), !!this.isCellOnBoard(a, b) && !this.isMoveBlocked(a, b) && !!this.getCandy(a, b)
        }, G.Board.prototype.isMoveBlocked = function(a, b) {
            for (var c = this.layers.length; c--;)
                if (this.layers[c].isMoveBlocked(a, b)) return !0;
            return !1
        }, G.Board.prototype.isBoosterChangeBlocked = function(a, b) {
            for (var c = this.layers.length; c--;)
                if (this.layers[c].isBoosterChangeBlocked(a, b)) return !0;
            return !1
        }, G.Board.prototype.isMatchBlocked = function(a, b) {
            for (var c = this.layers.length; c--;)
                if (this.layers[c].isMatchBlocked(a, b)) return !0;
            return !1
        }, G.Board.prototype.matchCellExceptCandy = function(a, b) {
            for (var c = this.layersNoCandies.length; c--;)
                if (!this.layersNoCandies[c].onMatch(a, b)) return void console.log("** except stopped propataion")
        }, G.Board.prototype.getLastCellInCollumn = function(a) {
            for (var b = this.boardData.height - 1; 0 <= b; b--)
                if (this.isCellOnBoard(a, b)) return b
        }, G.Board.prototype.matchCell = function(a, b, c, d, e) {
            for (var f = this.layers.length; f--;)
                if (!this.layers[f].onMatch(a, b, c, d, e)) return void console.log("** stopped propagation")
        }, G.Board.prototype.isCellInBoardArea = function(a, b) {
            return a < this.boardData.width && 0 <= a && 0 <= b && b < this.boardData.height
        }, G.Board.prototype.isCellMatchable = function(a, b, c) {
            if ("number" != typeof a && (b = a[1], a = a[0]), !this.isCellOnBoard(a, b)) return !1;
            if (this.isMatchBlocked(a, b)) return !1;
            var d = this.getCandy(a, b);
            return !!d && (!c || d.candyType == c)
        }, G.Board.prototype.isCellMatchable = function(a, b, c) {
            if ("number" != typeof a && (b = a[1], a = a[0]), !this.isCellOnBoard(a, b)) return !1;
            if (this.boardIce.isToken(a, b)) return !1;
            if (this.isMatchBlocked(a, b)) return !1;
            var d = this.getCandy(a, b);
            return !!d && !!d.matchable && !d.falling && !d.goalCandy && !d.chocolate && (!c || this.getCandy(a, b).candyType == c)
        }, G.Board.prototype.isCellOnBoard = function(a, b) {
            return "boolean" != typeof a && ("number" != typeof a && (b = a[1], a = a[0]), !(a < 0 || a >= this.boardData.width || b < 0 || b >= this.boardData.height) && "X" != this.boardData.get(a, b))
        }, G.Board.prototype.getCandy = function(a, b) {
            return "number" != typeof a ? this.boardCandies.getCandy(a[0], a[1]) : this.boardCandies.getCandy(a, b)
        }, G.Board.prototype.cellToPxOut = function(a) {
            var b = this.tilesize * this.scale.x;
            return [this.x + this.offsetX + b * a[0] + .5 * b, this.y + this.offsetY + b * a[1] + .5 * b]
        }, G.Board.prototype.pxInToCellX = function(a) {
            return Math.floor(a / this.tilesize)
        }, G.Board.prototype.pxInToCellY = function(a) {
            return Math.floor(a / this.tilesize)
        }, G.Board.prototype.cellXToPxIn = function(a) {
            return a * this.tilesize + .5 * this.tilesize
        }, G.Board.prototype.cellYToPxIn = function(a) {
            return a * this.tilesize + .5 * this.tilesize
        }, G.Board.prototype.cellToPxIn = function(a) {
            return [this.cellXToPxIn(a[0]), this.cellYToPxIn(a[1])]
        }, G.Board.prototype.swapCandies = function(a, b) {
            this.boardCandies.swapCandies(a, b)
        }, G.Board.prototype.removeCandy = function() {
            this.boardCandies.removeCandy.apply(this.boardCandies, arguments)
        }, G.Board.prototype.newFallingCandy = function(a, b, c, d) {
            var e = this.boardCandies.newCandy(a, b, c);
            e.y = this.cellYToPxIn(d), e.fallTo(a, b), e.alpha = 0
        }, G.Board.prototype.export = function() {
            var a = new G.GridArray(this.boardData.width, this.boardData.height);
            return a.loop(function(a, b, c, d) {
                var e = [];
                "X" == this.boardData.get(b, c) && e.push("X"), this.layers.forEach(function(a) {
                    var d = a.export(b, c);
                    d && e.push(d)
                }), d[b][c] = e
            }, this), JSON.stringify(a.data)
        }, G.Board.prototype.import = function(a) {
            a.loop(function(a, b, c) {
                for (var d = 0, e = a.length; d < e; d++)
                    if (a[d] = a[d].toString(), "W" == a[d][0] && (a[d] = a[d][1] + ":" + a[d][0]), "r" !== a[d][0] || this.editorMode || (a[d] = this.getRandomThatDoesntMatch(b, c) + a[d].substr(1)), "X" == a[d]) this.boardData.set(b, c, "X");
                    else {
                        var f = !1;
                        this.layersNoCandies.forEach(function(e) {
                            var g = e.import(b, c, a[d]);
                            !f && g && (f = !0)
                        }), f || this.boardCandies.import(b, c, a[d])
                    }
            }, this), 0 == this.matcher.checkPossibleMoves().length && this.shuffleCandies(!0), this.possibleMoves = this.matcher.checkPossibleMoves()
        }, G.Board.prototype.makePossibleMatch = function() {
            for (var a, b, c, d = this.boardData.width, e = this.boardData.height, f = [
                    [1, 0, 1, -1, 1, 1],
                    [-1, 0, -1, -1, -1, 1],
                    [0, -1, -1, -1, 1, -1],
                    [0, 1, -1, 1, 1, 1]
                ];;)
                if (a = Math.floor(Math.random() * d), b = Math.floor(Math.random() * e), c = f[Math.floor(Math.random() * f.length)], this.isMoveable(a, b) && this.isCellMatchable(a, b) && this.isMoveable(a + c[0], b + c[1]) && this.isCellMatchable(a + c[2], b + c[3]) && this.isCellMatchable(a + c[4], b + c[5])) {
                    var g = this.getCandy(a, b),
                        h = this.getCandy(a + c[2], b + c[3]),
                        i = h.candyType,
                        j = this.getCandy(a + c[4], b + c[5]),
                        k = j.candyType;
                    if (!g.goalCandy && !h.goalCandy && !j.goalCandy) {
                        if (h.candyType = g.candyType, j.candyType = g.candyType, !this.matcher.quickMatchCheck(h) && !this.matcher.quickMatchCheck(j)) {
                            G.changeTexture(h, g.frameName), G.changeTexture(j, g.frameName);
                            break
                        }
                        h.candyType = i, j.candyType = k
                    }
                }
        }, G.Board.prototype.getRandomThatDoesntMatch = function(a, b) {
            for (var c = game.rnd.between(1, this.MAX_NUMBER_OF_REGULAR_CANDY), d = 0; d < this.MAX_NUMBER_OF_REGULAR_CANDY; d++) {
                if (!(this.isCellMatchable(a - 2, b, c) && this.isCellMatchable(a - 1, b, c) || this.isCellMatchable(a, b - 2, c) && this.isCellMatchable(a, b - 1, c) || this.isCellMatchable(a - 1, b, c) && this.isCellMatchable(a - 1, b - 1, c) && this.isCellMatchable(a, b - 1, c))) return c;
                c = (c + 1) % this.MAX_NUMBER_OF_REGULAR_CANDY
            }
            return c
        }, G.Board.prototype.shuffleFailure = function() {
            for (var a = 0; a < 24; a++) this.removeCandy(a % 8, Math.floor(a / 8));
            for (a = 0; a < 24; a++) this.boardCandies.newCandy(a % 8, Math.floor(a / 8), game.rnd.between(1, 3).toString())
        }, G.Board.prototype.shuffleCandies = function(a) {
            for (var b = this.boardData.width, c = this.boardData.height, d = 0; 20 < ++d && this.shuffleFailure(), this.boardCandies.grid.loop(function(d, e, f, g) {
                    if (d && this.isMoveable(e, f) && !d.goalCandy) {
                        for (var h, i, j; h = game.rnd.between(0, b - 1), i = game.rnd.between(0, c - 1), e == h && i == f || (j = g[h][i], !this.isMoveable(h, i) || j.goalCandy););
                        a || G.IMMEDIATE ? this.swapCandiesWithPosition(d, j) : this.swapCandies(d, j)
                    }
                }, this), 0 == this.matcher.checkPossibleMoves().length;);
            G.sfx.whoosh_short_1.play(), this.boardCandies.grid.loop(function(b, c, d) {
                b && (!a && this.isMoveable(c, d) && b.shuffleMoveToOwnCell(), this.isCellMatchable(c, d) && this.matcher.quickMatchCheck(b) && this.checkMatchList.push(b))
            }, this), 0 < this.checkMatchList.length && this.actionManager.newAction("processMatch")
        }, G.Board.prototype.swapCandiesWithPosition = function(a, b) {
            this.boardCandies.grid.set(a.cellX, a.cellY, b), this.boardCandies.grid.set(b.cellX, b.cellY, a);
            var c = a.cellX,
                d = a.cellY,
                e = a.x,
                f = a.y;
            a.x = b.x, a.y = b.y, a.cellX = b.cellX, a.cellY = b.cellY, b.x = e, b.y = f, b.cellX = c, b.cellY = d
        }, G.Board.prototype.deconstruct = function() {
            this.deconstructing = !0, this.background.x += .5 * this.background.width, this.background.y += .5 * this.background.height, this.background.anchor.setTo(.5), this.glowImg = G.makeImage(0, 0, "popup_lighht", .5, this), this.glowImg.x = this.background.x, this.glowImg.y = this.background.y, this.glowImg.blendMode = 1, game.add.tween(this.glowImg).to({
                angle: 360
            }, 6e3, Phaser.Easing.Linear.None, !0), this.glowImg.alpha = 0, this.wellDoneTxt = new G.Text(0, 0, G.txt("Well done!"), {
                style: "font-red",
                fontSize: 70
            }, .5, 600), G.sfx.music.pause(), G.sfx.lvlcompleted.play(), this.add(this.wellDoneTxt), this.wellDoneTxt.x = this.background.x, this.wellDoneTxt.y = this.background.y, this.wellDoneTxt.visible = !1, game.add.tween(this.boardDirt).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.In, !0), game.add.tween(this.boardIce).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.In, !0), game.add.tween(this.boardCage).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.In, !0), game.time.events.add(200, this.boardCandies.deconstruct, this.boardCandies), game.time.events.add(900, function() {
                game.add.tween(this.background.scale).to({
                    x: 0,
                    y: 0
                }, 500, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this.background).to({
                    angle: 70
                }, 500, Phaser.Easing.Sinusoidal.InOut, !0)
            }, this), game.time.events.add(900, function() {
                game.add.tween(this.glowImg).to({
                    alpha: .2
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.wellDoneTxt.visible = !0, this.wellDoneTxt.scale.setTo(0), game.add.tween(this.wellDoneTxt.scale).to({
                    x: 1,
                    y: 1
                }, 500, Phaser.Easing.Elastic.Out, !0)
            }, this), game.time.events.add(2200, function() {
                game.add.tween(this.glowImg).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.wellDoneTxt).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), G.lvl.state.windowLayer.pushWindow("win")
            }, this)
        }, G.BoardActionManager = function(a) {
            this.board = a, this.state = game.state.getCurrentState(), this.actionList = [], this.noAction = !0, this.madeMove = !1, G.sb("madeMove").add(function() {
                this.madeMove = !0
            }, this), this.availableActions = {
                move: G.ActionMove,
                processMatch: G.ActionProcessMatch,
                processFall: G.ActionProcessFall,
                boosterMatch: G.ActionBoosterMatch,
                boosterSwap: G.ActionBoosterSwap,
                shuffle: G.ActionShuffle,
                startBoosterInit: G.ActionStartBoosters
            }, G.sb("onBoosterSelect").add(function(a) {
                1 == a ? this.newAction("boosterSwap") : this.newAction("boosterMatch", a)
            }, this), G.sb("onBoosterDeselect").add(function() {
                1 == this.actionList.length && this.actionList[0].finish()
            }, this), this.noActionFrames = 0, this.shakingCandies = []
        }, G.BoardActionManager.prototype.update = function() {
            0 == this.actionList.length ? (this.noAction = !0, this.noActionFrames++, 160 < this.noActionFrames && (this.noActionFrames = 0, this.glowPossibleMoves()), this.updateShakes()) : (this.noActionFrames = 0, this.noAction = !1, this.actionList[0].update())
        }, G.BoardActionManager.prototype.normalCandies = ["0", "1", "2", "3", "4", "5", "6"], G.BoardActionManager.prototype.updateShakes = function() {
            for (var a = this.shakingCandies.length; a--;) {
                var b = this.shakingCandies[a],
                    c = b.candy;
                b.dt += .04, c.x = b.orgX + Math.sin(4 * b.dt * Math.PI) * b.wave, 1 <= b.dt && (c.x = b.orgX, c.y = b.orgY, this.shakingCandies.pop())
            }
        }, G.BoardActionManager.prototype.breakShakes = function() {
            this.shakingCandies.forEach(function(a) {
                a.candy.x = a.orgX, a.candy.y = a.orgY
            }), this.shakingCandies = []
        }, G.BoardActionManager.prototype.glowPossibleMoves = function() {
            if (!G.tutorialOpened) {
                var a = this.board.matcher.checkPossibleMoves();
                if (Phaser.ArrayUtils.shuffle(a), 0 != a.length) {
                    var b = a[0];
                    this.shakeCandy(this.board.getCandy(b[0], b[1])), this.shakeCandy(this.board.getCandy(b[2], b[3]))
                }
            }
        }, G.BoardActionManager.prototype.shakeCandy = function(a) {
            this.shakingCandies.push({
                candy: a,
                orgX: a.x,
                orgY: a.y,
                dt: 0,
                wave: G.l(5)
            })
        }, G.BoardActionManager.prototype.newAction = function(a) {
            this.breakShakes();
            var b = [].slice.call(arguments, 1);
            this.actionList.push(new this.availableActions[a](this.board, this, b))
        }, G.BoardActionManager.prototype.removeAction = function(a) {
            var b = this.actionList.indexOf(a);
            if (-1 != b ? this.actionList.splice(b, 1) : this.actionList.splice(0, 1), 0 == this.actionList.length) {
                if (G.lvl.endCombo(), G.lvl.goalAchieved) {
                    if (0 < G.lvl.moves) {
                        var c = this.board.boardCandies.getNormalCandies();
                        Phaser.ArrayUtils.shuffle(c);
                        for (var d = Math.min(G.lvl.moves, c.length, 15), e = 0; e < d; e++) {
                            var f = c[e];
                            f.changeInto(Math.random() < .5 ? "horizontal" : "vertical"), f.activatedByMove = !0, G.lvl.changePointsNumber(G.json.settings.pointsForMoveLeft);
                            var g = G.lvl.state.board.cellToPxOut([f.cellX, f.cellY]);
                            G.sb("displayPoints").dispatch(g[0], g[1], G.json.settings.pointsForMoveLeft), G.lvl.madeMove(), this.board.checkSpecialMatchList.push(f)
                        }
                        return G.sfx.booster.play(), void game.time.events.add(800, function() {
                            this.newAction("processMatch")
                        }, this)
                    }
                    var h = this.board.boardCandies.getAllSpecialCandies();
                    if (!(0 < h.length)) return G.sb("onWinLevelPopUp").dispatch(), "CHALLENGE" == this.state.mode && (G.saveState.data.dailyBeaten || (G.saveState.data.dailyBeaten = 0), G.saveState.data.dailyBeaten++), this.board.deconstruct();
                    h.forEach(function(a) {
                        a.activatedByMove = !0, this.board.checkSpecialMatchList.push(a)
                    }, this), G.IMMEDIATE ? this.newAction("processMatch") : game.time.events.add(G.IMMEDIATE ? 1 : 300, function() {
                        this.newAction("processMatch")
                    }, this)
                }
                if (this.board.possibleMoves = this.possibleMoves = this.board.matcher.checkPossibleMoves(), 0 == this.possibleMoves.length) return this.newAction("shuffle");
                0 == G.lvl.moves && (G.lvl.isGoalAchieved() || G.lvl.state.windowLayer.pushWindow(game.incentivised ? "outOfMoves" : G.saveState.getCoins() >= 2 * G.lvl.getPriceOfExtraMoves() ? "outOfMoves" : "levelFailed")), G.sb("actionQueueEmpty").dispatch(), this.madeMove && (this.madeMove = !1, G.sb("actionQueueEmptyAfterMove").dispatch())
            }
        }, G.BoardBackground = function(a) {
            Phaser.Group.call(this, game), this.board = a, this.borderSize = G.l(8), this.renderTexture = game.add.renderTexture(1, 1), this.markerImg = game.make.image(), this.markerImg.anchor.setTo(.5)
        }, G.BoardBackground.prototype = Object.create(Phaser.Group.prototype), G.BoardBackground.prototype.redraw = function() {
            this.renderTexture.resize((this.board.boardData.width + 2) * this.board.tilesize, (this.board.boardData.height + 2) * this.board.tilesize, !0), this.renderTexture.clear(), this.drawBg()
        }, G.BoardBackground.prototype.drawBg = function() {
            this.board.tilesize;
            for (var a = -1; a < this.board.boardData.width + 1; a++)
                for (var b = -1; b < this.board.boardData.height + 1; b++) {
                    var c = this.checkIfTile(a, b),
                        d = this.checkIfTile(a, b - 1),
                        e = this.checkIfTile(a, b + 1),
                        f = this.checkIfTile(a - 1, b),
                        g = this.checkIfTile(a + 1, b),
                        h = this.checkIfTile(a + 1, b - 1),
                        i = this.checkIfTile(a - 1, b - 1),
                        j = this.checkIfTile(a + 1, b + 1),
                        k = this.checkIfTile(a - 1, b + 1);
                    c ? this.drawSprite(a, b, "tile_" + (1 + (a % 2 + b % 2) % 2), 0) : (d && this.drawSprite(a, b, "tile_border_straight", 180), e && this.drawSprite(a, b, "tile_border_straight", 0), f && this.drawSprite(a, b, "tile_border_straight", 90), g && this.drawSprite(a, b, "tile_border_straight", 270), !j || g || e || this.drawSprite(a, b, "tile_border_outside_corner", 0), !k || f || e || this.drawSprite(a, b, "tile_border_outside_corner", 90), !h || g || d || this.drawSprite(a, b, "tile_border_outside_corner", 270), !i || f || d || this.drawSprite(a, b, "tile_border_outside_corner", 180), e && g && this.drawSprite(a, b, "tile_border_inside_corner", 0), e && f && this.drawSprite(a, b, "tile_border_inside_corner", 90), d && g && this.drawSprite(a, b, "tile_border_inside_corner", 270), d && f && this.drawSprite(a, b, "tile_border_inside_corner", 180))
                }
        }, G.BoardBackground.prototype.drawSprite = function(a, b, c, d) {
            var e = a * this.board.tilesize,
                f = b * this.board.tilesize;
            this.markerImg.angle = d || 0, G.changeTexture(this.markerImg, c), this.markerImg.updateTransform(), this.renderTexture.renderXY(this.markerImg, e + 1.5 * this.board.tilesize, f + 1.5 * this.board.tilesize)
        }, G.BoardBackground.prototype.checkIfTile = function(a, b) {
            var c = this.board.boardData.get(a, b);
            return !1 !== c && "X" !== c
        }, G.BoardCandies = function(a, b) {
            Phaser.Group.call(this, game), this.board = a, this.position = a.position, this.scale = a.scale, this.boardData = b, this.grid = new G.GridArray(this.boardData.width, this.boardData.height, !1), this.deadGroup = game.add.group(), this.deadGroup.visible = !1, this.firstFloor = game.add.group(), this.secondFloor = game.add.group(), this.collectCells = a.collectCells, this.boardCollectCells = new G.BoardCollectCells(a, this.collectCells), a.boardCollectCells = this.boardCollectCells, this.fxGroup = new G.TopFxLayer(this.board), this.boosterFxGroup = game.add.group(), this.thirdFloor = game.add.group(), this.fxTopGroup = this.fxGroup.aboveThirdFloorLayer = game.add.group(), G.IMMEDIATE && (this.deadGroup.visible = this.firstFloor.visible = this.secondFloor.visible = this.fxGroup.visible = this.thirdFloor.visible = this.fxTopGroup.visible = !1), this.firstFloor.position = this.secondFloor.position = this.fxGroup.position = this.fxTopGroup.position = this.boosterFxGroup.position = this.thirdFloor.position = this.position, this.firstFloor.scale = this.secondFloor.scale = this.fxGroup.scale = this.fxTopGroup.scale = this.boosterFxGroup.scale = this.thirdFloor.scale = this.scale, this.infectionSources = [], this.infectionSuperSources = [], this.infectionCoords = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, -1],
                [-1, -1],
                [-1, -1],
                [1, -1],
                [1, 1]
            ], G.sb("onCandyInfect").add(function(a) {
                this.addInfectionSource(a, this.infectionSources)
            }, this), G.sb("onCandyInfectionRemove").add(function(a) {
                this.removeInfectionSource(a, this.infectionSources)
            }, this), this.removedInfectionSource = !1, this.infectionToMakeStep = 0, G.sb("actionQueueEmptyAfterMove").add(function() {
                this.removedInfectionSource || 0 < this.infectionSuperSources.length && (this.spreadInfection(this.infectionSuperSources) || this.spreadInfection(this.infectionSources)), this.removedInfectionSource = !1
            }, this)
        }, G.BoardCandies.prototype = Object.create(Phaser.Group.prototype), G.BoardCandies.prototype.onMatch = function(a, b, c, d, e) {
            var f = this.getCandy(a, b);
            return f && f.match(c, d, e), !0
        }, G.BoardCandies.prototype.onHit = function(a, b) {
            var c = this.getCandy(a, b);
            return c && c.hit(), !0
        }, G.BoardCandies.prototype.isMoveBlocked = function() {
            return !1
        }, G.BoardCandies.prototype.isMatchBlocked = function(a, b) {
            var c = this.getCandy(a, b);
            return !!c && (!c.matchable || c.falling || c.goalCandy || c.chocolate)
        }, G.BoardCandies.prototype.isBoosterChangeBlocked = function(a, b) {
            var c = this.getCandy(a, b);
            return !!c && (c.special || c.wrapped || c.infected)
        }, G.BoardCandies.prototype.import = function(a, b, c) {
            var d = c.indexOf(":");
            d = -1 == d ? c.length : d;
            var e = this.newCandy(a, b, c.slice(0, d)),
                f = c.slice(d); - 1 !== f.indexOf("W") && e.wrap(), -1 !== f.indexOf("B") && e.changeIntoBlocker(f[2]), -1 !== f.indexOf("I") && e.infect(), -1 !== f.indexOf("H") && e.changeInto("horizontal", !0), -1 !== f.indexOf("V") && e.changeInto("vertical", !0), -1 !== f.indexOf("S") && e.changeInto("spiral", !0), -1 !== f.indexOf("C") && e.changeInto("cross", !0)
        }, G.BoardCandies.prototype.export = function(a, b) {
            var c = this.getCandy(a, b);
            return !(!c || c.blocker) && (c.wrapped ? "W" + c.candyType : c.chocolate ? "c" + c.hp : c.candyType)
        }, G.BoardCandies.prototype.spreadInfection = function(a) {
            if (0 != a.length) {
                Phaser.ArrayUtils.shuffle(a);
                for (var b = game.rnd.pick(a), c = 0, d = this.infectionCoords.length; c < d; c++) {
                    var e = this.infectionCoords[c],
                        f = b.cellX + e[0],
                        g = b.cellY + e[1],
                        h = this.getCandy(f, g);
                    if (h && this.board.isMoveable(f, g) && this.board.isCellMatchable(f, g) && !h.wrapped && !h.infected && !h.special) return h.infect(), !0
                }
                return !1
            }
        }, G.BoardCandies.prototype.getRandom = function() {
            var a, b = this.firstFloor.children.concat(this.secondFloor.children),
                c = b.length,
                d = game.rnd.between(0, c);
            if (0 == c) return !1;
            for (var e = 0; e < c; e++)
                if (a = b[(e + d) % c], this.grid.get(a.cellX, a.cellY) == a && a && a.alive && !a.goalCandy && this.board.isCellMatchable(a.cellX, a.cellY)) return a;
            return !1
        }, G.BoardCandies.prototype.getRandomNormal = function() {
            var a, b = this.firstFloor.children.concat(this.secondFloor.children),
                c = b.length,
                d = game.rnd.between(0, c);
            if (0 == c) return !1;
            for (var e = 0; e < c; e++)
                if (a = b[(e + d) % c], this.grid.get(a.cellX, a.cellY) == a && a && !a.special && !a.chocolate && !a.wrapped && a.alive && !a.goalCandy && this.board.isCellMatchable(a.cellX, a.cellY) && this.board.isMoveable(a.cellX, a.cellY)) return a;
            return !1
        }, G.BoardCandies.prototype.getNormalCandies = function() {
            var a, b = this.firstFloor.children.concat(this.secondFloor.children),
                c = b.length,
                d = game.rnd.between(0, c),
                e = [];
            if (0 == c) return !1;
            for (var f = 0; f < c; f++) a = b[(f + d) % c], this.grid.get(a.cellX, a.cellY) == a && a && !a.special && !a.chocolate && !a.wrapped && a.alive && !a.goalCandy && this.board.isCellMatchable(a.cellX, a.cellY) && this.board.isMoveable(a.cellX, a.cellY) && e.push(a);
            return e
        }, G.BoardCandies.prototype.moveTo = function(a, b) {
            this.x = a, this.y = b
        }, G.BoardCandies.prototype.isSpaceFree = function(a, b) {
            return !this.grid.get(a, b)
        }, G.BoardCandies.prototype.gridMoveFromTo = function(a, b, c, d) {
            this.grid.set(c, d, this.grid.get(a, b)), this.grid.set(a, b, null)
        }, G.BoardCandies.prototype.newCandy = function(a, b, c) {
            var d = this.deadGroup.children[0] ? this.deadGroup.children[0] : new G.Candy(this.board, this.grid);
            return this.firstFloor.add(d), void 0 !== c && c.indexOf && -1 !== c.indexOf("CHAIN") ? (d.init(a, b, c.slice(-1)), d.wrap()) : d.init(a, b, c || game.rnd.between(1, this.board.MAX_NUMBER_OF_REGULAR_CANDY)), this.grid.set(a, b, d), "infection" == c && (d.matchable = !1, this.addInfectionSource(d, this.infectionSuperSources)), "chest" == c && (d.matchable = !1), d
        }, G.BoardCandies.prototype.getCandy = function(a, b) {
            return this.grid.get(a, b)
        }, G.BoardCandies.prototype.swapCandies = function(a, b) {
            this.grid.set(a.cellX, a.cellY, b), this.grid.set(b.cellX, b.cellY, a);
            var c = a.cellX,
                d = a.cellY;
            a.cellX = b.cellX, a.cellY = b.cellY, b.cellX = c, b.cellY = d
        }, G.BoardCandies.prototype.removeCandy = function() {
            var a, b = !1;
            b = "object" == typeof arguments[0] ? (a = Array.isArray(arguments[0]) ? this.getCandy(arguments[0][0], arguments[0][1]) : arguments[0], arguments[1]) : (a = this.getCandy(arguments[0], arguments[1]), arguments[2]), a && (this.removeInfectionSource(a, this.infectionSuperSources), this.grid.set(a.cellX, a.cellY, !1), b || G.sb("onCollectableRemove").dispatch(a.candyType, !a.specialType && a), a.kill(), this.deadGroup.add(a))
        }, G.BoardCandies.prototype.removeToken = G.BoardCandies.prototype.removeCandy, G.BoardCandies.prototype.destroyCell = G.BoardCandies.prototype.removeCandy, G.BoardCandies.prototype.addInfectionSource = function(a, b) {
            -1 === b.indexOf(a) && b.push(a)
        }, G.BoardCandies.prototype.removeInfectionSource = function(a, b) {
            var c = b.indexOf(a); - 1 !== c && (b.splice(c, 1), this.removedInfectionSource = !0)
        }, G.BoardCandies.prototype.consoleInfectionSources = function() {
            for (var a = 0; a < this.infectionSources.length; a++) console.log("INFECTION SOURCE: " + this.infectionSources[a].cellX + "x" + this.infectionSources[a].cellY)
        }, G.BoardCandies.prototype.getAllSpecialCandies = function() {
            var a = [];
            return this.grid.loop(function(b) {
                b && b.special && a.push(b)
            }), a
        }, G.BoardCandies.prototype.deconstruct = function() {
            for (var a = 0, b = 0; b <= 14; b++) {
                for (var c = 0, d = b; 0 <= d; d--) this.grid.get(c, d) && (t1 = game.add.tween(this.grid.get(c, d).scale).to({
                    x: 0,
                    y: 0
                }, 300, Phaser.Easing.Sinusoidal.InOut, !0, a)), c++;
                a += 40
            }
        }, G.BoardCandies.prototype.areCandiesNeighbours = function(a, b) {
            return !(!a || !b) && Math.abs(a.cellX - b.cellX) + Math.abs(a.cellY - b.cellY) == 1
        }, G.BoardCollectCells = function(a, b) {
            Phaser.Group.call(this, game), this.board = a, this.position = a.position, this.scale = a.scale, this.ccs = [], b && this.init(b)
        }, G.BoardCollectCells.prototype = Object.create(Phaser.Group.prototype), G.BoardCollectCells.prototype.init = function(a) {
            a.forEach(function(a) {
                this.addCC(a)
            }, this), G.sb("onCollectableTaskFinished").add(function(a) {
                "goalCandy" === a && this.hide()
            }), G.sb("onGoalAchieved").add(this.hide, this)
        }, G.BoardCollectCells.prototype.hide = function() {
            1 === this.alpha && game.add.tween(this).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0)
        }, G.BoardCollectCells.prototype.addCC = function(a) {
            var b = a.x * this.board.tilesize,
                c = a.y * this.board.tilesize,
                d = G.makeImage(b, c, "collect_cell", 0, this);
            d.cellX = a.x, d.cellY = a.y, this.ccs.push(d)
        }, G.BoardCollectCells.prototype.editorChangeCC = function(a, b) {
            var c = this.ccs.find(function(c) {
                return c.cellX === a && c.cellY === b
            });
            c ? (c.destroy(), this.ccs.splice(this.ccs.indexOf(c), 1)) : this.addCC({
                x: a,
                y: b
            }), G.lvlData.collectCells = this.editorExport()
        }, G.BoardCollectCells.prototype.editorExport = function() {
            return 0 === this.ccs.length ? null : this.ccs.map(function(a) {
                return {
                    x: a.cellX,
                    y: a.cellY
                }
            })
        }, G.BoardMatcher = function(a) {
            this.board = a, this.specialsCoordinates = G.specialCandies.patterns, this.grid = new G.GridArray(this.board.boardData.width, this.board.boardData.height, !1), this.grid.set = function(a, b, c) {
                return !!this.isInGrid(a, b) && (this.data[a][b] ? "m" == this.data[a][b] && "m" != c ? this.data[a][b] = c : void 0 : this.data[a][b] = c)
            }, this.tempGrid = new G.GridArray(this.board.boardData.width, this.board.boardData.height, !1), this.hitGrid = new G.GridArray(this.board.boardData.width, this.board.boardData.height, !1), this.toCheck = []
        }, G.BoardMatcher.prototype.isMoveValid = function(a) {
            var b = a.cellX,
                c = a.cellY;
            return !!this.board.isCellMatchable(b, c) && (!(!a.special || !a.activatedByMove) || !!this.quickCheckCoords(a, this.horCoords, !1) || !!this.quickCheckCoords(a, this.verCoords, !1))
        }, G.BoardMatcher.prototype.quickMatchCheck = function(a) {
            if (!a) return !1;
            var b = a.cellX,
                c = a.cellY;
            return !!this.board.isCellMatchable(b, c) && (!!this.quickCheckCoords(a, this.horCoords, !1) || !!this.quickCheckCoords(a, this.verCoords, !1))
        }, G.BoardMatcher.prototype.checkPossibleMoves = function() {
            var a = [];
            return this.board.boardCandies.grid.loop(function(b, c, d) {
                b && this.board.isMoveable(b.cellX, b.cellY) && this.board.isCellMatchable(b.cellX, b.cellY) && (b && this.board.isMoveable(c + 1, d) && this.quickCheckCoords(b, this.possibleRightMoves, !1) && a.push([c, d, c + 1, d]), b && this.board.isMoveable(c - 1, d) && this.quickCheckCoords(b, this.possibleLeftMoves, !1) && a.push([c, d, c - 1, d]), b && this.board.isMoveable(c, d - 1) && this.quickCheckCoords(b, this.possibleUpMoves, !1) && a.push([c, d, c, d - 1]), b && this.board.isMoveable(c, d + 1) && this.quickCheckCoords(b, this.possibleDownMoves, !1) && a.push([c, d, c, d + 1]))
            }, this), a
        }, G.BoardMatcher.prototype.quickCheckCoords = function(a, b, c) {
            for (var d, e, f = a.cellX, g = a.cellY, h = a.candyType, i = 0, j = b.length; i < j; i++) {
                e = !0;
                for (var k = 0, l = (d = b[i]).length; k < l; k += 2)
                    if (!this.board.isCellMatchable(f + d[k], g + d[k + 1], h)) {
                        e = !1;
                        break
                    }
                if (c && !e) return !1;
                if (!c && e) return !0
            }
            return !!c
        }, G.BoardMatcher.prototype.processMatchList = function() {
            if (0 != this.board.checkMatchList.length || 0 != this.board.checkSpecialMatchList.length) {
                G.lvl.increaseCombo(), G.sfx["match_" + game.math.clamp(G.lvl.combo || 1, 1, 5)].play(), this.candiesToProcess = this.board.checkMatchList, this.specialCandiesToProcess = this.board.checkSpecialMatchList;
                for (var a = 0, b = this.candiesToProcess.length; a < b; a++) this.grid.get(this.candiesToProcess[a].cellX, this.candiesToProcess[a].cellY) || (this.candiesToProcess[a].special && this.candiesToProcess[a].activatedByMove ? this.specialCandiesToProcess.push(this.candiesToProcess[a]) : this.processTemp(this.candiesToProcess[a]));
                this.inflateHitGrid();
                for (var c = 0; c < this.specialCandiesToProcess.length; c++) this.processTempSpecial(this.specialCandiesToProcess[c]);
                this.processGrid(), this.processHitGrid(), this.board.checkMatchList = [], this.board.checkSpecialMatchList = [], this.grid.clear(), this.hitGrid.clear()
            }
        }, G.BoardMatcher.prototype.inflateHitGrid = function() {
            this.grid.loop(function(a, b, c) {
                a && (this.hitGrid.set(b - 1, c, "h"), this.hitGrid.set(b + 1, c, "h"), this.hitGrid.set(b, c - 1, "h"), this.hitGrid.set(b, c + 1, "h"))
            }, this)
        }, G.BoardMatcher.prototype.processHitGrid = function() {
            this.hitGrid.loop(function(a, b, c) {
                a && this.board.hitCell(b, c)
            }, this)
        }, G.BoardMatcher.prototype.processGrid = function() {
            this.grid.loop(function(a, b, c) {
                a && ("m" == a ? this.board.matchCell(b, c) : ("change" == a[0] && (this.board.getCandy(b, c) && this.board.getCandy(b, c).changeInto(a[1]), this.board.matchCellExceptCandy(b, c)), "match-move" == a[0] && this.board.matchCell(b, c, a[1], a[2], a[3])))
            }, this)
        }, G.BoardMatcher.prototype.processTempSpecial = function(a) {
            for (var b, c = 0, d = a.exe.length; c < d; c++) "loop" == (b = a.exe[c])[0] && this.processSpecialExeLoop(a, b[1]), "specific" == b[0] && this.processSpecialExeSpecific(a, b[1]), "matchType" == b[0] && this.processSpecialExeMatchType(a, b[1]), "changeTypeInto" == b[0] && this.processSpecialExeChangeTypeInto(a, b[1], b[2]), "perform" == b[0] && this.processSpecialExePerform(a, b[1]), "superSpiral" == b[0] && this.processSpecialExeSuperSpiral(a, b[1]);
            this.copyTempGridToMatchGrid()
        }, G.BoardMatcher.prototype.processSpecialExeLoop = function(a, b) {
            G.sfx.line.play();
            for (var c = a.cellX, d = a.cellY; this.board.isCellInBoardArea(c, d);) this.tempCheckAndMark(c, d), c += b.x, d += b.y
        }, G.BoardMatcher.prototype.processSpecialExePerform = function(a, b) {
            a[b]()
        }, G.BoardMatcher.prototype.processSpecialExeSpecific = function(a, b) {
            G.sfx.boom.play();
            var c, d, e = a.cellX,
                f = a.cellY;
            G.sb("fx").dispatch("explosion", a);
            for (var g = 0, h = b.length; g < h; g += 2) c = e + b[g], d = f + b[g + 1], this.tempCheckAndMark(c, d)
        }, G.BoardMatcher.prototype.processSpecialExeMatchType = function(a, b) {
            G.sfx.lightning.play(), "LASTMOVEDWITH" == b && (b = a.lastMovedWith ? a.lastMovedWith.candyType : game.rnd.between(1, this.board.MAX_NUMBER_OF_REGULAR_CANDY)), "CANDYTYPE" == b && (b = a.candyType), this.board.getCandy(a.cellX, a.cellY) == a && this.tempGrid.set(a.cellX, a.cellY, "m"), this.board.boardCandies.grid.loop(function(c, d, e) {
                c && c.candyType == b && this.tempCheckAndMark(d, e, !0) && G.sb("fx").dispatch("lightning", a, [d, e])
            }, this)
        }, G.BoardMatcher.prototype.processSpecialExeChangeTypeInto = function(a, b, c) {
            "CANDYTYPE" == b && (b = a.candyType), "SPECIALLASTMOVED" == c && (c = a.lastMovedWith.specialType), this.board.getCandy(a.cellX, a.cellY) == a && this.tempGrid.set(a.cellX, a.cellY, "m"), this.board.boardCandies.grid.loop(function(d, e, f) {
                d && d.candyType == b && !d.special && d !== a && this.board.isCellMatchable(e, f) && this.board.isMoveable(e, f) && (this.board.checkAfterFall.push(d), d.changeInto(c), G.sb("fx").dispatch("lightning", a, [e, f]))
            }, this)
        }, G.BoardMatcher.prototype.processSpecialExeSuperSpiral = function() {
            this.board.boardData.loop(function(a, b, c) {
                this.board.isCellOnBoard(b, c) && this.tempCheckAndMark(b, c)
            }, this)
        }, G.BoardMatcher.prototype.tempCheckAndMark = function(a, b, c) {
            return c || this.hitGrid.set(a, b, !0), !(!this.board.isCellMatchable(a, b) || this.grid.get(a, b)) && (candy = this.board.getCandy(a, b), candy.special ? (this.specialCandiesToProcess.push(candy), this.tempGrid.set(a, b, "mSpecial")) : this.tempGrid.set(a, b, "m"), this.hitGrid.set(a, b, !0), !0)
        }, G.BoardMatcher.prototype.processTemp = function(a) {
            for (var b, c, d, e, f, g = [a], h = 0; h < g.length; h++) {
                b = g[h], d = this.getHorizontalMatchPos(b, this.quickCheckCoords(b, this.horCoords, !1)), e = this.getVerticalMatchPos(b, this.quickCheckCoords(b, this.verCoords, !1));
                for (var i = 0, j = (f = [].concat(d, e)).length; i < j; i += 2) c = this.board.getCandy(f[i], f[i + 1]), -1 == g.indexOf(c) && g.push(c)
            }
            g.forEach(function(a) {
                a.special ? (this.tempGrid.set(a.cellX, a.cellY, "m"), this.specialCandiesToProcess.push(a)) : this.tempGrid.set(a.cellX, a.cellY, "m")
            }, this), this.searchAndProcessSpecialsInTemp(g[0]), this.copyTempGridToMatchGrid()
        }, G.BoardMatcher.prototype.copyTempGridToMatchGrid = function() {
            var a = 0,
                b = 0,
                c = 0,
                d = [],
                e = !1;
            this.tempGrid.loop(function(e, f, g) {
                if (e) {
                    a++, b += f, c += g;
                    var h = this.board.getCandy(f, g);
                    h && -1 === d.indexOf(h.candyType.toString()) && d.push(h.candyType.toString()), "mSpecial" == e ? this.grid.set(f, g, "m") : this.grid.set(f, g, e)
                }
            }, this), 1 == d.length && (e = d[0]), 0 < a && G.lvl.processMatch(a, b / a, c / a, e), this.tempGrid.clear()
        }, G.BoardMatcher.prototype.searchAndProcessSpecialsInTemp = function(a) {
            for (;;) {
                for (var b = 0, c = this.specialsCoordinates.length; b < c; b++)
                    for (var d = 0, e = this.specialsCoordinates[b][1].length; d < e; d++) {
                        var f = this.tempGrid.findPattern(this.specialsCoordinates[b][1][d], "m");
                        f && this.pushSpecialToTempGrid(f, this.specialsCoordinates[b][0], a) && d--
                    }
                break
            }
        }, G.BoardMatcher.prototype.pushSpecialToTempGrid = function(a, b, c) {
            var d, e = !1,
                f = a.length,
                g = ["change", b],
                h = a[0],
                i = a[1],
                j = !1;
            if (c)
                for (d = 0; d < f; d += 2)
                    if (this.board.getCandy(a[d], a[d + 1]), a[d] == c.cellX && a[d + 1] == c.cellY && !this.board.isBoosterChangeBlocked(a[d], a[d + 1])) {
                        e = !0, h = a[d], i = a[d + 1], this.tempGrid.set(a[d], a[d + 1], g), j = !0;
                        break
                    }
            for (d = 0; d < f; d += 2) 0 != d || e || this.board.isBoosterChangeBlocked(a[d], a[d + 1]) ? this.tempGrid.get(a[d], a[d + 1]) == g || this.board.getCandy(a[d], a[d + 1]).wrapped || this.board.boardCage.isToken(a[d], a[d + 1]) || (this.tempGrid.set(a[d], a[d + 1], ["match-move", 0, h, i]), j = !0) : (this.tempGrid.set(a[d], a[d + 1], g), j = !0);
            return j
        }, G.BoardMatcher.prototype.getHorizontalMatchPos = function(a, b) {
            var c = [],
                d = (a.cellX, a.cellY);
            if (!b) return c;
            var e = a.cellX,
                f = a.cellX;
            for (c.push(a.cellX, a.cellY); this.board.isCellMatchable(--e, d, a.candyType) && !this.grid.get(e, d);) c.push(e, d);
            for (; this.board.isCellMatchable(++f, d, a.candyType) && !this.grid.get(f, d);) c.push(f, d);
            return c
        }, G.BoardMatcher.prototype.getVerticalMatchPos = function(a, b) {
            var c = [],
                d = a.cellX,
                e = a.cellY;
            if (!b) return c;
            var f = e,
                g = e;
            for (c.push(a.cellX, a.cellY); this.board.isCellMatchable(d, --f, a.candyType) && !this.grid.get(d, f);) c.push(d, f);
            for (; this.board.isCellMatchable(d, ++g, a.candyType) && !this.grid.get(d, g);) c.push(d, g);
            return c
        }, G.BoardMatcher.prototype.getBirdMatchPos = function(a) {
            for (var b = [], c = a.cellX, d = a.cellY, e = 0; e < 4; e++) this.board.isCellMatchable(c + this.birdCoords[e][0], d + this.birdCoords[e][1], a.candyType) && this.board.isCellMatchable(c + this.birdCoords[e][2], d + this.birdCoords[e][3], a.candyType) && this.board.isCellMatchable(c + this.birdCoords[e][4], d + this.birdCoords[e][5], a.candyType) && b.push(c + this.birdCoords[e][0], d + this.birdCoords[e][1], c + this.birdCoords[e][2], d + this.birdCoords[e][3], c + this.birdCoords[e][4], d + this.birdCoords[e][5]);
            return b
        }, G.BoardMatcher.prototype.possibleDownMoves = [
            [-1, 1, 1, 1],
            [1, 1, 2, 1],
            [-2, 1, -1, 1],
            [0, 2, 0, 3]
        ], G.BoardMatcher.prototype.possibleRightMoves = [
            [2, 0, 3, 0],
            [1, 1, 1, 2],
            [1, -1, 1, 1],
            [1, -2, 1, -1]
        ], G.BoardMatcher.prototype.possibleLeftMoves = [
            [-3, 0, -2, 0],
            [-1, -2, -1, -1],
            [-1, -1, -1, 1],
            [-1, 1, -1, 2]
        ], G.BoardMatcher.prototype.possibleUpMoves = [
            [-1, -1, 1, -1],
            [1, -1, 2, -1],
            [-2, -1, -1, -1],
            [0, -3, 0, -2]
        ], G.BoardMatcher.prototype.horCoords = [
            [-1, 0, 1, 0],
            [-2, 0, -1, 0],
            [1, 0, 2, 0]
        ], G.BoardMatcher.prototype.verCoords = [
            [0, -1, 0, 1],
            [0, -1, 0, -2],
            [0, 1, 0, 2]
        ], G.BoardMatcher.prototype.birdCoords = [
            [-1, -1, -1, 0, 0, -1],
            [1, 0, 0, -1, 1, -1],
            [-1, 0, -1, 1, 0, 1],
            [1, 0, 0, 1, 1, 1]
        ], G.Candy = function(a, b) {
            this.grid = b, this.board = a, this.boardCandies = a.boardCandies, Phaser.Image.call(this, game, 0, 0), this.anchor.setTo(.5), this.wrapperImg = G.makeImage(0, 0, "blocker_chain_wrapped", .5, null), this.anchor.setTo(.5, .5), this.animationData = {
                active: !1
            }, this.fallData = {
                alpha0: this.board.cellYToPxIn(-1),
                alpha1: this.board.cellYToPxIn(0),
                alphaDistance: Math.abs(this.board.cellYToPxIn(-1) - this.board.cellYToPxIn(0)),
                active: !1,
                delay: 0,
                targetY: 0,
                targetX: 0,
                velY: 0,
                grav: G.lnf(2.5)
            }, this.kill()
        }, G.Candy.prototype = Object.create(Phaser.Image.prototype), G.Candy.prototype.init = function(a, b, c) {
            this.loadTexture(null), this.scale.setTo(1), this.candyType = !1, this.special = !1, this.specialType = !1, this.animationData.active = !1, this.fallData.active = !1, this.alpha = 1, this.angle = 0, this.scale.setTo(1), this.revive(), this.onMatchFx = !1, this.activatedByMove = !1, this.exe = [], this.matchable = !0, this.goalCandy = !1, this.blocker = !1, this.blockerHp = 0, this.wrapped = !1, this.infected = !1, this.chocolate = !1, this.cellX = a, this.cellY = b, this.x = this.board.cellXToPxIn(a), this.y = this.board.cellYToPxIn(b), this.changeInto(c, !0)
        }, G.Candy.prototype.fallTo = function(a, b, c) {
            this.setCell(a, b), this.fallData.active || G.sb("onCandyFallStart").dispatch(this), this.fallData.active = !0, this.fallData.delay = c || 0, this.fallData.velY = G.IMMEDIATE ? 1e3 : 0, this.fallData.targetY = this.board.cellYToPxIn(b), this.fallData.targetX = this.board.cellXToPxIn(a)
        }, G.Candy.prototype.fallFrom = function(a, b) {
            G.sb("onCandyFallStart").dispatch(this), this.y = this.board.cellYToPxIn(a), this.fallData.active = !0, this.fallData.delay = b || 0, this.fallData.velY = 0, this.fallData.targetX = this.board.cellXToPxIn(this.cellX), this.fallData.targetY = this.board.cellYToPxIn(this.cellY)
        }, G.Candy.prototype.movedWith = function(a) {
            this.lastMovedWith = a
        }, G.Candy.prototype.changeInto = function(a, b) {
            if (this.bringToTop(), G.specialCandies.isTypeSpecial(a)) {
                b || G.sb("fx").dispatch("changeCircle", this);
                var c = G.specialCandies.getSpecialData(a);
                this.special = !0, c.texture && (this.boardCandies.secondFloor.add(this), G.changeTexture(this, c.texture.replace("%CANDYTYPE%", this.candyType))), c.candyType && (this.candyType = "RANDOM" == c.candyType ? Math.random() : c.candyType), c.onMatchFx && (this.onMatchFx = c.onMatchFx.slice()), c.specialType && (this.specialType = c.specialType), G.sb("onCandyChangedIntoSpecial").dispatch(this.specialType), c.activatedByMove && (this.activatedByMove = !0), c.exe && (this.exe = c.exe.slice()), c.specialInit && this["changeInto" + G.capitalize(a)]()
            } else G.changeTexture(this, "candy_" + a), this.candyType = a, this.boardCandies.firstFloor.add(this); - 1 !== G.json.specialCandies.goalCandies.indexOf(this.candyType) && (this.matchable = !1, this.goalCandy = !0)
        }, G.Candy.prototype.changeIntoBlocker = function(a) {
            this.blocker = !0, this.blockerHp = a, G.changeTexture(this, "candy_blocker_" + a), this.matchable = !1
        }, G.Candy.prototype.removeBlocker = function() {
            this.blocker = !1, G.changeTexture(this, "candy_" + this.candyType), this.matchable = !0
        }, G.Candy.prototype.prepareToProcess = function() {
            this.startAnimation("biggerAndExplode")
        }, G.Candy.prototype.wrap = function() {
            this.wrapped = !0, this.wrapperImg.alpha = 1, this.wrapperImg.scale.setTo(1), G.changeTexture(this.wrapperImg, "blocker_chain_wrapped"), this.addChild(this.wrapperImg)
        }, G.Candy.prototype.unwrap = function() {
            G.sfx.brick_break.play(), G.sb("onCollectableRemove").dispatch("chain", this), game.add.tween(this.wrapperImg).to({
                width: 1.5 * this.wrapperImg.width,
                height: 1.5 * this.wrapperImg.height,
                alpha: 0
            }, 1e3, Phaser.Easing.Cubic.Out, !0).onComplete.add(function() {
                this.removeChild(this.wrapperImg)
            }, this), G.sb("fx").dispatch("changeCircle", this), G.sb("fxTop").dispatch("burstChainAnim", this, this), G.sfx.chain_rattle.play(), this.wrapped = !1, this.board.pushToFallCheckList(this)
        }, G.Candy.prototype.coverWithChocolate = function() {
            this.chocolateHp = 2, this.chocolate = !0
        }, G.Candy.prototype.hitChocolate = function() {
            G.sb("fx").dispatch("changeCircle", this), G.sb("fx").dispatch("chocolatePart", this), G.sb("fx").dispatch("chocolatePart", this), G.sb("fx").dispatch("chocolatePart", this), G.sb("fx").dispatch("chocolatePart", this), G.sfx.explosion_subtle.play(), 1 == --this.chocolateHp || (this.chocolate = !1, this.board.fallCheckList.push(this))
        }, G.Candy.prototype.detachFromGrid = function() {
            this.boardCandies.grid.set(this.cellX, this.cellY, null)
        }, G.Candy.prototype.hit = function() {
            this.blocker && (this.blockerHp--, 0 === this.blockerHp ? (this.candyType = "blocker", this.remove()) : G.changeTexture(this, "candy_blocker_" + this.blockerHp)), "infection" == this.candyType && (G.sb("fxTop").dispatch("burstInfectionAnim", this, this), this.remove()), "chest" == this.candyType && (G.sb("onChestOpen").dispatch(this), this.remove()), this.chocolate && this.hitChocolate()
        }, G.Candy.prototype.update = function() {
            this.updateFall(), this.updateAnimation(), this.chainAttachement && (this.chainAttachement.x = this.x, this.chainAttachement.y = this.y)
        }, G.Candy.prototype.updateFall = function() {
            if (this.fallData.active) {
                if (0 < this.fallData.delay) return this.fallData.delay -= 1 * G.deltaTime;
                this.fallData.velY += this.fallData.grav * G.deltaTime, this.y += this.fallData.velY * G.deltaTime, this.alpha = this.y < this.fallData.alpha1 ? this.y < this.fallData.alpha0 ? 0 : Math.abs(this.fallData.alpha0 - this.y) / this.fallData.alphaDistance : 1;
                var a = this.fallData.targetX - this.x,
                    b = this.fallData.targetY - this.y;
                Math.abs(a) > b && (this.x = this.fallData.targetX - b * game.math.sign(a)), this.y > this.fallData.targetY && (this.y = this.fallData.targetY, this.x = this.fallData.targetX, this.fallData.active = !1, this.startAnimation("bounce"), G.sfx["stone_impact_" + game.rnd.between(1, 3)].play(), G.sb("onCandyFallFinish").dispatch(this))
            }
        }, G.Candy.prototype.setCell = function(a, b) {
            this.grid.get(this.cellX, this.cellY) == this && this.grid.set(this.cellX, this.cellY, null), this.cellX = a, this.cellY = b, this.grid.set(a, b, this)
        }, G.Candy.prototype.isGoalCandy = function() {
            return -1 != this.boardCandies.goalCandies.indexOf(this)
        }, G.Candy.prototype.infect = function() {
            this.infected = !0, G.stopTweens(this.wrapperImg), this.wrapperImg.alpha = 1, this.wrapperImg.scale.setTo(1), G.changeTexture(this.wrapperImg, "infection_front"), game.add.tween(this.wrapperImg).from({
                alpha: 0,
                width: 0,
                height: 0
            }, 250, Phaser.Easing.Sinusoidal.Out, !0), this.addChild(this.wrapperImg), G.sb("onCandyInfect").dispatch(this)
        }, G.Candy.prototype.removeInfection = function() {
            G.sb("fxTop").dispatch("burstInfectionAnim", this, this), this.infected = !1, G.stopTweens(this.wrapperImg), this.board.pushToFallCheckList(this), game.add.tween(this.wrapperImg).to({
                alpha: 0
            }, 250, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.removeChild(this.wrapperImg)
            }, this), G.sb("onCandyInfectionRemove").dispatch(this)
        }, G.Candy.prototype.match = function(a, b, c) {
            if (this.matchable) {
                if (this.wrapped) return this.unwrap();
                if (this.infected) return this.removeInfection();
                if (!this.animationData.active) return this.detachFromGrid(), G.sb("onCandyMatch").dispatch(this), this.special ? (this.onMatchFx && this.onMatchFx.forEach(function(a) {
                    G.sb("fx").dispatch(a[0], this, a[1], this)
                }, this), game.camera.shake(.0075, 250), this.boardCandies.thirdFloor.add(this), this.startAnimation("growAndFade", a)) : G.lvl.isGoal(this.candyType) ? this.remove() : void(void 0 === b ? this.startAnimation("vanishAlphaBurst", a) : this.startAnimation("moveTo", [a, b, c]))
            }
        }, G.Candy.prototype.remove = function() {
            this.boardCandies.removeCandy(this)
        }, G.Candy.prototype.updateAnimation = function() {
            this.animationData.active && (this.animationData.func && this.animationData.func.call(this), this.animationData.active || G.sb("onCandyAnimationFinish").dispatch())
        }, G.Candy.prototype.startAnimation = function(a, b) {
            return this.animationData.active ? alert("during another animation") : void(this["animation-init-" + a] && (G.sb("onCandyAnimationStart").dispatch(), this.animationData.active = !0, this["animation-init-" + a](b)))
        }, G.Candy.prototype["animation-init-bounce"] = function() {
            return G.IMMEDIATE ? (this.animationData.active = !1, void G.sb("onCandyAnimationFinish").dispatch(this)) : void game.add.tween(this).to({
                y: this.y - G.l(5)
            }, 100, Phaser.Easing.Sinusoidal.Out, !0, 0, 0, !0).onComplete.add(function() {
                this.animationData.active = !1, G.sb("onCandyAnimationFinish").dispatch(this)
            }, this)
        }, G.Candy.prototype["animation-init-vanishAlphaBurst"] = function() {
            G.sb("fx").dispatch("burstCandy", this, this), G.sb("onCandyAnimationFinish").dispatch(this), this.remove()
        }, G.Candy.prototype["animation-init-vanish"] = function(a) {
            return G.IMMEDIATE ? (G.sb("onCandyAnimationFinish").dispatch(this), this.remove(), void this.scale.setTo(1)) : void game.add.tween(this.scale).to({
                x: 0,
                y: 0
            }, 200, Phaser.Easing.Sinusoidal.In, !0, a || 0).onComplete.add(function() {
                G.sb("onCandyAnimationFinish").dispatch(this), this.remove(), this.scale.setTo(1)
            }, this)
        }, G.Candy.prototype["animation-init-scaleEndlessly"] = function() {
            G.IMMEDIATE || game.add.tween(this.scale).to({
                x: .5,
                y: .5
            }, 300, Phaser.Easing.Sinusoidal.In, !0, 0, -1, !0)
        }, G.Candy.prototype["animation-init-shrink"] = function() {
            this.boardCandies.thirdFloor.add(this), this.bringToTop(), game.add.tween(this.scale).to({
                x: 0,
                y: 0
            }, 200, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(function() {
                G.sb("onCandyAnimationFinish").dispatch(this), this.remove()
            }, this)
        }, G.Candy.prototype["animation-init-growAndFade"] = function() {
            if (G.IMMEDIATE) return G.sb("onCandyAnimationFinish").dispatch(this), void this.remove();
            this.boardCandies.thirdFloor.add(this), this.bringToTop();
            var a = game.add.tween(this.scale).to({
                x: 2.5,
                y: 2.5
            }, 200, Phaser.Easing.Sinusoidal.In, !0);
            game.add.tween(this).to({
                alpha: 0
            }, 100, Phaser.Easing.Sinusoidal.In, !0, 100).onComplete.add(function() {
                a.stop(), G.sb("onCandyAnimationFinish").dispatch(this), this.remove()
            }, this)
        }, G.Candy.prototype["animation-init-biggerAndExplode"] = function(a) {
            return G.IMMEDIATE ? (this.board.checkSpecialMatchList.push(this), this.burst = !0, this.readyToProcess = !0, G.sb("onCandyAnimationFinish").dispatch(this), void this.remove()) : void(a ? game.time.events.add(a, function() {
                this.bringToTop(), game.add.tween(this.scale).to({
                    x: 1.5,
                    y: 1.5
                }, 300, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(function() {
                    this.board.checkSpecialMatchList.push(this), this.burst = !0, this.readyToProcess = !0, G.sb("onCandyAnimationFinish").dispatch(this), this.remove(), this.scale.setTo(1)
                }, this)
            }, this) : (this.bringToTop(), game.add.tween(this.scale).to({
                x: 1.5,
                y: 1.5
            }, 300, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(function() {
                this.board.checkSpecialMatchList.push(this), this.burst = !0, this.readyToProcess = !0, G.sb("onCandyAnimationFinish").dispatch(this), this.remove(), this.scale.setTo(1)
            }, this)))
        }, G.Candy.prototype["animation-init-moveTo"] = function(a) {
            if (G.IMMEDIATE) return G.sb("onCandyAnimationFinish").dispatch(this), void this.remove();
            if (a[0]) game.time.events.add(a[0], function() {
                var b = game.add.tween(this).to({
                    x: this.board.cellXToPxIn(a[1]),
                    y: this.board.cellYToPxIn(a[2])
                }, 300, Phaser.Easing.Sinusoidal.In, !0);
                game.add.tween(this).to({
                    alpha: 0
                }, 200, Phaser.Easing.Sinusoidal.In, !0, 100).onComplete.add(function() {
                    b.stop(), G.sb("onCandyAnimationFinish").dispatch(this), this.remove()
                }, this)
            }, this);
            else {
                var b = game.add.tween(this).to({
                    x: this.board.cellXToPxIn(a[1]),
                    y: this.board.cellYToPxIn(a[2])
                }, 300, Phaser.Easing.Sinusoidal.In, !0);
                game.add.tween(this).to({
                    alpha: 0
                }, 200, Phaser.Easing.Sinusoidal.In, !0, 100).onComplete.add(function() {
                    b.stop(), G.sb("onCandyAnimationFinish").dispatch(this), this.remove()
                }, this)
            }
        }, G.Candy.prototype["animation-init-moveToCombo"] = function(a) {
            if (G.IMMEDIATE) return G.sb("onCandyAnimationFinish").dispatch(this), void this.remove();
            if (0 !== a[3]) var b = game.add.tween(this).to({
                angle: a[3]
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0);
            var c = game.add.tween(this).to({
                x: this.board.cellXToPxIn(a[1]),
                y: this.board.cellYToPxIn(a[2])
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0);
            game.add.tween(this).to({
                alpha: .8
            }, 200, Phaser.Easing.Sinusoidal.In, !0, 200).onComplete.add(function() {
                c.stop(), b && b.stop(), G.sb("onCandyAnimationFinish").dispatch(this), game.time.events.add(1, this.remove, this)
            }, this)
        }, G.Candy.prototype.moveTo = function(a, b, c) {
            if (G.IMMEDIATE) return G.sb("onCandyAnimationFinish").dispatch(this), this.cellX = d[0], this.cellY = d[1], this.animationData.active = !1, void this.boardCandies.grid.set(this.cellX, this.cellY, this);
            this.board.getCandy(a, b);
            var d = [a, b];
            this.bringToTop(), G.sb("onCandyAnimationStart").dispatch(), this.animationData.active = !0, c && game.add.tween(this.scale).to({
                x: 2 * this.scale.x,
                y: 2 * this.scale.y
            }, 250, Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0), game.add.tween(this).to({
                x: this.board.cellXToPxIn(a),
                y: this.board.cellYToPxIn(b)
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                G.sb("onCandyAnimationFinish").dispatch(this), this.cellX = d[0], this.cellY = d[1], this.animationData.active = !1, this.boardCandies.grid.set(this.cellX, this.cellY, this)
            }, this)
        }, G.Candy.prototype.shuffleMoveToOwnCell = function() {
            var a = this.parent;
            this.special ? this.boardCandies.thirdFloor.add(this) : this.boardCandies.secondFloor.add(this), G.sb("onCandyAnimationStart").dispatch(), this.animationData.active = !0, game.add.tween(this).to({
                x: this.board.cellXToPxIn(this.cellX),
                y: this.board.cellYToPxIn(this.cellY)
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                a.add(this), G.sb("onCandyAnimationFinish").dispatch(this), this.animationData.active = !1
            }, this)
        }, G.CandySelection = function(a) {
            G.Image.call(this, 0, 0, null, .5), this.board = a, this.alpha = 0, game.add.existing(this), this.selection = G.makeImage(0, 0, "selected_cookie_new", .5, this), game.add.tween(this.selection.scale).to({
                x: 1.2,
                y: 1.2
            }, 800, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.frameIndex = 0, this.every = 3, this.frameCounter = 0, this.scale = this.board.scale
        }, G.CandySelection.prototype = Object.create(G.Image.prototype), G.CandySelection.prototype.selectCandy = function(a) {
            this.alpha = 1, this.x = this.board.boardCandies.x + a.x * this.board.scale.x, this.y = this.board.boardCandies.y + a.y * this.board.scale.y
        }, G.CandySelection.prototype.hide = function() {
            this.alpha = 0
        }, G.AttachementsGroup = function() {
            Phaser.Group.call(this, game), this.deadArray = []
        }, G.AttachementsGroup.prototype = Object.create(Phaser.Group.prototype), G.AttachementsGroup.prototype.attach = function(a, b) {
            var c;
            return (c = 0 < this.deadArray.length ? this.deadArray.pop() : new G.AttachementPart).init(a, b), this.add(c), c
        }, G.AttachementPart = function() {
            Phaser.Image.call(this, game, 0, 0, null), this.anchor.setTo(.5), this.kill()
        }, G.AttachementPart.prototype = Object.create(Phaser.Image.prototype), G.AttachementPart.prototype.init = function(a, b) {
            this.attachement = b, this.position = b.position, this.scale = b.scale, this.position, this["init" + G.capitalize(a)](b), this.revive()
        }, G.AttachementPart.prototype.postUpdate = function() {
            this.alive && (this.rotation = this.attachement.rotation)
        }, G.AttachementPart.prototype.remove = function() {
            this.kill(), this.parent.deadArray.push(this), this.parent.removeChild(this)
        }, G.AttachementPart.prototype.detach = function() {
            this.position = new Phaser.Point(this.x, this.y)
        }, G.AttachementPart.prototype.initChain = function() {
            G.changeTexture(this, "blocker_chain_wrapped")
        }, G.BoardFallMgr = function(a, b) {
            this.board = a, this.boardData = a.boardData, this.refiller = b, this.refillData = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
        }, G.BoardFallMgr.prototype.allCollumsFall = function() {
            this.refillData = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
            for (var a = 0; a < this.boardData.width; a++) this.collumnFall(a)
        }, G.BoardFallMgr.prototype.collumnFall = function(a) {
            for (var b = this.boardData.height - 1; 0 <= b; b--)
                if ("X" != this.boardData.get(a, b) && !this.board.getCandy(a, b) && !this.board.boardIce.isToken(a, b)) {
                    for (var c = !1, d = b; 0 <= d; d--) {
                        if (c = this.board.getCandy(a, d), this.board.isMoveBlocked(a, d)) {
                            c = !0;
                            break
                        }
                        if (c && this.board.isMoveable(a, d)) {
                            c.fallTo(a, b);
                            break
                        }
                    }
                    c || this.board.newFallingCandy(a, b, this.refiller.getTypeToDrop(a), this.refillData[a]--)
                }
        }, G.BoardFallMgr.prototype.collumnFall = function(a) {
            for (var b = this.boardData.height - 1; 0 <= b; b--)
                if ("X" != this.boardData.get(a, b) && !this.board.getCandy(a, b) && !this.board.boardIce.isToken(a, b)) {
                    for (var c = !1, d = b; 0 <= d; d--) {
                        if (c = this.board.getCandy(a, d), this.board.isMoveBlocked(a, d)) {
                            c = !0;
                            break
                        }
                        if (c && this.board.isMoveable(a, d)) {
                            c.fallTo(a, b);
                            break
                        }
                    }
                    c || this.board.newFallingCandy(a, b, this.refiller.getTypeToDrop(a), this.refillData[a]--)
                }
        }, G.BoardFallMgr.prototype.isCellSolid = function(a, b) {
            return b == this.boardData.height || "X" == this.boardData.get(a, b) || this.board.getCandy(a, b)
        }, G.BoardFallMgr.prototype.crossCollumnFall = function() {
            for (var a = !1, b = 1, c = this.boardData.height - 1; 0 <= c; c--)
                for (var d = 0; d < this.boardData.width; d++)
                    if (this.board.isCellOnBoard(d, c) && !this.isCellSolid(d, c) && this.isCellSolid(d, c + 1) && !this.board.isMoveBlocked(d, c)) {
                        if (this.board.isMoveable(d + b, c - 1)) {
                            this.board.getCandy(d + b, c - 1).fallTo(d, c), this.collumnFall(d + b), a = !0;
                            continue
                        }
                        if (this.board.isMoveable(d - b, c - 1)) {
                            this.board.getCandy(d - b, c - 1).fallTo(d, c), this.collumnFall(d - b), a = !0;
                            continue
                        }
                        b *= -1
                    }
            return a
        }, G.InputController = function(a) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.board = a, this.booster = null, this.clicked = !1, this.clickedCell = !1, this.anyWindowOpen = !1, this.possibleCandies = [], G.sb("onWindowOpened").add(function() {
                this.anyWindowOpen = !0
            }, this), G.sb("onAllWindowsClosed").add(function() {
                this.anyWindowOpen = !1
            }, this), this.state.EDITOR || game.input.onDown.add(this.onClick, this), game.input.onUp.add(function() {
                this.clicked = !1
            }, this), this.locked = !1
        }, G.InputController.prototype = Object.create(Phaser.Group.prototype), G.InputController.prototype.update = function() {
            this.board.tileShade.visible = !1;
            var a = this.pointerToCell2(game.input.activePointer);
            if (game.device.desktop && !G.lvl.goalAchieved && this.board.isCellOnBoard(a[0], a[1]) && (this.board.tileShade.visible = !0, this.board.tileShade.x = this.board.cellXToPxIn(a[0]), this.board.tileShade.y = this.board.cellYToPxIn(a[1])), this.canMakeMove() && this.clicked) {
                if (0 < this.possibleCandies.length && (-1 == this.possibleCandies.indexOf(this.board.getCandy(this.clickedCell)) || -1 == this.possibleCandies.indexOf(this.board.getCandy(a)))) return;
                a && this.board.isMoveable(a) && this.areNeighbours(this.clickedCell, a) && this.board.getCandy(a) && (this.board.makeMove(this.board.getCandy(this.clickedCell), this.board.getCandy(a)), this.clicked = !1, this.clickedCell = null)
            }
        }, G.InputController.prototype.canMakeMove = function() {
            return !this.locked && !!this.board.actionManager.noAction && !G.lvl.goalAchieved && !this.anyWindowOpen
        }, G.InputController.prototype.onClick = function(a) {
            if (this.canMakeMove()) {
                var b = this.pointerToCell(a);
                if (b && this.board.isMoveable(b[0], b[1]) && this.board.getCandy(b)) {
                    if (G.sfx.pop.play(), 0 === G.lvl.lvlNr || 1 === G.lvl.lvlNr || G.lvl.lvlNr, this.clickedCell && Math.abs(this.clickedCell[0] - b[0]) + Math.abs(this.clickedCell[1] - b[1]) == 1) {
                        if (!(0 < this.possibleCandies.length)) return this.board.makeMove(this.board.getCandy(this.clickedCell), this.board.getCandy(b)), this.clickedCell = null, void(this.clicked = !1);
                        if (-1 < this.possibleCandies.indexOf(this.board.getCandy(this.clickedCell)) && -1 < this.possibleCandies.indexOf(this.board.getCandy(b))) return this.board.makeMove(this.board.getCandy(this.clickedCell), this.board.getCandy(b)), this.clickedCell = null, void(this.clicked = !1)
                    }
                    this.clicked = !0, this.clickedCell = b
                }
            }
        }, G.InputController.prototype.pointerToCell = function(a) {
            if (this.anyWindowOpen) return !1;
            var b = a.worldX,
                c = a.worldY;
            return !!this.isPointerInRange(a) && [Math.floor((b - (this.board.x + this.board.offsetX)) / (this.board.tilesize * this.board.scale.x)), Math.floor((c - (this.board.y + this.board.offsetY)) / (this.board.tilesize * this.board.scale.y))]
        }, G.InputController.prototype.pointerToCell2 = function(a) {
            var b = a.worldX,
                c = a.worldY;
            return [Math.floor((b - (this.board.x + this.board.offsetX)) / (this.board.tilesize * this.board.scale.x)), Math.floor((c - (this.board.y + this.board.offsetY)) / (this.board.tilesize * this.board.scale.y))]
        }, G.InputController.prototype.isPointerInRange = function(a) {
            var b = a.worldX,
                c = a.worldY;
            return !(b < this.board.x + this.board.offsetX || b > this.board.x + this.board.offsetX + this.board.width || c < this.board.y + this.board.offsetY || c > this.board.y + this.board.offsetY + this.board.height)
        }, G.InputController.prototype.areNeighbours = function(a, b) {
            return a[0] == b[0] ? 1 == Math.abs(a[1] - b[1]) : a[1] == b[1] ? 1 == Math.abs(a[0] - b[0]) : void 0
        }, G.MatchList = function() {
            this.list = []
        }, G.MatchList.prototype.push = function(a) {
            for (var b = 0, c = this.list.length; b < c; b++)
                if (this.list[b][0] == a[0] && this.list[b][1] == a[1]) return;
            this.list.push(a)
        }, G.MatchList.prototype.remove = function(a) {
            for (var b = 0, c = this.list.length; b < c; b++)
                if (this.list[b][0] == a[0] && this.list[b][1] == a[1]) return void this.list.splice(b, 1)
        }, G.MatchList.prototype.addHorizontal = function(a, b, c) {
            for (; a <= b; a++) this.push([a, c])
        }, G.MatchList.prototype.addVertical = function(a, b, c) {
            for (; c <= b; b--) this.push([a, b])
        }, G.MatchList.prototype.loop = function(a, b) {
            for (var c = 0, d = this.list.length; c < d; c++) a.call(b || this, this.list[c])
        }, G.Refiller = function(a, b) {
            this.board = b, this.drops = a.drops, this.goalDrops = a.goalDrops ? JSON.parse(JSON.stringify(a.goalDrops)) : [], this.predefinedDrops = a.predefinedDrops ? JSON.parse(JSON.stringify(a.predefinedDrops)) : [], void 0 === this.drops.chest && (this.drops.chest = 0), void 0 === this.drops.infection && (this.drops.infection = 0), void 0 === this.drops.chain && (this.drops.chain = 0), void 0 === this.drops.goalCandy && (this.drops.goalCandy = 0), this.drops.chest *= G.lvl.coinChanceProb
        }, G.Refiller.prototype.getTypeToDrop = function(a) {
            var b = this.checkPredifinedDrops(a);
            if (b) return "r" === b && (b = game.rnd.between(1, this.board.MAX_NUMBER_OF_REGULAR_CANDY)), b;
            this.substractGoalDropCounter();
            var c = this.checkGoalDropList();
            if (c) return c;
            var d = Math.random() < this.drops.goalCandy / 100,
                e = Math.random() < this.drops.chest / 100,
                f = Math.random() < this.drops.chain / 100,
                g = Math.random() < this.drops.infection / 100;
            if (d) return "goalCandy";
            if (e) return "chest";
            if (g) return "infection";
            var h = game.rnd.between(1, this.board.MAX_NUMBER_OF_REGULAR_CANDY);
            return f && 0 == (h = "CHAIN" + h) && alert(h), h
        }, G.Refiller.prototype.checkPredifinedDrops = function(a) {
            return this.predefinedDrops[a] ? this.predefinedDrops[a].shift() : null
        }, G.Refiller.prototype.checkGoalDropList = function() {
            for (var a = 0, b = this.goalDrops.length; a < b; a++)
                if (this.goalDrops[a][1] <= 0) {
                    var c = this.goalDrops[a][0];
                    return this.goalDrops.splice(a, 1), c
                }
            return !1
        }, G.Refiller.prototype.substractGoalDropCounter = function() {
            for (var a = 0, b = this.goalDrops.length; a < b; a++) this.goalDrops[a][1] = this.goalDrops[a][1] - 1
        }, G.Action = function(a, b, c) {
            this.state = game.state.getCurrentState(), this.board = a, this.am = b, this.args = c
        }, G.Action.prototype.finish = function() {
            this.am.removeAction(this)
        }, G.ActionBoosterMatch = function(a, b, c) {
            G.Action.call(this, a, b, c), this.clickedCandy = !1, this.availableCandies = [], this.inputController = this.board.inputController, this.signalBinding = game.input.onDown.add(function(a) {
                var b = this.inputController.pointerToCell(a);
                if (b) {
                    var c = this.board.getCandy(b[0], b[1]);
                    !c || 0 != this.availableCandies.length && -1 == this.availableCandies.indexOf(c) || (G.sfx.pop.play(), this.clickedCandy = c, G.saveState.useBooster(this.args[0]))
                }
            }, this), this.boosterInit = !1
        }, G.ActionBoosterMatch.prototype = Object.create(G.Action.prototype), G.ActionBoosterMatch.prototype.update = function() {
            this.clickedCandy && (this.boosterInit || this.board.duringAnimation || this.board.duringFall || (this.boosterInit = !0, this.signalBinding.detach(), this.board.boardCandies.boosterFxGroup.add(3 == this.args[0] ? new G.BoosterHorizontal(this.clickedCandy.cellX, this.clickedCandy.cellY, this.args[0]) : 4 == this.args[0] ? new G.BoosterVertical(this.clickedCandy.cellX, this.clickedCandy.cellY, this.args[0]) : new G.Booster(this.clickedCandy.cellX, this.clickedCandy.cellY, this.args[0]))))
        }, G.ActionBoosterMatch.prototype.finish = function() {
            this.signalBinding.detach(), this.am.removeAction(this)
        }, G.ActionBoosterSwap = function(a, b, c) {
            G.Action.call(this, a, b, c), this.availableCandies = [], this.clickedCandy = !1, this.clickedCandy2 = !1, this.madeMove = !1, this.inputController = this.board.inputController, this.signalBinding = game.input.onDown.add(function(a) {
                var b = this.inputController.pointerToCell(a);
                if (b && this.board.isMoveable(b[0], b[1])) {
                    var c = this.board.getCandy(b[0], b[1]);
                    if (c.goalCandy) return;
                    if (!this.clickedCandy && (0 == this.availableCandies.length || -1 != this.availableCandies.indexOf(c))) return this.selection = this.board.candySelection, this.selection.selectCandy(c), G.sb("onBoosterSwapCandySelect").dispatch(c), this.clickedCandy = c;
                    if (this.clickedCandy != c && (0 == this.availableCandies.length || -1 != this.availableCandies.indexOf(c))) {
                        if (G.lvl.tutOpen) {
                            var d = game.state.getCurrentState().tut;
                            game.add.tween(d.hand).to({
                                alpha: 0
                            }, 300, Phaser.Easing.Sinusoidal.In, !0)
                        }
                        this.clickedCandy2 = c, G.saveState.useBooster(1)
                    }
                }
            }, this)
        }, G.ActionBoosterSwap.prototype = Object.create(G.Action.prototype), G.ActionBoosterSwap.prototype.update = function() {
            this.clickedCandy && this.clickedCandy2 && (this.madeMove || (this.madeMove = !0, this.signalBinding.detach(), this.selection && this.selection.hide(), this.clickedCandy2.moveTo(this.clickedCandy.cellX, this.clickedCandy.cellY), this.clickedCandy.moveTo(this.clickedCandy2.cellX, this.clickedCandy2.cellY, !0)), this.board.duringAnimation || this.board.duringFall || (this.board.matcher.isMoveValid(this.clickedCandy) && this.board.checkMatchList.push(this.clickedCandy), this.board.matcher.isMoveValid(this.clickedCandy2) && this.board.checkMatchList.push(this.clickedCandy2), 0 < this.board.checkMatchList.length && this.am.newAction("processMatch"), G.sb("onBoosterActionFinished").dispatch(), this.finish()))
        }, G.ActionBoosterSwap.prototype.finish = function() {
            this.selection && this.selection.hide(), this.signalBinding.detach(), this.am.removeAction(this)
        }, G.ActionMove = function(a, b, c) {
            G.Action.call(this, a, b, c), this.candy1 = c[0], this.candy1orgParent = this.candy1.parent, this.candy2 = c[1], this.candy2orgParent = this.candy2.parent, this.forceMove = c[2], this.back = !1, this.startAnimation()
        }, G.ActionMove.prototype = Object.create(G.Action.prototype), G.ActionMove.prototype.update = function() {
            if (this.updateAnimation(), this.progress += .075 * G.deltaTime, 1 <= this.progress) {
                if (this.finishAnimation(), this.back) return this.finish();
                if (this.candy1.movedWith(this.candy2), this.candy2.movedWith(this.candy1), this.candy1.special && this.candy2.special) {
                    if (this.checkCombo(this.candy1, this.candy2)) return G.lvl.madeMove(), this.am.newAction("processMatch"), this.finish();
                    if ("spiral" != this.candy1.specialType && "spiral" != this.candy2.specialType) return this.candy1.activatedByMove = !0, this.candy2.activatedByMove = !0, this.board.checkMatchList.push(this.candy1), this.board.checkMatchList.push(this.candy2), G.lvl.madeMove(), this.am.newAction("processMatch"), this.finish();
                    var a = "spiral" == this.candy1.specialType ? this.candy1 : this.candy2,
                        b = "spiral" != this.candy1.specialType ? this.candy1 : this.candy2;
                    return b.startAnimation("moveTo", [0, a.cellX, a.cellY]), a.exe = [
                        ["changeTypeInto", 1 <= b.candyType ? b.candyType : game.rnd.between(1, this.board.MAX_NUMBER_OF_REGULAR_CANDY), b.specialType]
                    ], this.board.checkMatchList.push(a), G.lvl.madeMove(), this.am.newAction("processMatch"), this.finish()
                }
                if (this.additionalChecks(this.candy1, this.candy2) && (this.board.matcher.isMoveValid(this.candy1) && this.board.checkMatchList.push(this.candy1), this.board.matcher.isMoveValid(this.candy2) && this.board.checkMatchList.push(this.candy2)), 0 != this.board.checkMatchList) return this.candy1.movedWith(this.candy2), this.candy2.movedWith(this.candy1), this.forceMove || G.lvl.madeMove(), this.am.newAction("processMatch"), this.finish();
                this.back || this.forceMove ? this.finish() : (this.back = !0, this.startAnimation())
            }
        }, G.ActionMove.prototype.additionalChecks = function(a, b) {
            var c = [a, b].find(function(a) {
                    return "spiral" == a.specialType
                }),
                d = [a, b].find(function(a) {
                    return "goalCandy" === a.candyType
                }),
                e = [a, b].find(function(a) {
                    return "chest" === a.candyType
                });
            return !(c && d || c && e)
        }, G.ActionMove.prototype.startAnimation = function() {
            G.sfx.exchange.play(), this.candy1anim = {
                startX: this.candy1.x,
                deltaX: this.candy2.x - this.candy1.x,
                startY: this.candy1.y,
                deltaY: this.candy2.y - this.candy1.y
            }, this.board.boardCandies.secondFloor.add(this.candy1), this.candy2anim = {
                startX: this.candy2.x,
                deltaX: this.candy1.x - this.candy2.x,
                startY: this.candy2.y,
                deltaY: this.candy1.y - this.candy2.y
            }, this.board.boardCandies.secondFloor.add(this.candy2), this.candy1.bringToTop(), this.progress = 0, G.IMMEDIATE && (this.progress = 1)
        }, G.ActionMove.prototype.finishAnimation = function() {
            this.board.swapCandies(this.candy1, this.candy2), this.candy1.x = this.board.cellXToPxIn(this.candy1.cellX), this.candy1.y = this.board.cellYToPxIn(this.candy1.cellY), this.candy1.scale.setTo(1), this.candy1orgParent.add(this.candy1), this.candy2.x = this.board.cellXToPxIn(this.candy2.cellX), this.candy2.y = this.board.cellYToPxIn(this.candy2.cellY), this.candy2orgParent.add(this.candy2)
        }, G.ActionMove.prototype.updateAnimation = function() {
            var a = Phaser.Easing.Sinusoidal.InOut(this.progress);
            this.candy1.x = this.candy1anim.startX + a * this.candy1anim.deltaX, this.candy1.y = this.candy1anim.startY + a * this.candy1anim.deltaY, this.candy1.scale.setTo(2 - 2 * Math.abs(.5 - a)), this.candy2.x = this.candy2anim.startX + a * this.candy2anim.deltaX, this.candy2.y = this.candy2anim.startY + a * this.candy2anim.deltaY
        }, G.ActionMove.prototype.checkCombo = function(a, b) {
            for (var c, d = 0, e = G.specialCandies.combos.length; d < e; d++)
                if (c = G.specialCandies.combos[d], a.specialType == c[0] && b.specialType == c[1] || a.specialType == c[1] && b.specialType == c[0]) {
                    var f = c[3];
                    return "vertical" != c[0] && "horizontal" != c[0] || "cross" != c[1] || "vertical" != a.specialType && "horizontal" != a.specialType || (game.add.tween(a).to({
                        angle: c[3]
                    }, 300, Phaser.Easing.Sinusoidal.InOut, !0), f = 0), a.changeInto(c[2]), b.detachFromGrid(), b.startAnimation("moveToCombo", [0, a.cellX, a.cellY, f]), a.onMatchFx || (a.onMatchFx = []), a.onMatchFx.push(["dummyComboGrowAndFade", [b.frameName, f]]), b.bringToTop(), b.candyType = Math.random(), a.activatedByMove = !0, this.board.checkMatchList.push(this.candy1), !0
                }
            return !1
        }, G.ActionProcessFall = function(a, b, c) {
            G.Action.call(this, a, b, c), this.madeCrossCollumn = !1, this.board.fallMgr.allCollumsFall()
        }, G.ActionProcessFall.prototype = Object.create(G.Action.prototype), G.ActionProcessFall.prototype.update = function() {
            if (!this.board.duringAnimation && !this.board.duringFall) {
                if (!this.madeCrossCollumn) {
                    for (; this.board.fallMgr.crossCollumnFall(););
                    return void(this.madeCrossCollumn = !0)
                }
                if (this.board.fallCheckList.forEach(function(a) {
                        this.board.matcher.quickMatchCheck(a) && this.board.checkMatchList.push(a)
                    }, this), this.board.fallCheckList = [], 0 != this.board.checkMatchList || 0 < this.board.checkAfterFall.length) {
                    for (var a = 0, b = this.board.checkAfterFall.length; a < b; a++) this.board.checkMatchList.push(this.board.checkAfterFall[a]);
                    this.board.checkAfterFall = [], this.am.newAction("processMatch")
                }
                G.sb("actionFallEnd").dispatch(), this.board.checkGoalCandy(), this.finish()
            }
        }, G.ActionProcessMatch = function(a, b, c) {
            G.Action.call(this, a, b, c), this.preFall = !0, this.processed = !1
        }, G.ActionProcessMatch.prototype = Object.create(G.Action.prototype), G.ActionProcessMatch.prototype.update = function() {
            this.board.duringAnimation || this.board.duringFall || this.board.matcher.processMatchList(), this.board.duringAnimation || this.board.duringFall || 0 != this.board.checkMatchList || 0 != this.board.checkSpecialMatchList || (this.am.newAction("processFall"), this.finish())
        }, G.ActionShuffle = function(a, b, c) {
            G.Action.call(this, a, b, c), this.state = game.state.getCurrentState(), this.board = this.state.board, this.shuffleText = new G.Text(0, 0, G.txt("No possible match - shuffling"), {
                font: "ComicSansBold",
                fill: "#fdfbe4",
                fontSize: 40,
                fontSize: "50px",
                stroke: "#73461c",
                strokeThickness: 7,
                lineSpacing: -25
            }, .5, 620), this.shuffleText.position.setTo(this.board.x + .5 * (this.board.width - 2 * this.board.tilesize), this.board.y + .45 * (this.board.height - 2 * this.board.tilesize)), game.state.getCurrentState().UIFxLayer.add(this.shuffleText), this.shuffleText.scale.setTo(0), game.add.tween(this.shuffleText.scale).to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !0), this.updateActive = !1, game.add.tween(this.shuffleText).to({
                alpha: 0
            }, G.IMMEDIATE ? 1 : 300, Phaser.Easing.Sinusoidal.Out, !0, G.IMMEDIATE ? 10 : 2e3).onComplete.add(function() {
                this.board.shuffleCandies(), this.updateActive = !0, this.shuffleText.destroy()
            }, this)
        }, G.ActionShuffle.prototype = Object.create(G.Action.prototype), G.ActionShuffle.prototype.update = function() {
            this.updateActive && (this.board.duringAnimation || this.board.duringFall || (this.updateActive = !1, 0 == this.board.checkMatchList.length ? this.finish() : G.IMMEDIATE ? this.finish() : game.time.events.add(300, this.finish, this)))
        }, G.ActionStartBoosters = function(a, b, c) {
            G.Action.call(this, a, b, c), this.state = game.state.getCurrentState(), this.boosters = [], this.popCounter = 0, this.positions = this.generatePositions(), this.positionIndex = 0, this.delay = 500, this.delayIncrease = 200;
            var d = this.state.startBoosters || [];
            this.normals = this.getTargetCandies(), this.normalsIndex = 0, this.initStartBoosters(d), G.MYSTERYGIFT && this.initMysteryGifts(G.saveState.mysteryGift_getCurrentGifts()), this.state.UIFxLayer.addMultiple(this.boosters), this.boosters.forEach(function(a) {
                a.events.onDestroy.add(function() {
                    this.popCounter++
                }, this)
            }, this)
        }, G.ActionStartBoosters.prototype = Object.create(G.Action.prototype), G.ActionStartBoosters.prototype.update = function() {
            this.popCounter == this.boosters.length && this.finish()
        }, G.ActionStartBoosters.prototype.generatePositions = function() {
            for (var a = [], b = .15; b <= .85; b += .14)
                for (var c = .15; c <= .85; c += .14) a.push([b + game.rnd.realInRange(-.02, .02), c + game.rnd.realInRange(-.02, .02)]);
            return Phaser.ArrayUtils.shuffle(a)
        }, G.ActionStartBoosters.prototype.initStartBoosters = function(a) {
            if (a[5] && (G.saveState.useStartBooster(5), (c = new G.StartBoosterBubble(this.positions[this.positionIndex++], "ui_booster_5", this.state.topBar.movesTxt, function() {
                    G.lvl.changeMoveNumber(5)
                })).goToTarget(this.delay), this.delay += this.delayIncrease, this.boosters.push(c), G.sb("onStartBoosterUsed").dispatch(6)), a[7]) {
                for (var b = 0; b < 3; b++) {
                    var c;
                    this.normals[this.normalsIndex + 1] && ((c = new G.StartBoosterBubble(this.positions[this.positionIndex++], "ui_booster_7", this.normals[this.normalsIndex++], function() {
                        this.target.changeInto(Math.random() < .5 ? "vertical" : "horizontal")
                    })).goToTarget(this.delay), this.delay += this.delayIncrease, this.boosters.push(c), G.sb("onStartBoosterUsed").dispatch(7))
                }
                G.saveState.useStartBooster(7)
            }
            a[8] && this.normals[this.normalsIndex + 1] && (G.saveState.useStartBooster(8), (c = new G.StartBoosterBubble(this.positions[this.positionIndex++], "ui_booster_8", this.normals[this.normalsIndex++], function() {
                this.target.changeInto("spiral")
            })).goToTarget(this.delay), this.delay += this.delayIncrease, this.boosters.push(c), G.sb("onStartBoosterUsed").dispatch(8))
        }, G.ActionStartBoosters.prototype.initMysteryGifts = function(a) {
            a.forEach(this.addChangeIntoBooster, this)
        }, G.ActionStartBoosters.prototype.addChangeIntoBooster = function(a) {
            var b = this.normals[this.normalsIndex + 1];
            if (b) {
                var c = {
                        cross: "ui_booster_9",
                        vertical: "ui_booster_3",
                        spiral: "ui_booster_8",
                        horizontal: "ui_booster_4"
                    }[a].replace("%%", b.frameName),
                    d = new G.StartBoosterBubble(this.positions[this.positionIndex], c, b, function() {
                        this.target.changeInto(a)
                    });
                this.normalsIndex++, this.positionIndex++, d.goToTarget(this.delay), this.delay += this.delayIncrease, this.boosters.push(d)
            }
        }, G.ActionStartBoosters.prototype.getTargetCandies = function() {
            var a = this.board.boardCandies.getNormalCandies();
            Phaser.ArrayUtils.shuffle(a);
            var b = [],
                c = [];
            return a.forEach(function(a) {
                b.find(function(b) {
                    return this.board.boardCandies.areCandiesNeighbours(a, b)
                }, this) ? c.push(a) : b.push(a)
            }, this), b.concat(c)
        }, G.BoardLayer = function(a, b) {
            Phaser.Group.call(this, game), this.position = a.position, this.scale = a.scale, this.board = a, this.boardData = a.boardData, this.config = b, this.grid = new G.GridArray(this.boardData.width, this.boardData.height, !1)
        }, G.BoardLayer.prototype = Object.create(Phaser.Group.prototype), G.BoardLayer.prototype.isMoveBlocked = function(a, b) {
            return this.isToken(a, b) && this.config.blockMove
        }, G.BoardLayer.prototype.isMatchBlocked = function(a, b) {
            return this.isToken(a, b) && this.config.blockMatch
        }, G.BoardLayer.prototype.isBoosterChangeBlocked = function(a, b) {
            return this.isToken(a, b) && this.config.blockMove
        }, G.BoardLayer.prototype.isProperChunk = function(a) {
            return 0 === a.indexOf(this.config.editorSymbol)
        }, G.BoardLayer.prototype.createToken = function(a, b, c) {
            var d = this.add(new this.config.constructor(this, a, b, c));
            return this.grid.set(a, b, d), d.grid = this.grid, d
        }, G.BoardLayer.prototype.import = function(a, b, c) {
            return 0 === c.indexOf(this.config.editorSymbol) && (this.config.hpToken && this.createToken(a, b, c[this.config.editorSymbol.length]), !0)
        }, G.BoardLayer.prototype.export = function(a, b) {
            var c = this.getToken(a, b);
            return c ? this.config.hpToken ? this.config.editorSymbol + c.hp : c.export ? c.export() : this.config.editorSymbol : null
        }, G.BoardLayer.prototype.getRandom = function() {
            if (0 == this.children.length) return !1;
            for (var a, b = this.children.length, c = (game.rnd.between(0, b), 0); c < b; c++)
                if ((a = this.children[c]) && this.grid.get(a.cellX, a.cellY) == a) return a;
            return !1
        }, G.BoardLayer.prototype.removeToken = function(a, b) {
            var c = this.grid.get(a, b);
            if (c) {
                this.grid.set(a, b, !1), this.config.collectableType && G.sb("onCollectableRemove").dispatch(this.config.collectableType, c, c.frameName), c.deathAnimation();
                var d = this.board.getCandy(a, b);
                d && (this.config.blockMove && this.board.pushToFallCheckList(d), this.config.blockMatch && this.board.checkMatchList.push(d))
            }
        }, G.BoardLayer.prototype.onMatch = function(a, b) {
            var c = this.getToken(a, b);
            return !c || (c.onMatch(), !this.config.stopMatchPropagation)
        }, G.BoardLayer.prototype.onHit = function(a, b) {
            var c = this.getToken(a, b);
            return !c || (c.onHit(), !this.config.stopHitPropagation)
        }, G.BoardLayer.prototype.isCellFree = function(a, b) {
            return !this.grid.get(a, b)
        }, G.BoardLayer.prototype.getToken = function(a, b) {
            return this.grid.get(a, b)
        }, G.BoardLayer.prototype.isToken = G.BoardLayer.prototype.getToken, G.BoardLayer.prototype.destroyCell = G.BoardLayer.prototype.removeToken, G.BoardToken = function(a, b, c, d, e) {
            Phaser.Image.call(this, game, a.board.cellXToPxIn(c), a.board.cellYToPxIn(d)), this.board = a.board, this.config = b, this.anchor.setTo(.5), this.layer = a, this.layerGrid = a.grid, this.cellX = c, this.cellY = d, this.hp = parseInt(e)
        }, G.BoardToken.prototype = Object.create(Phaser.Image.prototype), G.BoardToken.prototype.onMatch = function() {}, G.BoardToken.prototype.onHit = function() {}, G.BoardToken.prototype.remove = function() {
            this.layer.removeToken(this.cellX, this.cellY)
        }, G.BoardToken.prototype.deathAnimation = function() {
            this.destroy()
        }, G.BoardConcrete = function(a) {
            G.BoardLayer.call(this, a, {
                constructor: G.Concrete,
                maxHp: 3,
                hpToken: !0,
                editorSymbol: "cn",
                blockMove: !0,
                blockBoosterChange: !0,
                collectableType: "concrete",
                stopMatchPropagation: !0
            })
        }, G.BoardConcrete.prototype = Object.create(G.BoardLayer.prototype), G.BoardDirt = function(a) {
            G.BoardLayer.call(this, a, {
                constructor: G.Dirt,
                maxHp: 3,
                hpToken: !0,
                editorSymbol: "dirt",
                collectableType: "dirt"
            })
        }, G.BoardDirt.prototype = Object.create(G.BoardLayer.prototype), G.BoardDirtS = function(a) {
            G.BoardLayer.call(this, a, {
                constructor: G.DirtS,
                maxHp: 3,
                hpToken: !0,
                editorSymbol: "dS",
                collectableType: "dirtS"
            }), this.removedToken = !1, G.sb("onCollectableRemove").add(function(a) {
                "dirtS" === a && (this.removedToken = !0)
            }, this), G.sb("actionQueueEmptyAfterMove").add(function() {
                this.removedToken || this.spread(), this.removedToken = !1
            }, this)
        }, G.BoardDirtS.prototype = Object.create(G.BoardLayer.prototype), G.BoardDirtS.prototype.spread = function() {
            for (var a = ["U", "D", "L", "R", "I"], b = this.children.length, c = game.rnd.between(0, b - 1), d = 0; d < b; d++) {
                var e = this.children[(d + c) % b];
                Phaser.ArrayUtils.shuffle(a);
                for (var f = 0; f < a.length; f++) switch (a[f]) {
                    case "U":
                        if (this.isSpreadPossible(e.cellX, e.cellY - 1)) return void this.spreadToken(e.cellX, e.cellY - 1);
                        break;
                    case "D":
                        if (this.isSpreadPossible(e.cellX, e.cellY + 1)) return void this.spreadToken(e.cellX, e.cellY + 1);
                        break;
                    case "L":
                        if (this.isSpreadPossible(e.cellX - 1, e.cellY)) return void this.spreadToken(e.cellX - 1, e.cellY);
                        break;
                    case "R":
                        if (this.isSpreadPossible(e.cellX + 1, e.cellY)) return void this.spreadToken(e.cellX + 1, e.cellY);
                        break;
                    case "I":
                        if (e.hp < this.config.maxHp) return void e.increaseHp()
                }
            }
        }, G.BoardDirtS.prototype.isSpreadPossible = function(a, b) {
            return this.board.isCellOnBoard(a, b) && !this.getToken(a, b)
        }, G.BoardDirtS.prototype.spreadToken = function(a, b) {
            var c = this.createToken(a, b, 1);
            game.add.tween(c.scale).from({
                x: 0,
                y: 0
            }, 500, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.BoardIce = function(a) {
            G.BoardLayer.call(this, a, {
                constructor: G.Ice,
                maxHp: 4,
                hpToken: !0,
                editorSymbol: "ice",
                collectableType: "ice",
                blockMove: !0,
                blockMatch: !0,
                blockBoosterChange: !0,
                stopHitPropagation: !0
            })
        }, G.BoardIce.prototype = Object.create(G.BoardLayer.prototype), G.BoardJam = function(a) {
            G.BoardLayer.call(this, a, {
                constructor: G.Jam,
                maxHp: 3,
                hpToken: !0,
                editorSymbol: "jam",
                collectableType: "jam",
                blockMove: !0,
                blockMatch: !0,
                stopHitPropagation: !0
            }), this.removedToken = !1, G.sb("onCollectableRemove").add(function(a) {
                "jam" === a && (this.removedToken = !0)
            }, this), G.sb("actionQueueEmptyAfterMove").add(function() {
                this.removedToken || this.spread(), this.removedToken = !1
            }, this)
        }, G.BoardJam.prototype = Object.create(G.BoardLayer.prototype), G.BoardJam.prototype.spread = function() {
            for (var a = ["U", "D", "L", "R", "I"], b = this.children.length, c = game.rnd.between(0, b - 1), d = 0; d < b; d++) {
                var e = this.children[(d + c) % b];
                Phaser.ArrayUtils.shuffle(a);
                for (var f = 0; f < a.length; f++) switch (a[f]) {
                    case "U":
                        if (this.isSpreadPossible(e.cellX, e.cellY - 1)) return void this.spreadToken(e.cellX, e.cellY - 1);
                        break;
                    case "D":
                        if (this.isSpreadPossible(e.cellX, e.cellY + 1)) return void this.spreadToken(e.cellX, e.cellY + 1);
                        break;
                    case "L":
                        if (this.isSpreadPossible(e.cellX - 1, e.cellY)) return void this.spreadToken(e.cellX - 1, e.cellY);
                        break;
                    case "R":
                        if (this.isSpreadPossible(e.cellX + 1, e.cellY)) return void this.spreadToken(e.cellX + 1, e.cellY);
                        break;
                    case "I":
                        if (e.hp < this.config.maxHp) return void e.increaseHp()
                }
            }
        }, G.BoardJam.prototype.isSpreadPossible = function(a, b) {
            return this.board.isCellOnBoard(a, b) && !this.getToken(a, b)
        }, G.BoardJam.prototype.spreadToken = function(a, b) {
            var c = this.createToken(a, b, 1);
            game.add.tween(c.scale).from({
                x: 0,
                y: 0
            }, 500, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.Concrete = function(a, b, c, d) {
            G.BoardToken.call(this, a, {
                tokenType: "concrete"
            }, b, c, d), G.changeTexture(this, "concrete_" + this.hp)
        }, G.Concrete.prototype = Object.create(G.BoardToken.prototype), G.Concrete.prototype.onMatch = function() {
            G.sb("fx").dispatch("burstConcrete", this, this.hp), G.sfx.explosion_subtle.play(), this.hp--, G.sb("fxTop").dispatch("burstConcreteAnim", this, this), G.sfx.brick_break.play(), 0 == this.hp ? this.remove() : G.changeTexture(this, "concrete_" + this.hp)
        }, G.Dirt = function(a, b, c, d) {
            G.BoardToken.call(this, a, {
                tokenType: "dirt"
            }, b, c, d), G.changeTexture(this, "dirt_" + this.hp)
        }, G.Dirt.prototype = Object.create(G.BoardToken.prototype), G.Dirt.prototype.onMatch = function() {
            G.sb("fxTop").dispatch("burstDirtAnim", this, this), this.hp--, 0 < this.hp ? G.changeTexture(this, "dirt_" + this.hp) : this.remove()
        }, G.DirtS = function(a, b, c, d) {
            G.BoardToken.call(this, a, {
                tokenType: "dirtS"
            }, b, c, d), G.changeTexture(this, "dirt_s_" + this.hp), this.top
        }, G.DirtS.prototype = Object.create(G.BoardToken.prototype), G.DirtS.prototype.onMatch = function() {
            G.sb("fxTop").dispatch("burstDirtAnim", this, this), this.hp--, 0 < this.hp ? G.changeTexture(this, "dirt_s_" + this.hp) : this.remove()
        }, G.DirtS.prototype.increaseHp = function() {
            this.hp++, G.changeTexture(this, "dirt_s_" + this.hp)
        }, G.Ice = function(a, b, c, d) {
            G.BoardToken.call(this, a, {
                tokenType: "ice"
            }, b, c, d), G.changeTexture(this, "ice_front"), this.breakImg = G.makeImage(0, 0, null, .5, this), this.hp < 4 && G.changeTexture(this.breakImg, "ice_crack_" + this.hp)
        }, G.Ice.prototype = Object.create(G.BoardToken.prototype), G.Ice.prototype.onHit = function() {
            G.sfx.explosion_subtle.play(), G.sb("fxTop").dispatch("burstIce", this, this), this.hp--, 0 < this.hp ? G.changeTexture(this.breakImg, "ice_crack_" + this.hp) : (G.sb("fx").dispatch("smallCircle", this), this.remove())
        }, G.Jam = function(a, b, c, d) {
            G.BoardToken.call(this, a, {
                tokenType: "jam"
            }, b, c, d), G.changeTexture(this, "jam_" + this.hp)
        }, G.Jam.prototype = Object.create(G.BoardToken.prototype), G.Jam.prototype.onHit = function() {
            G.sfx.explosion_subtle.play(), this.hp--, 0 == this.hp ? (this.remove(), this.board.removeCandy(this.cellX, this.cellY, !0)) : G.changeTexture(this, "jam_" + this.hp)
        }, G.Jam.prototype.increaseHp = function() {
            this.hp++, G.changeTexture(this, "jam_" + this.hp)
        }, G.EditorDropPanel = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.goalTxt = new G.Text(0, 0, "% DROPS:", {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "white",
                stroke: "black",
                strokeThickness: 5
            }, [0, .5], 400), this.add(this.goalTxt), this.drops = G.lvlData.drops, this.makeField(50, "candy_chest", "chest"), this.makeField(100, "blocker_chain_wrapped", "chain"), this.makeField(150, "candy_infection", "infection"), this.makeField(200, "candy_goalCandy", "goalCandy")
        }, G.EditorDropPanel.prototype = Object.create(Phaser.Group.prototype), G.EditorDropPanel.prototype.makeField = function(a, b, c) {
            G.makeImage(50, a, b, [0, .5], this).scale.setTo(.6);
            var d = new G.Text(150, a - 30, this.drops[c] || "0", {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "#a8dbc6",
                stroke: "black",
                strokeThickness: 5
            });
            d.inputEnabled = !0, d.input.useHandCursor = !0, d.events.onInputDown.add(function() {
                var a = prompt("Enter % of getting " + c),
                    b = parseFloat(a);
                isNaN(b) || b < 0 || 100 <= b || (G.lvlData.drops[c] = b, this.setText(b.toString()))
            }, d), this.add(d)
        }, G.EditorDropZones = function(a, b) {
            Phaser.Group.call(this, game), this.board = a, this.position = a.position, this.scale = a.scale, this.dropZones = [], this.import(b)
        }, G.EditorDropZones.prototype = Object.create(Phaser.Group.prototype), G.EditorDropZones.prototype.import = function(a) {
            a && (this.update(), a.forEach(function(a, b) {
                a.forEach(function(a, c) {
                    this.dropZones[b].addElement(a, c)
                }, this)
            }, this))
        }, G.EditorDropZones.prototype.export = function() {
            return this.dropZones.filter(function(a) {
                return null !== a
            }).map(function(a) {
                return a.elements
            })
        }, G.EditorDropZones.prototype.update = function() {
            for (var a = Math.max(this.dropZones.length, this.board.boardData.width), b = 0; b < a; b++) b < this.board.boardData.width ? this.dropZones[b] ? this.dropZones[b].update() : this.dropZones[b] = this.add(new G.EditorDropZone(this.board, b)) : this.dropZones[b] && (this.dropZones[b].destroy(), this.dropZones[b] = null)
        }, G.EditorDropZone = function(a, b) {
            Phaser.Group.call(this, game), this.board = a, this.col = b, this.elements = [], this.elementsObj = [], this.x = b * a.tilesize, this.y = this.getTopTile() * a.tilesize, this.gfx = game.add.graphics(), this.add(this.gfx), this.redrawGfx(), this.gfx.inputEnabled = !0, this.keys = game.input.keyboard.addKeys({
                one: Phaser.Keyboard.ONE,
                two: Phaser.Keyboard.TWO,
                three: Phaser.Keyboard.THREE,
                four: Phaser.Keyboard.FOUR,
                five: Phaser.Keyboard.FIVE,
                six: Phaser.Keyboard.SIX,
                seven: Phaser.Keyboard.SEVEN,
                eight: Phaser.Keyboard.EIGHT,
                nine: Phaser.Keyboard.NINE,
                zero: Phaser.Keyboard.ZERO,
                bs: Phaser.Keyboard.BACKSPACE
            }), this.keys.one.onDown.add(function() {
                this.onBtnPressed("1")
            }, this), this.keys.two.onDown.add(function() {
                this.onBtnPressed("2")
            }, this), this.keys.three.onDown.add(function() {
                this.onBtnPressed("3")
            }, this), this.keys.four.onDown.add(function() {
                this.onBtnPressed("4")
            }, this), this.keys.five.onDown.add(function() {
                this.onBtnPressed("5")
            }, this), this.keys.six.onDown.add(function() {
                this.onBtnPressed("6")
            }, this), this.keys.seven.onDown.add(function() {
                this.onBtnPressed("r")
            }, this), this.keys.eight.onDown.add(function() {
                this.onBtnPressed("chest")
            }, this), this.keys.nine.onDown.add(function() {
                this.onBtnPressed("goalCandy")
            }, this), this.keys.bs.onDown.add(this.removeLastElement, this)
        }, G.EditorDropZone.prototype = Object.create(Phaser.Group.prototype), G.EditorDropZone.prototype.onBtnPressed = function(a) {
            if (this.gfx.input.pointerOver()) {
                var b = Math.floor((this.gfx.worldPosition.y - game.input.activePointer.worldY) / this.board.tilesize);
                this.addElement(a, b)
            }
        }, G.EditorDropZone.prototype.addElement = function(a, b) {
            this.elementsObj[b] && this.elementsObj[b].destroy(), this.elements[b] = a, this.elementsObj[b] = G.makeImage(.5 * this.board.tilesize, (b + .5) * this.board.tilesize * -1, "candy_" + a, .5, this), this.redrawGfx()
        }, G.EditorDropZone.prototype.removeLastElement = function() {
            this.gfx.input.pointerOver() && 0 < this.elements.length && (this.elements.splice(-1, 1), this.elementsObj.splice(-1, 1)[0].destroy()), this.redrawGfx()
        }, G.EditorDropZone.prototype.redrawGfx = function() {
            var a = this.board.tilesize;
            this.gfx.clear(), this.gfx.beginFill(255, .5);
            var b = Math.max(1, this.elements.length + 1) * a;
            this.gfx.drawRect(0, -b, a, b)
        }, G.EditorDropZone.prototype.update = function() {
            var a = this.getTopTile();
            null === a ? this.visible = !1 : this.y = a * this.board.tilesize, this.gfx.alpha = this.gfx.input.pointerOver() ? 1 : .1
        }, G.EditorDropZone.prototype.getTopTile = function() {
            for (var b = 0; b < this.board.boardData.height; b++)
                if (this.board.isCellOnBoard(this.col, b)) return b;
            return null
        }, G.EditorGoalDropPanel = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), G.lvlData.goalDrops || (G.lvlData.goalDrops = []), this.goalTxt = new G.Text(0, 0, "DROPS:", {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "white",
                stroke: "black",
                strokeThickness: 5
            }, [0, .5], 400), this.plusBtn = new G.Button(200, 0, "plus_ico", function() {
                this.makeGoalItem(this.goals.length)
            }, this), this.minusBtn = new G.Button(240, 0, "minus_ico", function() {
                0 != this.goals.length && this.removeGoal()
            }, this), this.addMultiple([this.goalTxt, this.plusBtn, this.minusBtn]), this.goals = [], this.loadLvlDrops()
        }, G.EditorGoalDropPanel.prototype = Object.create(Phaser.Group.prototype), G.EditorGoalDropPanel.prototype.loadLvlDrops = function() {
            G.lvlData.goalDrops.forEach(function(a, b) {
                this.makeGoalItem(b, a[0], a[1])
            }, this)
        }, G.EditorGoalDropPanel.prototype.removeGoal = function() {
            this.goals.pop().destroy(), G.lvlData.goalDrops.pop()
        }, G.EditorGoalDropPanel.prototype.makeGoalItem = function(a, b, c) {
            var d = game.make.group();
            d.goalIndex = a, d.x = G.l(100), d.y = G.l(50 + 50 * a), d.allGoals = ["goalCandy"], d.goalName = b || d.allGoals[0], d.goalNr = c || 5, d.img = G.makeImage(-50, 0, null, .5, d), d.img.scale.setTo(.6), d.img.refreshGraphics = function() {
                G.changeTexture(this, G.json.settings.goals[this.parent.goalName].sprite)
            }, d.img.refreshGraphics(), d.img.inputEnabled = !0, d.img.input.useHandCursor = !0, d.img.events.onInputDown.add(function() {
                var a = d.allGoals.indexOf(d.goalName);
                d.goalName = d.allGoals[(a + 1) % d.allGoals.length], G.lvlData.goalDrops[d.goalIndex][0] = d.goalName, d.img.refreshGraphics()
            }), d.nr = new G.Text(50, 0, d.goalNr.toString(), {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "#a8dbc6",
                stroke: "black",
                strokeThickness: 5
            }), d.add(d.nr), d.nr.anchor.setTo(0, .5), d.nr.inputEnabled = !0, d.nr.input.useHandCursor = !0, d.nr.events.onInputDown.add(function() {
                var a = prompt("Enter moves number");
                isNaN(parseInt(a)) || (G.lvlData.goalDrops[d.goalIndex][1] = parseInt(a), d.goalNr = a, d.nr.setText(d.goalNr.toString()))
            }), this.add(d), this.goals.push(d), a >= G.lvlData.goalDrops.length && G.lvlData.goalDrops.push([d.goalName, d.goalNr])
        }, G.EditorGoalPanel = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.state = game.state.getCurrentState(), this.goalTxt = new G.Text(0, 0, "GOAL:", {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "white",
                stroke: "black",
                strokeThickness: 5
            }, [0, .5], 400), this.plusBtn = new G.Button(160, 0, "plus_ico", function() {
                "points" !== G.lvlData.goal[0] && (4 <= this.goals.length || this.makeGoalItem(this.goals.length))
            }, this), this.plusBtn.IMMEDIATE = !0, this.minusBtn = new G.Button(200, 0, "minus_ico", function() {
                "points" !== G.lvlData.goal[0] && 1 != this.goals.length && this.removeGoal()
            }, this), this.minusBtn.IMMEDIATE = !0, this.changeGoalType = new G.Button(270, 0, "minus_ico", function() {
                G.lvlData.goal = "points" === G.lvlData.goal[0] ? ["collect", [
                    ["1", 5],
                    ["2", 5]
                ]] : ["points", 5e3], this.loadLvlGoals()
            }, this), this.changeGoalType.IMMEDIATE = !0, this.changeGoalType.angle = 90, this.addMultiple([this.goalTxt, this.plusBtn, this.minusBtn, this.changeGoalType]), this.goals = [], this.normals = ["1", "2", "3", "4", "5", "6"];
            var c = "points" === G.lvlData.goal[0] ? G.lvlData.goal[1] : 1e3;
            this.pointTxt = new G.Text(50, 50, c, {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "#a8dbc6",
                stroke: "black",
                strokeThickness: 5
            }), this.add(this.pointTxt), this.pointTxt.anchor.setTo(0, .5), this.pointTxt.inputEnabled = !0, this.pointTxt.input.useHandCursor = !0, this.pointTxt.events.onInputDown.add(function() {
                var a = prompt("Enter points target");
                isNaN(parseInt(a)) || (G.lvlData.goal[1] = parseInt(a), this.setText(parseInt(a)))
            }, this.pointTxt), this.loadLvlGoals()
        }, G.EditorGoalPanel.prototype = Object.create(Phaser.Group.prototype), G.EditorGoalPanel.prototype.update = function() {
            if ("points" !== G.lvlData.goal[0])
                for (var a = 0; a < this.goals.length; a++) this.updateGoal(this.goals[a])
        }, G.EditorGoalPanel.prototype.loadLvlGoals = function() {
            return this.goals.forEach(function(a) {
                a.destroy()
            }), this.goals = [], "points" == G.lvlData.goal[0] ? (this.pointTxt.visible = !0, void this.pointTxt.setText(G.lvlData.goal[1])) : (this.pointTxt.visible = !1, void G.lvlData.goal[1].forEach(function(a, b) {
                this.makeGoalItem(b, a[0], a[1])
            }, this))
        }, G.EditorGoalPanel.prototype.removeGoal = function() {
            this.goals.pop().destroy(), G.lvlData.goal[1].pop()
        }, G.EditorGoalPanel.prototype.makeGoalItem = function(a, b, c) {
            var d = game.make.group();
            d.goalIndex = a, d.x = G.l(50), d.y = G.l(50 + 50 * a), d.allGoals = Object.keys(G.json.settings.goals), d.goalName = b || d.allGoals[0], d.goalNr = c || 5, d.img = G.makeImage(0, 0, null, .5, d), d.img.scale.setTo(.6), d.img.refreshGraphics = function() {
                this.parent.goalName, G.changeTexture(this, G.json.settings.goals[this.parent.goalName].sprite)
            }, d.img.refreshGraphics(), d.img.inputEnabled = !0, d.img.input.useHandCursor = !0, d.img.events.onInputDown.add(function() {
                var a = d.allGoals.indexOf(d.goalName);
                d.goalName = d.allGoals[(a + 1) % d.allGoals.length], G.lvlData.goal[1][d.goalIndex][0] = d.goalName, d.img.refreshGraphics()
            }), d.alert = new G.Text(250, 0, "ALERT", {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "white",
                stroke: "black",
                strokeThickness: 5
            }), d.alert.anchor.setTo(0, .5), d.alert.tint = 16711680, d.alert.visible = !1, d.add(d.alert), d.nr = new G.Text(50, 0, d.goalNr.toString(), {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "#a8dbc6",
                stroke: "black",
                strokeThickness: 5
            }), d.add(d.nr), d.nr.anchor.setTo(0, .5), d.nr.inputEnabled = !0, d.nr.input.useHandCursor = !0, d.nr.events.onInputDown.add(function() {
                var a = prompt("Enter moves number");
                isNaN(parseInt(a)) || (G.lvlData.goal[1][d.goalIndex][1] = parseInt(a), d.goalNr = a, d.nr.setText(d.goalNr.toString()))
            }), this.add(d), this.goals.push(d), a >= G.lvlData.goal[1].length && G.lvlData.goal[1].push([d.goalName, d.goalNr])
        }, G.EditorGoalPanel.prototype.updateGoal = function(a) {
            var b = a.goalNr.toString();
            if (-1 !== this.normals.indexOf(a.goalName)) a.nr.setText(b), a.nr.fill = "#a8dbc6";
            else {
                var c, d = !1;
                "concrete" === a.goalName && (c = this.countConcrete()), "goalCandy" === a.goalName ? c = this.countGoalCandies() : "ice" === a.goalName ? c = this.countIce() : "dirt" === a.goalName ? c = this.countDirt() : "chain" === a.goalName ? (c = this.countChains(), d = 0 < G.lvlData.drops.chain) : "infection" === a.goalName && (c = this.countInfections(), d = 0 < G.lvlData.drops.infection), b += " (" + c + ")", a.nr.setText(" "), a.nr.setText(b), a.nr.fill = a.goalNr > c ? d ? "#ffa500" : "#ff0000" : "#a8dbc6"
            }
        }, G.EditorGoalPanel.prototype.countConcrete = function() {
            var a = 0;
            return this.state.board.boardCage.grid.loop(function(b) {
                null !== b && !1 !== b && a++
            }), a
        }, G.EditorGoalPanel.prototype.countGoalCandies = function() {
            var a = 0;
            return this.state.board.boardCandies.grid.loop(function(b) {
                null !== b && !1 !== b && "goalCandy" == b.candyType && a++
            }), G.lvlData.goalDrops.forEach(function(b) {
                "goalCandy" === b[0] && a++
            }), a
        }, G.EditorGoalPanel.prototype.countDirt = function() {
            var a = 0;
            return this.state.board.boardDirt.grid.loop(function(b) {
                null !== b && !1 !== b && a++
            }), a
        }, G.EditorGoalPanel.prototype.countChains = function() {
            var a = 0;
            return this.state.board.boardCandies.grid.loop(function(b) {
                null !== b && !1 !== b && b.wrapped && a++
            }), a
        }, G.EditorGoalPanel.prototype.countIce = function() {
            var a = 0;
            return this.state.board.boardIce.grid.loop(function(b) {
                null !== b && !1 !== b && a++
            }), a
        }, G.EditorGoalPanel.prototype.countInfections = function() {
            var a = 0;
            return this.state.board.boardCandies.grid.loop(function(b) {
                null !== b && !1 !== b && "infection" === b.candyType && a++
            }), a
        }, void 0 === G && (G = {}), G.EditorSidePanel = function(a) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.x = a, this.makeKeyLabels(0, 0), this.makeBoardSizeController(0, 150), this.makeMoveController(0, 220), this.makeMaxNumberController(0, 270), this.makeStarsReqController(0, 320), this.makeTutorialIdBtn(0, 370), this.goalPanel = new G.EditorGoalPanel(0, 470), this.add(this.goalPanel), this.dropPanel = new G.EditorDropPanel(350, 470), this.add(this.dropPanel), this.dropGoalPanel = new G.EditorGoalDropPanel(650, 470), this.add(this.dropGoalPanel), this.backBtn = this.makeTextBtn(0, 1370, "Back to WORLD MAP", function() {
                this.exportLevel(), game.state.start("EditorWorld", !0, !1, G.lvlNr)
            }, this), this.makeNextPrevExport(0, 1420)
        }, G.EditorSidePanel.prototype = Object.create(Phaser.Group.prototype), G.EditorSidePanel.prototype.makeTutorialIdBtn = function(a, b) {
            var c = this.add(game.add.group());
            c.position.setTo(a, b), c.label = c.add(this.makeText(0, 0, "Tutorial ID:"));
            var d = G.lvlData.tutID;
            c.switch = this.makeTextBtn(300, 0, d || "---", function() {
                var a = prompt("Enter tutorial ID");
                0 == a.length ? (delete G.lvlData.tutID, this.setText("---"), this.fill = "#a8dbc6") : (G.lvlData.tutID = a, this.setText(a), this.fill = G.json.tutorials[a] ? "green" : "orange")
            }), c.add(c.switch), d && G.json.tutorials[d] && (c.switch.fill = "green")
        }, G.EditorSidePanel.prototype.makeNextPrevExport = function(a, b) {
            this.makeTextBtn(a + 200, b, "Prev", function() {
                this.exportLevel(), game.state.start("Editor", !0, !1, Math.max(0, G.lvlNr - 1))
            }, this), this.makeTextBtn(a, b, "Play", function() {
                this.exportLevel(), game.state.start("Game", !0, !1, G.lvlNr, !0)
            }, this), this.makeTextBtn(a + 350, b, "Next", function() {
                this.exportLevel(), game.state.start("Editor", !0, !1, Math.min(G.json.levels.length - 1, G.lvlNr + 1))
            }, this), this.makeTextBtn(a + 600, b, "EXPORT", function() {
                this.exportLevel();
                var a = new Blob([JSON.stringify(G.json.levels)], {
                    type: "text/plain;charset=utf-8"
                });
                saveAs(a, "levels.json")
            }, this)
        }, G.EditorSidePanel.prototype.makeText = function(a, b, c) {
            return c = new G.Text(a, b, c, {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "white",
                stroke: "black",
                strokeThickness: 5
            }), this.add(c), c
        }, G.EditorSidePanel.prototype.makeTextBtn = function(a, b, c, d, e) {
            return (c = new G.Text(a, b, c, {
                font: "Verdana",
                fontWeight: "bold",
                fontSize: 40,
                fill: "#a8dbc6",
                stroke: "black",
                strokeThickness: 5
            })).inputEnabled = !0, c.input.useHandCursor = !0, c.events.onInputDown.add(d, e || c), this.add(c), c
        }, G.EditorSidePanel.prototype.makeMaxNumberController = function(a, b) {
            this.maxNrGroup = this.add(game.make.group()), this.maxNrGroup.x = G.l(a), this.maxNrGroup.y = G.l(b), this.maxNrLabel = this.makeText(0, 0, "Types of candies:"), this.maxNrGroup.add(this.maxNrLabel), this.maxNrBtn = this.makeTextBtn(400, 0, G.lvlData.nrOfTypes.toString(), function() {
                var a = prompt("Enter max candy number (4 or 5)"),
                    b = parseInt(a);
                isNaN(b) || (G.lvlData.nrOfTypes = parseInt(a), this.maxNrBtn.setText(parseInt(a).toString()))
            }, this), this.maxNrGroup.add(this.maxNrBtn)
        }, G.EditorSidePanel.prototype.makeMoveController = function(a, b) {
            this.moveControllerGroup = this.add(game.make.group()), this.moveControllerGroup.x = G.l(a), this.moveControllerGroup.y = G.l(b), this.moveLabel = this.makeText(0, 0, "Moves:"), this.movesNr = this.makeTextBtn(200, 0, G.lvlData.moves.toString(), function() {
                var a = prompt("Enter moves number");
                isNaN(parseInt(a)) || (G.lvlData.moves = parseInt(a), this.setText(parseInt(a).toString()))
            }), this.moveControllerGroup.addMultiple([this.moveLabel, this.movesNr])
        }, G.EditorSidePanel.prototype.makeStarsReqController = function(a, b) {
            this.starsReqGroup = this.add(game.make.group()), this.starsReqGroup.x = G.l(a), this.starsReqGroup.y = G.l(b), this.starsReqGroup.add(this.makeText(0, 0, "Stars:")), this.btns = [];
            for (var c = 0; c < 3; c++) this.btns[c] = this.makeTextBtn(200 + 150 * c, 0, G.lvlData.starsReq[c].toString(), function() {
                var a = prompt("Enter requirement for " + (this.index + 1) + " stars:"),
                    b = parseInt(a);
                isNaN(b) || (G.lvlData.starsReq[this.index] = b, this.setText(b.toString()))
            }), this.btns[c].index = c;
            this.starsReqGroup.addMultiple(this.btns)
        }, G.EditorSidePanel.prototype.makeKeyPreview = function(a, b, c, d) {
            var e = game.add.group();
            e.position.setTo(a, b);
            var f = G.makeImage(0, 0, d, 0, e),
                g = new G.Text(45, 30, c, {
                    font: "Verdana",
                    fontWeight: "bold",
                    fontSize: 20,
                    fill: "white",
                    stroke: "black",
                    strokeThickness: 5
                }, 0);
            e.add(g), f.width = G.l(60), f.height = G.l(60), this.add(e)
        }, G.EditorSidePanel.prototype.makeBoardSizeController = function(a, b) {
            this.makeText(a, b, "Board size:"), this.widthMinus = new G.Button(a + 320, b + 30, "minus_ico", function() {
                this.state.changeBoardSize(Math.max(4, this.state.board.boardData.width - 1), Math.max(4, this.state.board.boardData.height)), this.widthText.setText(this.state.board.boardData.width)
            }, this), this.widthMinus.IMMEDIATE = !0, this.widthText = this.makeText(a + 340, b, this.state.board.boardData.width.toString()), this.widthPlus = new G.Button(a + 390, b + 30, "plus_ico", function() {
                this.state.changeBoardSize(Math.max(4, this.state.board.boardData.width + 1), Math.max(4, this.state.board.boardData.height)), this.widthText.setText(this.state.board.boardData.width)
            }, this), this.widthPlus.IMMEDIATE = !0, this.heightMinus = new G.Button(a + 440, b + 30, "minus_ico", function() {
                this.state.changeBoardSize(Math.max(4, this.state.board.boardData.width), Math.max(4, this.state.board.boardData.height - 1)), this.heightText.setText(this.state.board.boardData.height)
            }, this), this.heightMinus.IMMEDIATE = !0, this.heightText = this.makeText(a + 460, b, this.state.board.boardData.height.toString()), this.heightPlus = new G.Button(a + 510, b + 30, "plus_ico", function() {
                this.state.changeBoardSize(Math.max(4, this.state.board.boardData.width), Math.max(4, this.state.board.boardData.height + 1)), this.heightText.setText(this.state.board.boardData.height)
            }, this), this.heightPlus.IMMEDIATE = !0, this.addMultiple([this.widthMinus, this.widthPlus, this.heightPlus, this.heightMinus])
        }, G.EditorSidePanel.prototype.makeKeyLabels = function(a, b) {
            var c = {
                    1: "candy_1",
                    2: "candy_2",
                    3: "candy_3",
                    4: "candy_4",
                    5: "candy_5",
                    6: "candy_6",
                    7: "candy_r",
                    8: "candy_chest",
                    9: "candy_goalCandy",
                    B: "candy_spiral"
                },
                d = {
                    E: "concrete_3",
                    R: "dirt_2",
                    T: "eraser",
                    Y: "tile_1",
                    W: "ice_front",
                    A: "blocker_chain_wrapped",
                    S: "candy_infection",
                    C: "collect_cell",
                    F: "dirt_s_2",
                    G: "jam_2",
                    S: "candy_infection",
                    0: "candy_r"
                };
            Object.keys(c).forEach(function(d, e) {
                this.makeKeyPreview(a + 70 * e, b, d, c[d])
            }, this), Object.keys(d).forEach(function(c, e) {
                this.makeKeyPreview(a + 70 * e, b + 70, c, d[c])
            }, this)
        }, G.EditorSidePanel.prototype.exportLevel = function() {
            var a = new G.GridArray(this.state.board.boardData.width, this.state.board.boardData.height);
            a.loop(function(a, b, c, d) {
                d[b][c] = [], "X" == s.board.boardData.data[b][c] && d[b][c].push("X");
                var e = s.board.boardDirt.grid.data[b][c];
                e && d[b][c].push("dirt" + e.hp);
                var f = s.board.boardDirtS.grid.data[b][c];
                f && d[b][c].push("dS" + f.hp);
                var g = s.board.boardJam.grid.data[b][c];
                g && d[b][c].push("jam" + g.hp);
                var h = s.board.boardIce.grid.data[b][c];
                h && d[b][c].push("ice" + h.hp);
                var i = s.board.boardCage.grid.data[b][c];
                i && d[b][c].push("cn" + i.hp);
                var j = s.board.boardCandies.grid.data[b][c];
                if (j) {
                    var k = j.candyType;
                    j.blocker && (k += ":B" + j.blockerHp), j.wrapped && (k += ":W"), j.infected && (k += ":I"), j.specialType && ("horizontal" == j.specialType && (k += ":H"), "vertical" == j.specialType && (k += ":V"), "cross" == j.specialType && (k += ":C"), "spiral" == j.specialType && (k = "1:S")), d[b][c].push(k)
                }
            }, this), G.lvlData.predefinedDrops = this.state.dropZones.export(), G.lvlData.levelData = a.data
        }, G.EditorWorldSidePanel = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.state = game.state.getCurrentState(), this.levelNr = this.makeText(0, 0, "LEVEL: --"), this.add(this.levelNr), this.starsReq = this.makeText(0, 50, "--"), this.add(this.starsReq), this.previewBitmap = game.add.bitmapData(400, 400), this.previewBitmapImg = this.add(this.previewBitmap.addToWorld(0, 100)), this.swapUpBtn = this.makeTextButton(0, 500, "Swap Up", 50, function() {
                void 0 !== this.state.selectedLevels[0] && this.swapLevels(this.state.selectedLevels[0] + 1)
            }, this), this.add(this.swapUpBtn), this.swapDownBtn = this.makeTextButton(0, 550, "Swap Down", 50, function() {
                void 0 !== this.state.selectedLevels[0] && this.swapLevels(Math.max(0, this.state.selectedLevels[0] - 1))
            }, this), this.add(this.swapDownBtn), this.changeNumberBtn = this.makeTextButton(0, 600, "Change number", 50, function() {
                var a = parseInt(prompt("New lvl nr")) - 1;
                isNaN(a) || this.swapLevels(a)
            }, this), this.add(this.changeNumberBtn), this.removeLevelsBtn = this.makeTextButton(0, 675, "Remove Levels", 50, this.removeLevels, this), this.removeLevelsBtn.fill = "red", this.add(this.removeLevelsBtn), this.playLevelBtn = this.makeTextButton(0, 750, "Play Level", 50, function() {
                void 0 !== this.state.selectedLevels[0] && (G.lvlNr = this.state.selectedLevels[0], game.state.start("Game", !0, !1, G.lvlNr, !0))
            }, this), this.add(this.playLevelBtn), this.editLevelBtn = this.makeTextButton(0, 800, "Edit Level", 50, function() {
                void 0 !== this.state.selectedLevels[0] && game.state.start("Editor", !0, !1, this.state.selectedLevels[0])
            }, this), this.add(this.editLevelBtn), this.copyLevelBtn = this.makeTextButton(0, 850, "Copy Levels", 50, function() {
                this.copyLevels()
            }, this), this.add(this.copyLevelBtn), this.exportBtn = this.makeTextButton(0, 950, "Export JSON", 50, function() {
                var a = new Blob([JSON.stringify(G.json.levels)], {
                    type: "text/plain;charset=utf-8"
                });
                saveAs(a, "levels.json")
            }, this), this.add(this.exportBtn), this.lineEditorInit()
        }, G.EditorWorldSidePanel.prototype = Object.create(Phaser.Group.prototype), G.EditorWorldSidePanel.prototype.makeText = function(a, b, c, d) {
            return c = new G.Text(a, b, c, {
                style: "font-white",
                fontSize: (d || 50) + "px"
            }), this.add(c), c
        }, G.EditorWorldSidePanel.prototype.makeTextButton = function(a, b, c, d, e, f) {
            return (c = this.makeText(a, b, c, d)).inputEnabled = !0, c.input.useHandCursor = !0, c.events.onInputDown.add(e, f), c
        }, G.EditorWorldSidePanel.prototype.swapLevels = function(a) {
            if (0 !== this.state.selectedLevels.length) {
                console.log("swap levels");
                var b = G.json.levels.map(function(a) {
                        return {
                            mapX: a.mapX,
                            mapY: a.mapY
                        }
                    }),
                    c = [];
                this.state.selectedLevels.forEach(function(a) {
                    c.push(G.json.levels[a])
                }), c.forEach(function(a) {
                    var b = G.json.levels.indexOf(a);
                    0 <= b && G.json.levels.splice(b, 1)
                }), G.json.levels.splice.apply(G.json.levels, [a, 0].concat(c)), G.json.levels.forEach(function(a, c) {
                    a && (a.mapX = b[c].mapX, a.mapY = b[c].mapY)
                });
                var d = c.map(function(a) {
                    return G.json.levels.indexOf(a)
                });
                this.state.selectLevel(d)
            }
        }, G.EditorWorldSidePanel.prototype.copyLevels = function() {
            var a = this.state.selectedLevels.map(function(a) {
                var b = JSON.parse(JSON.stringify(G.json.levels[a]));
                return b.mapX += 150, b
            });
            G.json.levels = G.json.levels.concat(a), this.state.fillSaveState3Stars(), this.state.map.refreshButtons();
            var b = a.map(function(a) {
                return G.json.levels.indexOf(a)
            });
            this.state.selectLevel(b)
        }, G.EditorWorldSidePanel.prototype.removeLevels = function() {
            if (confirm("ARE YOU SURE?") && 0 !== this.state.selectedLevels.length) {
                var b = [];
                this.state.selectedLevels.forEach(function(a) {
                    b.push(G.json.levels[a])
                }), b.forEach(function(a) {
                    var b = G.json.levels.indexOf(a);
                    0 <= b && G.json.levels.splice(b, 1)
                }), this.state.selectLevel(null)
            }
        }, G.EditorWorldSidePanel.prototype.refresh = function() {
            void 0 === s.selectedLevels[0] ? (this.levelNr.setText("LEVEL: --"), this.starsReq.setText("--"), this.previewBitmapImg.alpha = 0) : (this.previewBitmapImg.alpha = 1, G.makeLvlPreview(G.json.levels[s.selectedLevels[0]], this.previewBitmap), this.levelNr.setText("LEVEL: " + (s.selectedLevels[0] + 1)), this.starsReq.setText(G.json.levels[s.selectedLevels[0]].starsReq.toString()))
        }, G.makeLvlPreview = function(a, b) {
            var c = game.make.image(0, 0, null);
            b.clear(), b.fill(0, 0, 0, 1);
            for (var d = a.levelData.length, e = a.levelData[0].length, f = b.width / d, g = b.height / e, h = Math.min(f, g), i = {
                    1: "candy_1",
                    2: "candy_2",
                    3: "candy_3",
                    4: "candy_4",
                    5: "candy_5",
                    6: "candy_6",
                    r: "candy_r",
                    goalCandy: "candy_goalCandy",
                    cn1: "concrete_1",
                    cn2: "concrete_2",
                    cn3: "concrete_3",
                    dirt1: "dirt_1",
                    dirt2: "dirt_2",
                    dirt3: "dirt_3",
                    ice1: "ice_front",
                    ice2: "ice_front",
                    ice3: "ice_front",
                    chest: "candy_chest",
                    infection: "candy_infection",
                    dS1: "dirt_s_1",
                    dS2: "dirt_s_2",
                    dS3: "dirt_s_3",
                    jam1: "jam_1",
                    jam2: "jam_2",
                    jam3: "jam_3"
                }, j = 0; j < d; j++)
                for (var k = 0; k < e; k++) {
                    var l = a.levelData[j][k];
                    if ("X" != l[0]) {
                        G.changeTexture(c, "tile_1"), b.draw(c, j * h, k * h, h, h);
                        for (var m = 0; m < l.length; m++) {
                            var n = l[m];
                            if ("S" != n[2])
                                if ("H" != n[2] && "V" != n[2] && "C" != n[2]) "W" == n[2] ? (G.changeTexture(c, i[n[0]]), b.draw(c, j * h, k * h, h, h), G.changeTexture(c, "blocker_chain_wrapped"), c.alpha = .5, b.draw(c, j * h, k * h, h, h), c.alpha = 1) : i[n] && (G.changeTexture(c, i[n]), b.draw(c, j * h, k * h, h, h));
                                else {
                                    var o = "candy_" + n[0] + "_bonus_" + [0, "H", "V", "C"].indexOf(n[2]);
                                    G.changeTexture(c, o), b.draw(c, j * h, k * h, h, h)
                                }
                            else G.changeTexture(c, "candy_spiral"), b.draw(c, j * h, k * h, h, h)
                        }
                    } else G.changeTexture(c, "dark_screen"), c.tint = 0, b.draw(c, j * h, k * h, h, h), c.tint = 16777215
                }
        }, G.EditorWorldSidePanel.prototype.lineEditorInit = function() {
            this.line = this.makeText(0, 1050, "LVL LINE:\nZ-clearLine\nX-add node\nC-remove last node\nV-spread\nB-improt from lvls\nN-spread on nodes", 25), this.lvlLineX = [], this.lvlLineY = [], gfx = game.add.graphics(), gfx.sidePanel = this, gfx.update = function() {
                if (this.x = s.map.x, this.y = s.map.y, this.clear(), this.beginFill(16711680, 1), !(this.sidePanel.lvlLineX.length < 2))
                    for (var a = 0; a < 1e4; a++) this.drawRect(game.math.linearInterpolation(this.sidePanel.lvlLineX, a / 1e4), game.math.linearInterpolation(this.sidePanel.lvlLineY, a / 1e4), 1, 1)
            }, this.keys = game.input.keyboard.addKeys({
                Z: Phaser.Keyboard.Z,
                X: Phaser.Keyboard.X,
                C: Phaser.Keyboard.C,
                V: Phaser.Keyboard.V,
                B: Phaser.Keyboard.B,
                N: Phaser.Keyboard.N
            }), this.keys.Z.onDown.add(function() {
                this.lvlLineX = [], this.lvlLineY = []
            }, this), this.keys.X.onDown.add(function() {
                var a = game.input.activePointer,
                    b = Math.floor((a.worldX - s.map.x) * (1 / G.Loader.currentConfigMulti)),
                    c = Math.floor((a.worldY - s.map.y) * (1 / G.Loader.currentConfigMulti));
                this.lvlLineX.push(b), this.lvlLineY.push(c)
            }, this), this.keys.C.onDown.add(function() {
                this.lvlLineX.pop(), this.lvlLineY.pop()
            }, this), this.keys.V.onDown.add(function() {
                var a = parseInt(prompt("FROM: ")),
                    b = parseInt(prompt("TO: "));
                if (isNaN(a) && isNaN(b)) G.lineUtils.spreadAcrossLine(this.lvlLineX, this.lvlLineY, G.json.levels, "mapX", "mapY");
                else {
                    isNaN(a) && !isNaN(b) && (a = 0), !isNaN(a) && isNaN(b) && (b = G.json.levels.length), a--;
                    var c = G.json.levels.slice(a, b);
                    G.lineUtils.spreadAcrossLine(this.lvlLineX, this.lvlLineY, c, "mapX", "mapY")
                }
                s.map.refreshButtons()
            }, this), this.keys.N.onDown.add(function() {
                console.log("N key");
                var a = parseInt(prompt("FROM: ")),
                    b = parseInt(prompt("TO: "));
                if (isNaN(a) && isNaN(b)) G.lineUtils.spreadAcrossLine(this.lvlLineX, this.lvlLineY, G.json.levels, "mapX", "mapY");
                else {
                    isNaN(a) && !isNaN(b) && (a = 0), !isNaN(a) && isNaN(b) && (b = G.json.levels.length), a--;
                    var c = G.json.levels.slice(a, b);
                    console.log("from to: " + a + "x" + b), G.lineUtils.spreadOnNodes(this.lvlLineX, this.lvlLineY, c, "mapX", "mapY")
                }
                s.map.refreshButtons()
            }, this), this.keys.B.onDown.add(function() {
                this.lvlLineX = [], this.lvlLineY = [], G.json.levels.forEach(function(a) {
                    this.lvlLineX.push(a.mapX), this.lvlLineY.push(a.mapY)
                }, this)
            }, this)
        }, G.BOT = function(a) {
            Phaser.Group.call(this, game), this.board = a, this.active = !1, this.finished = !1, this.spacebar = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR), this.spacebar.onDown.add(function() {
                this.active = !this.active
            }, this), G.sb("onGoalAchieved").add(function() {
                this.finished = !0
            }, this)
        }, G.BOT.prototype = Object.create(Phaser.Group.prototype), G.BOT.prototype.update = function() {
            this.active && !this.finished ? (G.IMMEDIATE = !0, this.active && this.board.isIdle() && this.board.possibleMoves[0] && this.makeMove()) : G.IMMEDIATE = !1
        }, G.BOT.prototype.makeMove = function() {
            var a = game.rnd.pick(this.board.possibleMoves),
                b = this.board.getCandy(a[0], a[1]),
                c = this.board.getCandy(a[2], a[3]);
            this.board.makeMove(b, c)
        }, G.BoosterTutorialText = function() {
            Phaser.Group.call(this, game), this.x = G.l(480), this.y = .8 * game.height, this.alpha = 0, this.bg = G.makeImage(0, 0, "text_shade_bg", .5, this), this.bg.alpha = 0, G.sb("onBoosterUse").add(function(a) {
                G.lvl.tutOpen || ((this.alpha = 1) == a && this.makeNewText("CANDY SWIPER CHANGES THE PLACE OF TWO CANDIES"), 2 == a && this.makeNewText("SWEET APPLE CRUSHES ONE CANDY. TAP ON CANDY YOU WANT TO CRUSH"), 3 != a && 4 != a || this.makeNewText("THE ROLLING PIN CAN CLEAR WHOLE ROW OR COLUMN"))
            }, this), G.sb("onBoosterUsed").add(function() {
                G.lvl.tutOpen || game.add.tween(this).to({
                    alpha: 0
                }, 500, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(this.hide, this)
            }, this)
        }, G.BoosterTutorialText.prototype = Object.create(Phaser.Group.prototype), G.BoosterTutorialText.prototype.makeNewText = function() {
            this.txt = new G.Text(0, 0, {
                font: "ComicSansBold",
                fill: "white",
                fontSize: "45px",
                lineSpacing: -25
            }, .5, 940, 400, !0, "center"), this.txt.alpha = 0, this.add(this.txt), game.add.tween(this.txt).to({
                alpha: 1
            }, 500, Phaser.Easing.Sinusoidal.Out, !0), this.bg.width = this.txt.width + G.l(100), this.bg.height = this.txt.height + G.l(100), game.add.tween(this.bg).to({
                alpha: .7
            }, 500, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.BoosterTutorialText.prototype.changeText = function(a) {
            var b = this.txt;
            game.add.tween(b).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(b.destroy, b), this.makeNewText(a)
        }, G.BoosterTutorialText.prototype.hide = function() {
            if (this.txt) {
                var a = this.txt;
                game.add.tween(this).to({
                    alpha: 0
                }, 500, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                    this.bg.alpha = 0, a.destroy()
                }, this)
            }
        }, G.CollectableAnimLayer = function(a, b) {
            Phaser.Group.call(this, game), this.board = a, this.goalPanel = b.goalPanel, G.IMMEDIATE || G.sb("onCandyToUIAnim").add(function(a, b, c, d, e) {
                if (b) {
                    var f = this.goalPanel.getGoalPanel(a);
                    this.getFreeParticle().init(a, b, f, c, d, e)
                } else d.call(e)
            }, this)
        }, G.CollectableAnimLayer.prototype = Object.create(Phaser.Group.prototype), G.CollectableAnimLayer.prototype.getFreeParticle = function() {
            return this.getFirstDead() || this.add(new G.CollectableAnimPart(this.board, this.goalPanel))
        }, G.CollectableAnimLayer.prototype.initNofly = function(a) {
            this.getFreeParticle().initNofly(a)
        }, G.CollectableAnimPart = function(a, b) {
            Phaser.Image.call(this, game), this.kill(), this.anchor.setTo(.5), this.board = a, this.goalPanel = b
        }, G.CollectableAnimPart.prototype = Object.create(Phaser.Image.prototype), G.CollectableAnimPart.prototype.init = function(a, b, c, d, e, f) {
            this.revive();
            var g = this.board.cellToPxOut([b.cellX, b.cellY]);
            this.x = g[0], this.y = g[1], this.scale.setTo(1), this.alpha = 1, G.changeTexture(this, d || G.json.settings.goals[a].sprite);
            var h = (c = c).img.worldPosition.x + game.world.bounds.x,
                i = c.img.worldPosition.y;
            game.add.tween(this.scale).to({
                x: 1.2,
                y: 1.2
            }, 250, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                game.add.tween(this).to({
                    x: h,
                    y: i,
                    width: c.img.width * c.scale.x,
                    height: c.img.height * c.scale.y
                }, 500, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                    e && e.call(f), game.add.tween(this).to({
                        alpha: 0
                    }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.scale).to({
                        x: 2,
                        y: 2
                    }, 300, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                        this.kill()
                    }, this)
                }, this)
            }, this)
        }, G.CollectableAnimPart.prototype.initNofly = function(a) {
            this.revive(), this.x = game.world.bounds.x + a.img.worldPosition.x, this.y = a.img.worldPosition.y, this.alpha = 1, G.changeTexture(this, G.json.settings.goals[a.goalName].sprite), this.width = a.img.width * a.scale.x, this.height = a.img.height * a.scale.y, game.add.tween(this).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.scale).to({
                x: 1.5,
                y: 1.5
            }, 300, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.kill()
            }, this)
        }, G.FadeLayer = function() {
            Phaser.Image.call(this, game, 0, 0), game.camera.flash(16777215, 600, !0), G.sb("onStateChange").add(this.setupChange, this), this.game.add.existing(this)
        }, G.FadeLayer.prototype = Object.create(Phaser.Image.prototype), G.FadeLayer.constructor = G.FadeLayer, G.FadeLayer.prototype.setupChange = function(a, b, c, d, e) {
            G.sfx.transition.play(), G.sfx.music.resume(), 0 < game.camera.onFadeComplete.getNumListeners() || (game.camera.onFadeComplete.addOnce(function() {
                game.state.start(a, !0, !1, b, c, d, e)
            }), game.camera.fade(16777215, 300, !0))
        }, G.FxParticle = function(a, b) {
            Phaser.Image.call(this, game), this.board = a, this.fxGroup = b, this.anchor.setTo(.5), this.kill(), this.id = Math.random(), this.animationData = {
                currentIndex: 0,
                currentTimer: 0,
                timer: 3,
                loop: 0,
                maxFrame: 0,
                gfxName: ""
            }
        }, G.FxParticle.prototype = Object.create(Phaser.Image.prototype), G.FxParticle.prototype.getOther = function() {
            return this.parent.getFreeParticle()
        }, G.FxParticle.prototype.update = function() {
            this.alive && this.updateFunc()
        }, G.FxParticle.prototype.updateAnimation = function() {
            if (this.animationData.currentTimer += G.deltaTime, this.animationData.currentTimer >= this.animationData.timer) {
                if (this.animationData.currentIndex++, this.animationData.currentTimer -= this.animationData.timer, this.animationData.currentIndex > this.animationData.maxFrame) {
                    if (0 == this.animationData.loop) return this.kill();
                    this.animationData.loop--, this.animationData.currentIndex = 0
                }
                G.changeTexture(this, this.animationData.gfxName + this.animationData.currentIndex)
            }
        }, G.FxParticle.prototype.initAnimation = function(a, b, c, d, e) {
            this.animationData.currentIndex = e || 0, this.animationData.currentTimer = 0, this.animationData.timer = c, this.animationData.gfxName = a, this.animationData.maxFrame = b, this.animationData.loop = d || 0, G.changeTexture(this, a + this.animationData.currentIndex), this.updateFunc = this.updateAnimation
        }, G.FxParticle.prototype.emptyFunc = function() {}, G.FxParticle.prototype.init = function(a, b) {
            this.x = a, this.y = b, this.blendMode = 0, this.alpha = 1, this.angle = 0, this.scale.setTo(1), this.updateFunc = this.emptyFunc, this.anchor.setTo(.5), this.revive()
        }, G.FxParticle.prototype.explosion = function(a, b) {
            this.init(a, b), this.initAnimation("cookie_match_", 10, 2, 0, 1), this.scale.setTo(.6)
        }, G.FxParticle.prototype.spiral = function(a, b) {
            this.init(a, b), this.initAnimation("candy_spiral_explode_", 13, 2)
        }, G.FxParticle.prototype.dummyFadeOut = function(a, b, c) {
            this.init(a, b), G.changeTexture(this, c), game.add.tween(this).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(this.kill, this)
        }, G.FxParticle.prototype.dummyFadeOutScaleIn = function(a, b, c) {
            this.init(a, b), G.changeTexture(this, c), game.add.tween(this.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(this.kill, this)
        }, G.FxParticle.prototype.dummyComboGrowAndFade = function(a, b, c) {
            this.fxGroup.aboveThirdFloorLayer.add(this), this.init(a, b), G.changeTexture(this, c[0]), this.angle = c[1], this.alpha = .8;
            var d = game.add.tween(this.scale).to({
                x: 2.5,
                y: 2.5
            }, 200, Phaser.Easing.Sinusoidal.In, !0);
            game.add.tween(this).to({
                alpha: 0
            }, 100, Phaser.Easing.Sinusoidal.In, !0, 100).onComplete.add(function() {
                d.stop(), this.fxGroup.add(this), this.kill()
            }, this)
        }, G.FxParticle.prototype.electricCircle = function(a, b) {
            this.init(a, b), this.blendMode = 1, G.loadTexture(this, "circle"), game.add.tween(this).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.Out, !0, 300).onComplete.add(this.kill, this), this.updateFunc = this.electricCircleUpdate, this.other = this.getOther(), this.other.blendMode = 1, G.loadTexture(this.other, "circle"), this.other.updateFunc = this.other.electricCircleUpdate, game.add.tween(this.other).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.Out, !0, 300).onComplete.add(this.other.kill, this.other)
        }, G.FxParticle.prototype.electricCircleUpdate = function() {
            this.scale.setTo(1 + .5 * Math.random())
        }, G.FxParticle.prototype.smallCircle = function(a, b) {
            this.init(a, b), this.blendMode = 1, G.loadTexture(this, "circle"), this.scale.setTo(0), this.alpha = .5, game.add.tween(this.scale).to({
                x: .5,
                y: .5
            }, 150, Phaser.Easing.Cubic.Out, !0), game.add.tween(this).to({
                alpha: 0
            }, 150, Phaser.Easing.Cubic.Out, !0, 200).onComplete.add(this.kill, this)
        }, G.FxParticle.prototype.lightCircle = function(a, b) {
            this.init(a, b), this.blendMode = 1, G.loadTexture(this, "circle"), this.scale.setTo(0), game.add.tween(this.scale).to({
                x: 1.5,
                y: 1.5
            }, 500, Phaser.Easing.Cubic.Out, !0), game.add.tween(this).to({
                alpha: 0
            }, 300, Phaser.Easing.Cubic.Out, !0, 200).onComplete.add(this.kill, this)
        }, G.FxParticle.prototype.lightCircleFast = function(a, b) {
            this.init(a, b), this.blendMode = 1, G.loadTexture(this, "circle"), this.scale.setTo(0), game.add.tween(this.scale).to({
                x: 1.5,
                y: 1.5
            }, 300, Phaser.Easing.Cubic.Out, !0), game.add.tween(this).to({
                alpha: 0
            }, 200, Phaser.Easing.Cubic.Out, !0, 100).onComplete.add(this.kill, this)
        }, G.FxParticle.prototype.changeCircle = function(a, b) {
            this.init(a, b), this.blendMode = 1, G.loadTexture(this, "circle"), this.scale.setTo(.6), game.add.tween(this.scale).to({
                x: 1.5,
                y: 1.5
            }, 600, Phaser.Easing.Cubic.Out, !0), game.add.tween(this).to({
                alpha: 0
            }, 600, Phaser.Easing.Cubic.Out, !0).onComplete.add(this.kill, this)
        }, G.FxParticle.prototype.initStroke = function(a, b, c, d) {
            this.init(a, b);
            var e = parseInt(c.candyType),
                f = "line_effect_" + game.rnd.between(1, 6);
            1 <= e && e <= 6 && (f = "line_effect_" + e), G.changeTexture(this, f), this.angle = d || 0, game.add.tween(this.scale).to({
                y: 15
            }, 500, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this).to({
                alpha: 0
            }, 100, Phaser.Easing.Cubic.In, !0, 400).onComplete.add(function() {
                this.kill()
            }, this)
        }, G.FxParticle.prototype.strokeH = function(a, b, c, d) {
            this.initStroke(a, b, d, 90)
        }, G.FxParticle.prototype.strokeV = function(a, b, c, d) {
            this.initStroke(a, b, d, 0)
        }, G.FxParticle.prototype.strokeDR = function(a, b, c, d) {
            this.initStroke(a, b, d, -45)
        }, G.FxParticle.prototype.strokeDF = function(a, b, c, d) {
            this.initStroke(a, b, d, 45)
        }, G.FxParticle.prototype.lightning = function(a, b, c) {
            this.init(a, b), G.changeTexture(this, "lightning"), this.anchor.setTo(.5, 0);
            var d = this.board.cellXToPxIn(c[0]),
                e = this.board.cellYToPxIn(c[1]);
            this.height = game.math.distance(a, b, d, e), this.rotation = game.math.angleBetween(a, b, d, e), this.angle -= 90, this.timer = 0, this.updateFunc = this.lightningUpdate, game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Cubic.In, !0).onComplete.add(function() {
                this.kill()
            }, this)
        }, G.FxParticle.prototype.lightningUpdate = function() {
            this.timer += 1 * G.deltaTime, 2 < this.timer && (this.scale.x *= -1, this.timer = 0)
        }, G.FxParticle.prototype.chocolatePart = function(a, b) {
            this.init(a, b), this.x += G.l(40 * Math.random() - 20), this.y += G.l(40 * Math.random() - 20), G.changeTexture(this, "chocolatePiece"), this.scale.setTo(.8), this.angle = 360 * Math.random(), this.velX = Math.random() * G.lnf(-12) + G.lnf(6), this.velY = Math.random() * G.lnf(-6) - G.lnf(4), this.gravity = G.lnf(.6), this.updateFunc = this.fallingPartUpdate
        }, G.FxParticle.prototype.chocolatePartW = function(a, b) {
            this.init(a, b), this.x += G.l(40 * Math.random() - 20), this.y += G.l(40 * Math.random() - 20), G.changeTexture(this, "chocolatePieceW"), this.scale.setTo(.8), this.angle = 360 * Math.random(), this.velX = Math.random() * G.lnf(-12) + G.lnf(6), this.velY = Math.random() * G.lnf(-6) - G.lnf(4), this.gravity = G.lnf(.6), this.updateFunc = this.fallingPartUpdate
        }, G.FxParticle.prototype.burstConcrete = function(a, b, c, d, e) {
            this.init(a + G.l(c), b + G.l(d)), G.changeTexture(this, e), this.burstConcreteVelX = Math.sign(c) * G.lnf(2 + 3 * Math.random()), this.burstConcreteVelY = G.lnf(-3 * Math.random() - 3), this.burstConcreteGrav = G.lnf(.6), this.updateFunc = this.burstConcreteUpdate
        }, G.FxParticle.prototype.burstConcreteUpdate = function() {
            this.x += this.burstConcreteVelX, this.y += this.burstConcreteVelY, this.angle += 2 * this.burstConcreteVelX, this.burstConcreteVelX *= .98, this.burstConcreteVelY += this.burstConcreteGrav, this.alpha -= .03, this.scale.setTo(this.scale.x + .01), this.alpha <= 0 && this.kill()
        }, G.FxParticle.prototype.burstLookup = {
            1: 17,
            2: 15,
            3: 16,
            4: 16,
            5: 16,
            6: 17
        }, G.FxParticle.prototype.burstCandy = function(a, b) {
            this.init(a, b), this.scale.setTo(.9), this.alpha = 1, this.initAnimation("cookie_match_", 10, 2, 0, 1)
        }, G.FxParticle.prototype.burstIce = function(a, b) {
            this.init(a, b), this.alpha = 1, this.scale.setTo(1), this.initAnimation("ice_part_", 13, 2, 0, 1)
        }, G.FxParticle.prototype.burstConcreteAnim = function(a, b) {
            this.init(a, b), this.alpha = 1, this.scale.setTo(1), this.initAnimation("concrete_part_", 17, 2, 0, 0)
        }, G.FxParticle.prototype.burstDirtAnim = function(a, b) {
            this.init(a, b), this.alpha = 1, this.scale.setTo(1), this.initAnimation("dirt_part_", 16, 2, 0, 0)
        }, G.FxParticle.prototype.burstInfectionAnim = function(a, b) {
            this.init(a, b), this.alpha = 1, this.scale.setTo(1), this.initAnimation("infection_part_", 18, 2, 0, 0)
        }, G.FxParticle.prototype.burstChainAnim = function(a, b) {
            this.init(a, b), this.alpha = 1, this.scale.setTo(1), this.initAnimation("unwrap_part_", 14, 2, 0, 0)
        }, G.FxParticle.prototype.glowLookup = {
            1: 8,
            2: 12,
            3: 5,
            4: 6,
            5: 11,
            6: 8
        }, G.FxParticle.prototype.whiteStarPart = function(a, b) {
            this.init(a, b), G.changeTexture(this, "starPart"), this.blendMode = 1, this.angle = 360 * Math.random(), this.velX = Math.random(20) * G.lnf(-20) + G.lnf(10), this.velY = Math.random() * G.lnf(-9) - G.lnf(3), this.gravity = G.lnf(.5), this.updateFunc = this.fallingPartUpdate
        }, G.FxParticle.prototype.fallingPartUpdate = function() {
            this.x += this.velX * G.deltaTime, this.y += this.velY * G.deltaTime, this.angle += .1 * this.velX, this.velX *= .99, this.velY += this.gravity * G.deltaTime, this.alpha -= .02, this.alpha <= 0 && this.kill()
        }, G.FxParticle.prototype.whiteStarPartFast = function(a, b) {
            this.init(a, b), G.changeTexture(this, "starPart"), this.blendMode = 1, this.angle = 360 * Math.random(), this.velX = Math.random(20) * G.lnf(-20) + G.lnf(10), this.velY = Math.random() * G.lnf(-9) - G.lnf(3), this.gravity = G.lnf(.25), this.updateFunc = this.fallingPartUpdate
        }, G.addTextStyles = function() {
            G.Text.addStyle("font-white", {
                font: "ComicSansBold",
                fill: "white",
                fontSize: 40,
                stroke: "#85511f",
                strokeThickness: 5
            }), G.Text.addStyle("font-white-stroke", {
                font: "ComicSansBold",
                fill: "white",
                fontSize: 40,
                stroke: "#85511f",
                strokeThickness: 5
            }), G.Text.addStyle("font-green", {
                font: "ComicSansBold",
                fill: "#f7ffdb",
                fontSize: 40,
                stroke: "#005700",
                strokeThickness: 5
            }), G.Text.addStyle("font-beige", {
                font: "ComicSansBold",
                fill: "#ece9e5",
                fontSize: 40,
                stroke: "#85511f",
                strokeThickness: 5
            }), G.Text.addStyle("font-beige-standard", {
                font: "ComicSansBold",
                fill: "#fdfbe4",
                fontSize: 40,
                stroke: "#73461c",
                strokeThickness: 7
            }), G.Text.addStyle("font-beige-header", {
                font: "ComicSansBold",
                fill: "#ece9e5",
                fontSize: 40,
                stroke: "#85511f",
                strokeThickness: 5
            }), G.Text.addStyle("font-brown", {
                font: "ComicSansBold",
                fill: "#ece9e5",
                fontSize: 40,
                stroke: "#A0692E",
                strokeThickness: 7
            }), G.Text.addStyle("font-red", {
                font: "ComicSansBold",
                fill: "#ffe9d0",
                fontSize: 40,
                stroke: "#961400",
                strokeThickness: 7
            }), G.Text.addStyle("font-blue-out", {
                font: "ComicSansBold",
                fill: "#ffffe8",
                fontSize: 40,
                stroke: "#004455",
                strokeThickness: 10
            }), G.Text.addStyle("font-blue-out-small", {
                font: "ComicSansBold",
                fill: "#ffffe8",
                fontSize: 40,
                stroke: "#004455",
                strokeThickness: 5
            }), G.Text.addStyle("font-gray", {
                font: "ComicSansBold",
                fill: "white",
                fontSize: 40,
                stroke: "#393939",
                strokeThickness: 5
            }), G.Text.addStyle("font-white", {
                font: "Lobster",
                fill: "white",
                fontSize: "30px",
                shadow: [2, 3, "rgba(0,0,0,0.3)", 0]
            }), G.Text.addStyle("font-blue", {
                font: "Lobster",
                fill: "#008aca",
                fontSize: "30px"
            }), G.Text.addStyle("font-darkBlue", {
                font: "Lobster",
                fill: "#006A8F",
                fontSize: "30px"
            }), G.Text.addStyle("font-num-blue", {
                font: "Lobster",
                fill: "white",
                fontSize: "30px",
                stroke: "#3d95ea",
                strokeThickness: 3
            }), G.Text.addStyle("font-num-orange", {
                font: "Lobster",
                fill: "white",
                fontSize: "30px",
                stroke: "#ff7200",
                strokeThickness: 3
            }), G.Text.addStyle("font-score-0", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#eea1c2"
            }), G.Text.addStyle("font-score-1", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#c52216"
            }), G.Text.addStyle("font-score-2", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#1eb3e5"
            }), G.Text.addStyle("font-score-3", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#eac867"
            }), G.Text.addStyle("font-score-4", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#e34bbc"
            }), G.Text.addStyle("font-score-5", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#7adc2c"
            }), G.Text.addStyle("font-score-6", {
                font: "RubikBold",
                fontSize: "50px",
                stroke: "white",
                strokeThickness: 8,
                fill: "#e79909"
            }), G.Text.addStyle("rubikWB", {
                font: "RubikBold",
                fontSize: "40px",
                stroke: "#49abe8",
                strokeThickness: 6,
                fill: "white"
            }), G.Text.addStyle("rubikPW", {
                font: "RubikBold",
                fontSize: "40px",
                stroke: "white",
                strokeThickness: 6,
                fill: "#EC048D"
            })
        }, void 0 === G && (G = {}), G.Button = function(a, b, c, d, e) {
            Phaser.Button.call(this, game, G.l(a), G.l(b), null), this.state = game.state.getCurrentState(), G.changeTexture(this, c), this.anchor.setTo(.5), this.sfx = G.sfx.pop, this.active = !0, this.onClick = new Phaser.Signal, d && this.onClick.add(d, e || this), this.onInputDown.add(this.click, this), this.terms = [], this.IMMEDIATE = !1, this.pulsing = !1, this.tweenScale = !1
        }, G.Button.prototype = Object.create(Phaser.Button.prototype), G.Button.constructor = G.Button, G.Button.prototype.pulse = function(a) {
            this.pulsing = !0, this.pulsingTween = game.add.tween(this.scale).to({
                x: a || 1.1,
                y: a || 1.1
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.Button.prototype.stopPulse = function(a) {
            this.pulsingTween && this.pulsingTween.stop(), this.scale.setTo(a || 1), this.pulsing = !1
        }, G.Button.prototype.click = function() {
            if (this.active) {
                for (var a = 0; a < this.terms.length; a++)
                    if (!this.terms[a][0].call(this.terms[a][1])) return;
                this.active = !1, this.onClick.dispatch(), this.sfx.play();
                var b = this.scale.x,
                    c = this.scale.y;
                this.IMMEDIATE ? this.active = !0 : this.pulsing ? game.time.events.add(400, function() {
                    this.active = !0
                }, this) : game.add.tween(this.scale).to({
                    x: this.tweenScale ? this.tweenScale.x : b + .2 * Math.sign(b),
                    y: this.tweenScale ? this.tweenScale.y : c + .2 * Math.sign(c)
                }, 200, Phaser.Easing.Quadratic.Out, !0).onComplete.add(function() {
                    game.add.tween(this.scale).to({
                        x: b,
                        y: c
                    }, 200, Phaser.Easing.Quadratic.Out, !0).onComplete.add(function() {
                        this.active = !0
                    }, this)
                }, this)
            }
        }, G.Button.prototype.addTerm = function(a, b) {
            this.terms.push([a, b])
        }, G.Button.prototype.addImageLabel = function(a) {
            this.label = game.make.image(0, 0, "ssheet", a), this.label.anchor.setTo(.5), this.addChild(this.label)
        }, G.Button.prototype.addTextLabel = function(a, b, c, d, e, f) {
            var g = 1 / G.Loader.currentConfigMulti;
            d = void 0 === d ? 0 : d, e = void 0 === e ? -6 : e, f = void 0 === f ? this.width * g * .7 : f, this.label = new G.Text(d, e, b, {
                style: a,
                fontSize: c || Math.floor(this.height * g * .7)
            }, .5, f), this.label.scale.setTo(Math.min(this.label.scale.x, this.label.scale.y)), this.label.hitArea = new Phaser.Rectangle(0, 0, 0, 0), this.addChild(this.label)
        }, G.Button.prototype.addTextLabelMultiline = function(a, b) {
            this.label = new G.Text(0, 0, b, {
                style: a,
                fontSize: Math.floor(.5 * this.height)
            }, .5, .7 * this.width, .7 * this.height, !0, "center"), this.addChild(this.label)
        }, G.ChestLayer = function() {
            Phaser.Group.call(this, game), this.deadElems = [], this.state = game.state.getCurrentState(), this.board = this.state.board, this.deadArray = [], G.sb("onChestOpen").add(function(a) {
                var b = this.board.cellToPxOut([a.cellX, a.cellY]);
                this.getFreeParticle().init(b[0], b[1]), this.sort("orgY", Phaser.Group.SORT_ASCENDING)
            }, this)
        }, G.ChestLayer.prototype = Object.create(Phaser.Group.prototype), G.ChestLayer.prototype.onElemKilled = function(a) {
            this === a.parent && (this.deadArray.push(a), this.removeChild(a))
        }, G.ChestLayer.prototype.getFreeParticle = function() {
            return 0 < this.deadArray.length ? part = this.deadArray.pop() : (part = new G.Chest(this.board, this), part.events.onKilled.add(this.onElemKilled, this)), this.add(part), part
        }, G.Chest = function() {
            Phaser.Image.call(this, game, 0, 0), G.changeTexture(this, "chest_bottom"), this.anchor.setTo(.5), this.state = game.state.getCurrentState(), this.cover = G.makeImage(-33, 0, null, [0, 1], this), this.light = G.makeImage(0, -20, "popup_lighht", .5, this), this.light.scale.setTo(.5), this.light.cacheAsBitmap = !0, this.light.blendMode = 1, this.addChild(this.light), this.gift = G.makeImage(0, -10, null, .5, this), this.animTimer = 0, this.animEvery = 3, this.animIndex = 0, this.coverCoords = [
                [G.l(-33), 0],
                [G.l(-33), G.l(-8)],
                [G.l(-33), G.l(-8)],
                [G.l(-35), G.l(-8)]
            ], this.kill()
        }, G.Chest.prototype = Object.create(Phaser.Image.prototype), G.Chest.prototype.init = function(a, b) {
            G.stopTweens(this), G.changeTexture(this.cover, "chest_top_00"), this.cover.y = 0, this.orgX = a, this.orgY = b, this.alpha = 1, this.scale.setTo(1), this.animTimer = 0, this.animIndex = 0, this.x = a, this.y = b + G.l(5), this.light.alpha = 0, game.add.tween(this).to({
                y: b - G.l(30)
            }, 1500, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.scale).to({
                x: 1.2,
                y: 1.2
            }, 400, Phaser.Easing.Sinusoidal.Out, !0), G.stopTweens(this.gift), this.giftData = G.gift.getGift("ingamechests"), G.changeTexture(this.gift, G.gift.getIcon(this.giftData)), "coin" == this.giftData[0] && (1 == this.giftData[1] ? G.changeTexture(this.gift, "coin_package_icon_0") : 2 == this.giftData[1] ? G.changeTexture(this.gift, "coin_package_icon_1") : 3 == this.giftData[1] ? G.changeTexture(this.gift, "coin_package_icon_2") : G.changeTexture(this.gift, "coin_package_icon_4")), this.gift.scale.setTo(0), this.gift.angle = -10, this.gift.y = G.l(-10), this.update = this.updatePreOpen, this.revive(), G.sfx.chest_open_louder.play()
        }, G.Chest.prototype.updatePreOpen = function() {
            this.alive && (this.animIndex < 3 && this.animTimer++ % this.animEvery == 0 && (this.animIndex++, this.cover.x = this.coverCoords[this.animIndex][0], this.cover.y = this.coverCoords[this.animIndex][1], G.changeTexture(this.cover, "chest_top_0" + this.animIndex), 3 == this.animIndex) && (game.add.tween(this.gift.scale).to({
                x: 1,
                y: 1
            }, 600, Phaser.Easing.Bounce.Out, !0), game.add.tween(this.gift).to({
                y: G.l(-40)
            }, 400, Phaser.Easing.Sinusoidal.InOut).to({
                y: G.l(-30)
            }, 1100, Phaser.Easing.Sinusoidal.Out).start(), game.add.tween(this.gift).to({
                angle: 10
            }, 1500, Phaser.Easing.Sinusoidal.InOut, !0), game.time.events.add(1e3, function() {
                G.gift.applyGift(this.giftData, !0), game.add.tween(this).to({
                    alpha: 0
                }, 500, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(function() {
                    this.kill()
                }, this)
            }, this)), this.light.angle++, this.light.alpha = game.math.clamp(this.light.alpha + .03, 0, .5))
        }, G.DotBg = function() {
            this.texture = game.add.renderTexture(game.width, game.height), this.marker = G.makeImage(0, 0, "background_star_tile", 0, null), this.marker.alpha = .4, this.img = game.add.image(0, 0, this.texture), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize()
        }, G.DotBg.prototype = Object.create(Phaser.Image.prototype), G.DotBg.prototype.onScreenResize = function() {
            this.texture.resize(game.width, game.height), this.texture.clear(), this.img.x = game.world.bounds.x;
            for (var a = 0; a < game.width; a += this.marker.width)
                for (var b = 0; b < game.height; b += this.marker.height) this.texture.renderXY(this.marker, a, b)
        }, G.FxMapLayer = function() {
            G.PoolGroup.call(this, G.FxMapPart), this.fixedToCamera = !0, G.sb("fxMap").add(this.init, this)
        }, G.FxMapLayer.prototype = Object.create(G.PoolGroup.prototype), G.FxMapPart = function() {
            G.Image.call(this), this.state = game.state.getCurrentState()
        }, G.FxMapPart.prototype = Object.create(G.Image.prototype), G.FxMapPart.prototype.emptyUpdate = function() {}, G.FxMapPart.prototype.reset = function(a) {
            this.x = a.position ? a.position.x : a.x, this.y = a.position ? a.position.y : a.y, this.anchor.setTo(.5), this.scale.setTo(1), this.alpha = 1, this.angle = 0, this.blendMode = 0, this.changeTexture(null), this.visible = !0, this.update = this.emptyUpdate, this.revive()
        }, G.FxMapPart.prototype.init = function(a, b) {
            this.reset(b), this[a] ? this[a].apply(this, arguments) : console.warn("There is no " + a + " in G.FxPart")
        }, G.FxMapPart.prototype.star = function(a, b) {
            this.changeTexture("starPart"), this.blendMode = 1, this.alpha = b.alpha || 1, this.grav = void 0 === b.grav ? 0 : b.grav, this.timer = b.timer || game.rnd.between(20, 40), this.blendMode = 0, this.scale.setTo(b.scale || .7), this.velX = b.velX || game.rnd.realInRange(-10, 10), this.velY = b.velY || game.rnd.realInRange(-20, -8), this.velAngle = game.rnd.realInRange(-5, 5), this.angle = game.rnd.realInRange(0, 360), this.update = this.starUpdate
        }, G.FxMapPart.prototype.starUpdate = function() {
            this.x += this.velX, this.y += this.velY, this.velX *= .95, this.velY *= .95, this.angle += this.velAngle, this.timer-- < 0 && (this.alpha -= .05, this.alpha <= 0 && this.kill())
        }, G.gameTracking = {
            sink: function(a, b, c, d) {
                console.log("sink", a, b, c, d);
                try {
                    sdkHandler.trigger("gameTracking", {
                        event: "Sink",
                        dimension1: a ? a.toString() : void 0,
                        dimension2: b ? b.toString() : void 0,
                        dimension3: c ? c.toString() : void 0,
                        value: d || 1
                    })
                } catch (a) {
                    console.log(a)
                }
            },
            source: function(a, b, c, d) {
                console.log("source", a, b, c, d);
                try {
                    sdkHandler.trigger("gameTracking", {
                        event: "Source",
                        dimension1: a ? a.toString() : void 0,
                        dimension2: b ? b.toString() : void 0,
                        dimension3: c ? c.toString() : void 0,
                        value: d || 1
                    })
                } catch (a) {
                    console.log(a)
                }
            },
            start: function(a, b, c, d) {
                try {
                    sdkHandler.trigger("gameTracking", {
                        event: "Start",
                        dimension1: a ? a.toString() : void 0,
                        dimension2: b ? b.toString() : void 0,
                        dimension3: c ? c.toString() : void 0,
                        value: d
                    })
                } catch (a) {
                    console.log(a)
                }
            },
            fail: function(a, b, c, d) {
                try {
                    sdkHandler.trigger("gameTracking", {
                        event: "Fail",
                        dimension1: a ? a.toString() : void 0,
                        dimension2: b ? b.toString() : void 0,
                        dimension3: c ? c.toString() : void 0,
                        value: d
                    })
                } catch (a) {
                    console.log(a)
                }
            },
            complete: function(a, b, c, d) {
                try {
                    sdkHandler.trigger("gameTracking", {
                        event: "Complete",
                        dimension1: a ? a.toString() : void 0,
                        dimension2: b ? b.toString() : void 0,
                        dimension3: c ? c.toString() : void 0,
                        value: d
                    })
                } catch (a) {
                    console.log(a)
                }
            },
            design: function(a, b) {
                try {
                    sdkHandler.trigger("gameTracking", {
                        event: "Design",
                        dimension1: a ? a.toString() : void 0,
                        value: b
                    })
                } catch (a) {
                    console.log(a)
                }
            },
            init: function() {
                this.onInitFinished = new Phaser.Signal, sdkHandler.trigger("restore", {
                    key: "ftueEventsData",
                    callback: function(a, b) {
                        a ? console.log(a) : (this.ftueData = null === b ? {} : JSON.parse(b), this.initialized = !0, this.onInitFinished.dispatch())
                    }
                }, this)
            },
            FTUEDesign: function(a, b) {
                this.initialized, this._FTUEDesign(a, b)
            },
            _FTUEDesign: function(a, b) {
                this.ftueData[a] || (console.log("FTUE EVENT: ", a, b), this.ftueData[a] = !0, this.design(a, b), sdkHandler.trigger("save", {
                    key: "ftueEventsData",
                    value: JSON.stringify(this.ftueData),
                    callback: function() {}
                }))
            },
            checkFTUE: function(a) {
                return this.ftueData[a]
            }
        }, G.ga = {
            event: function() {}
        }, G.gift = {}, G.gift.getGift = function(a) {
            a = a || "normals";
            var b = G.json.settings.gifts[a],
                c = b.boosterMaxNr || G.json.settings.gifts.boosterMaxNr,
                d = b.boosterChance || G.json.settings.gifts.boosterChance,
                e = [];
            b.list.forEach(function(a) {
                "coin" == a[0] ? e.push(a) : -1 !== a[0].indexOf("booster") ? G.saveState.isBoosterUnlocked(parseInt(a[0][8])) && G.saveState.getBoosterAmount(parseInt(a[0][8])) < c && e.push(a) : "ginger" === a[0] && G.GINGEREVENT && e.push(a)
            }), Phaser.ArrayUtils.shuffle(e);
            for (var f = Math.random() < d, g = 0; g < e.length; g++) {
                var h = e[g];
                if (-1 === h[0].indexOf("booster")) return h.slice();
                if (f) return h.slice()
            }
            return ["coin", 50]
        }, G.gift.getLabelString = function(a, b) {
            var c = "coin" === a[0] ? "" : "x";
            return b = b ? "*" + b + "*" : "", a[1] + c + "@" + b + G.json.settings.gifts.icons[a[0]] + "@"
        }, G.gift.applyGift = function(a, b) {
            "coin" == a[0] ? G.saveState.changeCoins(a[1], b) : "life" == a[0] ? G.saveState.addLife(a[1], b) : "ginger" == a[0] ? G.saveState.addGinger(a[1]) : G.saveState.changeBoosterAmount(parseInt(a[0][8]), a[1], b)
        }, G.gift.getIcon = function(a) {
            return G.json.settings.gifts.icons[a[0]]
        }, G.gift.processRandomBoosters = function(a) {
            if ("coin" === a[0] && "R" !== a[0][8]) return a;
            var b = [1, 2, 3, 4, 5, 6, 7, 8].filter(function(a) {
                return G.saveState.isBoosterUnlocked(a)
            });
            return 0 < b.length ? a[0] = "booster#" + game.rnd.pick(b) : (a[0] = "coin", a[1] = a[1] * G.json.settings.gifts.fallbackCoins), a
        }, G.gift.getLabelPackString = function(a) {
            var b = "";
            return a.forEach(function(a, c, d) {
                b += G.gift.getLabelString(a, 1), c !== d.length - 1 && (b += " ")
            }), b
        }, G.GiftBox = function(a, b, c, d) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.giftData = d || G.gift.getGift("normals"), this.giftData = G.gift.processRandomBoosters(this.giftData), this.x = a, this.y = b, this.light = G.makeImage(0, 0, "popup_lighht", .5, this), this.light.update = function() {
                this.angle++
            }, this.light.alpha = 0, this.light.blendMode = 1, this.inside = new G.LabelGroupT(G.gift.getLabelString(this.giftData), 0, 0, {
                font: "ComicSansBold",
                fontSize: "120px",
                fill: "#FDFBE4",
                stroke: "#A0692E",
                strokeThickness: 7
            }, .5, 180), this.add(this.inside), this.inside.alpha = 0, this.gift = G.makeImage(0, 0, "gift", .5, this), c && (this.gift.inputEnabled = !0, this.gift.events.onInputDown.add(function() {
                this.gift.inputEnabled = !1, this.unpack()
            }, this), this.hand = G.makeImage(30, 40, "tut_hand", 0, this), this.hand.scale.setTo(.6), game.add.tween(this.hand).to({
                x: G.l(50),
                y: G.l(60)
            }, 600, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0))
        }, G.GiftBox.prototype = Object.create(Phaser.Group.prototype), G.GiftBox.prototype.unpack = function() {
            "coin" == this.giftData[0] && "World" == game.state.current && this.state.uiTargetParticles ? (this.state.uiTargetParticles.createCoinBatch(game.world.bounds.x + this.worldPosition.x, this.worldPosition.y, this.state.panel.coinsTxt, this.giftData[1]), this.state.uiTargetParticles.createDividedBatch(this.worldPosition.y, "coin_1", this.state.panel.coinsTxt, this.giftData[1], 5)) : G.gift.applyGift(this.giftData), G.sfx.xylophone_positive_12.play(), game.add.tween(this.gift).to({
                alpha: 0,
                width: 1.2 * this.gift.width,
                height: 1.2 * this.gift.height
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this.light).to({
                alpha: .5
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this.inside).to({
                alpha: 1
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0), this.hand && game.add.tween(this.hand).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.InOut, !0)
        }, G.GlobalGoalButton = function(a, b) {
            Phaser.Group.call(this, game), this.position.setTo(0, 130), this.unlocked = G.saveState.getLastPassedLevelNr() >= G.json.settings.featuresUnlock.globalGoals, this.tutorial = this.unlocked && !G.saveState.data.sawGlobalGoalsTut, this.x = G.l(a), this.y = G.l(b), this.state = game.state.getCurrentState(), this.glow = G.makeImage(0, 0, "popup_lighht", .5, this), this.glow.blendMode = 1, this.glow.scale.setTo(.5), this.glow.alpha = 0, this.importantStuff = G.globalGoalMgr.isAnyToUserAttention(), this.goalBtn = new G.Button(0, 0, this.unlocked ? "Mission_Button_yellow" : "Mission_Button_locked_yellow", function() {
                new G.Window("globalGoals")
            }), this.goalBtn.addTerm(function() {
                return this.unlocked
            }, this), this.add(this.goalBtn), this.unlocked ? this.initUnlocked() : this.initLocked(), this.tutorial && this.addTutHand(), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.GlobalGoalButton.prototype = Object.create(Phaser.Group.prototype), G.GlobalGoalButton.prototype.onResize = function() {
            var a = game.world.bounds.x + Math.floor(.5 * game.width);
            this.x = game.width < 1070 ? a - 265 : a - 265 - 235
        }, G.GlobalGoalButton.prototype.initUnlocked = function() {
            this.amount = G.makeImage(20, 15, "booster_ammount", .5, this), this.amount.scale.setTo(.75), this.amountTxt = this.amount.addChild(new G.Text(0, 2, this.importantStuff.toString(), {
                style: "font-beige-standard",
                fontSize: "30px"
            }, .5)), this.reasons = [], G.globalGoalMgr.isAnyToUserAttention() && (this.reasons = G.globalGoalMgr.getAttentionReason()), G.sb("onGlobalGoalOutOfTime").add(function(a) {
                this.reasons.push(a.status)
            }, this), this.duringMessage = !1, this.txtLookUp = {
                inactive: "New mission available",
                achieved: "Mission completed",
                failed: "Mission failed"
            }, this.initDelay = 30
        }, G.GlobalGoalButton.prototype.initLocked = function() {
            this.unlockTxt = new G.Text(95, 0, G.txt("Unlock at Level X").replace("X", G.json.settings.featuresUnlock.globalGoals + 1), {
                fill: "#fdfbe4",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#73461c",
                strokeThickness: 5
            }, .5, 150, 150, !0, "center"), this.unlockTxt.lineSpacing = -15, this.unlockTxt.setShadow(0, 0, "black", 3), this.add(this.unlockTxt), game.add.tween(this.unlockTxt.scale).to({
                x: .9,
                y: .9
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.GlobalGoalButton.prototype.update = function() {
            if (this.unlocked) {
                var a = this.importantStuff;
                this.importantStuff = G.globalGoalMgr.isAnyToUserAttention(), a !== this.importantStuff && this.amountTxt.setText(this.importantStuff.toString()), this.amount.alpha = 0 == this.importantStuff ? 0 : 1, this.glow.angle++, this.glow.alpha = 0 < this.importantStuff ? Math.min(this.glow.alpha + .05, .4) : Math.max(this.glow.alpha - .05, 0), this.updateMsg()
            }
        }, G.GlobalGoalButton.prototype.updateMsg = function() {
            if (!(0 < this.state.windowLayer.children.length) && this.initDelay-- < 0 && this.reasons[0] && !this.duringMessage) {
                var a = this.txtLookUp[this.reasons[0]];
                this.reasons.splice(0, 1);
                var b = new G.Text(60, 0, G.txt(a), {
                    fill: "#fdfbe4",
                    font: "ComicSansBold",
                    fontSize: "30px",
                    stroke: "#73461c",
                    strokeThickness: 7
                }, [0, .5], 300);
                b.scale.x = 0, game.add.tween(b.scale).to({
                    x: 1
                }, 300, Phaser.Easing.Elastic.Out, !0), this.add(b), this.duringMessage = !0, game.add.tween(b).to({
                    alpha: 0
                }, 500, Phaser.Easing.Sinusoidal.In, !0, 2e3).onComplete.add(function() {
                    this.duringMessage = !1, b.destroy()
                }, this)
            }
        }, G.GlobalGoalButton.prototype.addTutHand = function() {
            this.tutHand = G.makeImage(0, 10, "tut_hand", 0, this), game.add.tween(this.tutHand).to({
                x: G.l(10),
                y: G.l(20)
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.goalBtn.onClick.addOnce(function() {
                this.tutHand && (this.tutHand.destroy(), this.tutHand = null, G.saveState.data.sawGlobalGoalsTut = !0)
            }, this)
        }, G.GlobalGoalMgr = function() {
            this.globalGoalsTemplates = G.json.settings.globalGoals, this.loadGoals(), this.lastSave = 15, setInterval(function() {
                G.sb("onWallClockTimeUpdate").dispatch(Date.now())
            }, 1e3), G.sb("onGlobalGoalOutOfTime").addPermanent(this.saveGoals, this), G.sb("onWallClockTimeUpdate").addPermanent(this.updateTimers, this)
        }, G.GlobalGoalMgr.prototype.saveGoals = function() {
            var a = [];
            this.goals.forEach(function(b) {
                a.push(b.stringify())
            }), G.saveState.data.globalGoals = a, G.saveState.save()
        }, G.GlobalGoalMgr.prototype.loadGoals = function() {
            if (this.goals = [], !(G.saveState.getLastPassedLevelNr() < G.json.settings.featuresUnlock.globalGoals))
                for (G.saveState.data.globalGoals.forEach(function(a) {
                        this.goals.push(this.parseGoal(a))
                    }, this); this.goals.length < 4;) this.createNewGoal()
        }, G.GlobalGoalMgr.prototype.unlockCheck = function() {
            0 === this.goals.length && G.saveState.getLastPassedLevelNr() >= G.json.settings.featuresUnlock.globalGoals && this.loadGoals()
        }, G.GlobalGoalMgr.prototype.updateTimers = function(a) {
            for (var b = 0; b < this.goals.length; b++) this.goals[b].updateTimer(a)
        }, G.GlobalGoalMgr.prototype.isAnyToUserAttention = function() {
            for (var a = 0, b = 0; b < this.goals.length; b++) "active" != this.goals[b].status && a++;
            return a
        }, G.GlobalGoalMgr.prototype.getAttentionReason = function() {
            for (var a = [], b = 0; b < this.goals.length; b++) "active" != this.goals[b].status && -1 == a.indexOf(this.goals[b].status) && a.push(this.goals[b].status);
            return a
        }, G.GlobalGoalMgr.prototype.parseGoal = function(a) {
            var b = JSON.parse(a),
                c = new G.GlobalGoal(b.id, b.description, b.listener, b.terms, b.increaser, b.target, b.timeDuration, b.afterIncreaseCallbackName, b.reward, b.rewardHidden, b.cancelationPrice);
            return c.status = b.status, c.current = b.current, b.timeBeginingDate && (c.timeBinding = G.sb("onWallClockTimeUpdate").addPermanent(c.updateTimer, this), c.timeBeginingDate = b.timeBeginingDate, c.updateTimer(Date.now())), c
        }, G.GlobalGoalMgr.prototype.removeAndPushNew = function(a) {
            var b = a.id,
                c = this.goals.indexOf(a);
            this.goals.splice(c, 1), a.destroy(), G.sb("onGlobalGoalRemove").dispatch(a, c);
            var d = this.createNewGoal(b);
            return this.saveGoals(), d
        }, G.GlobalGoalMgr.prototype.createNewGoal = function(a) {
            var b = [];
            void 0 !== a && b.push(a);
            for (var c = 0; c < this.goals.length; c++) b.push(this.goals[c].id);
            var d = G.saveState.getLastPassedLevelNr(),
                e = this.globalGoalsTemplates.filter(function(a) {
                    if (a.levelRangeRequired && Array.isArray(a.levelRangeRequired)) {
                        var b = a.levelRangeRequired[0],
                            c = a.levelRangeRequired[1];
                        return b <= d && d < c
                    }
                    return !0
                });
            for (e.length < 4 && (e = this.globalGoalsTemplates);;) {
                var f = Math.floor(Math.random() * e.length);
                if (-1 == b.indexOf(e[f].id)) break
            }
            var g = e[f],
                h = G.saveState.getLastPassedLevelNr() / G.json.levels.length;
            if (g.levelRangeRequired && Array.isArray(g.levelRangeRequired)) {
                var i = g.levelRangeRequired[1] - g.levelRangeRequired[0];
                h = (d - g.levelRangeRequired[0]) / i, h = game.math.clamp(h, 0, 1)
            }
            var j = this.prepareArgumentsArray(g, h),
                k = new(Function.prototype.bind.apply(G.GlobalGoal, [null].concat(j)));
            return k.timeRestriction || k.start(), this.goals.push(k), G.sb("onGoalCreated").dispatch(k, this.goals.indexOf(k)), k
        }, G.GlobalGoalMgr.safetyCheck = function() {
            function a(a) {
                return G.json.settings.globalGoals.filter(function(b) {
                    if (b.levelRangeRequired && Array.isArray(b.levelRangeRequired)) {
                        var c = b.levelRangeRequired[0],
                            d = b.levelRangeRequired[1];
                        return c <= a && a < d
                    }
                    return !0
                })
            }
            for (var b = 0; b < G.json.levels.length++; b++) {
                var c = a(b).length;
                console.log(b, c)
            }
        }, G.GlobalGoalMgr.prototype.prepareArgumentsArray = function(a, b) {
            var c = a.targetRange[0] + 5 * Math.floor((a.targetRange[1] - a.targetRange[0]) * b / 5),
                d = !1;
            void 0 !== a.terms && (d = JSON.parse(JSON.stringify(a.terms)));
            var e = !1;
            void 0 !== a.timeRange && Math.random() < .3 && (e = a.timeRange[0] + 5 * Math.floor((a.timeRange[1] - a.timeRange[0]) * b / 5));
            var f = G.gift.getGift("missions");
            return [a.id, a.description.replace("%TARGET%", c.toString()), a.listener, d, a.increaser, c, e, a.afterIncrease, f, Math.random() < .4]
        }, G.GlobalGoal = function(a, b, c, d, e, f, g, h, i, j, k) {
            this.id = a, this.reward = i, this.rewardHidden = j || !1, this.description = b, this.status = "inactive", this.listenerBinding = G.sb(c).addPermanent(this.onListener, this), this.listener = c, this.current = 0, this.target = f, this.timeRestriction = g || !1, this.timeDuration = g || 0, this.timeBeginingDate = !1, this.cancelationPrice = k || 5 * game.rnd.between(G.json.settings.priceOfGoalRemove[0] / 5, G.json.settings.priceOfGoalRemove[1] / 5), this.terms = d, this.increaser = e, this.afterIncreaseCallback = this.customAfterIncrease[h] || !1, this.afterIncreaseCallbackName = h || "", this.onFinish = new Phaser.Signal
        }, G.GlobalGoal.prototype.customAfterIncrease = {
            pushPassedLevelToTerms: function(a) {
                this.terms || (this.terms = [
                    []
                ]), this.terms[0].push("!" + a)
            }
        }, G.GlobalGoal.prototype.stringify = function() {
            var a = {
                id: this.id,
                reward: this.reward,
                rewardHidden: this.rewardHidden,
                description: this.description,
                status: this.status,
                current: this.current,
                target: this.target,
                listener: this.listener,
                terms: this.terms,
                increaser: this.increaser,
                timeRestriction: this.timeRestriction,
                timeDuration: this.timeDuration,
                timeBeginingDate: this.timeBeginingDate,
                afterIncreaseCallbackName: this.afterIncreaseCallbackName,
                cancelationPrice: this.cancelationPrice
            };
            return JSON.stringify(a)
        }, G.GlobalGoal.prototype.getProgress = function() {
            return Math.min(this.current, this.target) / this.target
        }, G.GlobalGoal.prototype.getLeft = function() {
            return Math.max(0, this.target - this.current)
        }, G.GlobalGoal.prototype.start = function() {
            "inactive" === this.status && (this.status = "active", this.timeRestriction && (this.timeBeginingDate = Date.now(), this.timeBinding = G.sb("onWallClockTimeUpdate").addPermanent(this.updateTimer, this)))
        }, G.GlobalGoal.prototype.finish = function() {
            "active" === this.status && (this.listenerBinding.detach(), this.timeRestriction && this.timeBinding.detach(), this.current >= this.target ? (G.gameTracking.design("MissionCompleted"), this.status = "achieved") : (G.gameTracking.design("MissionFailed"), this.status = "failed"), this.onFinish.dispatch(this.status))
        }, G.GlobalGoal.prototype.updateTimer = function(a) {
            "active" === this.status && this.timeRestriction && a - this.timeBeginingDate > 60 * this.timeDuration * 1e3 && (this.finish(), G.sb("onGlobalGoalOutOfTime").dispatch(this))
        }, G.GlobalGoal.prototype.checkTerms = function(a) {
            if (this.terms)
                for (var b = 0, c = this.terms.length; b < c; b++) {
                    var d = this.terms[b];
                    if (Array.isArray(d)) {
                        if (!this.checkArrayTerm(a[b], d)) return !1
                    } else if (!this.checkTerm(a[b], d)) return !1
                }
            return !0
        }, G.GlobalGoal.prototype.checkArrayTerm = function(a, b) {
            for (var c = 0; c < b.length; c++)
                if (!this.checkTerm(a, b[c])) return !1;
            return !0
        }, G.GlobalGoal.prototype.checkTerm = function(a, b) {
            return !1 === b || ("string" == typeof b && "!" === b[0] ? a != b.slice(1) : a == b)
        }, G.GlobalGoal.prototype.processIncrease = function(a) {
            if ("number" == typeof this.increaser) this.current += this.increaser;
            else if (Array.isArray(this.increaser))
                for (var b = 0, c = this.increaser.length; b < c; b++) this.increaser[b] && (this.current += a[b])
        }, G.GlobalGoal.prototype.getEndtime = function() {
            this.timeBeginingDate, this.timeDuration
        }, G.GlobalGoal.prototype.destroy = function() {
            this.listenerBinding.detach(), this.timeBinding && this.timeBinding.detach()
        }, G.GlobalGoal.prototype.getRemainingSeconds = function() {
            return "inactive" == this.status ? 60 * this.timeDuration : Math.max(0, Math.floor((60 * this.timeDuration * 1e3 - (Date.now() - this.timeBeginingDate)) / 1e3))
        }, G.GlobalGoal.prototype.onListener = function() {
            "active" === this.status && (this.checkTerms(arguments) && (this.processIncrease(arguments), this.afterIncreaseCallback && this.afterIncreaseCallback.apply(this, arguments)), this.current >= this.target && this.finish())
        }, G.GlobalGoalPanel = function(a, b, c, d) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.x = a, this.y = b, this.bg = G.makeImage(-35, 8, "goal_bar_empty", .5, this), this.goalObj = c, this.goalIndex = d, this.label = new G.LabelGroupT(this.goalObj.description, -210, -5, {
                font: "ComicSansBold",
                fontSize: "30px",
                fill: "#ece9e5"
            }, [0, .5], 200), this.add(this.label), this.prize = new G.LabelGroupT(this.goalObj.rewardHidden ? "@*1.3*gift_small@" : G.gift.getLabelString(this.goalObj.reward), 140, -5, {
                font: "ComicSansBold",
                fontSize: "30px",
                fill: "#ece9e5"
            }, [1, .5], 200), this.add(this.prize), this.bar = G.makeImage(-216, 24, "goal_bar_full", 0, this), this.bar.cropRect = new Phaser.Rectangle(0, 0, this.bar.width * this.goalObj.getProgress(), this.bar.height), this.bar.updateCrop(), this.goalObj.timeRestriction && ("active" != this.goalObj.status && "inactive" != this.goalObj.status || (this.timer = new G.Timer(142, 22, "font-white", 20, 300, 1, 0), this.add(this.timer), this.timer.setSecLeft(this.goalObj.getRemainingSeconds()), this.onFinishBinding = this.goalObj.onFinish.add(this.onGoalFinish, this), this.timer.events.onDestroy.add(this.onFinishBinding.detach, this.onFinishBinding)), "active" == this.goalObj.status ? this.timer.start() : "inactive" == this.goalObj.status && (this.startBtn = new G.Button(200, 10, "btn_start_goal", function() {
                this.goalObj.start(), this.timer.start(), this.startBtn.destroy(), this.addGoalRemoveBtn(), G.gameTracking.design("MissionStarted")
            }, this), this.startBtn.pulse(), this.add(this.startBtn))), "failed" == this.goalObj.status && this.addGoalFailedBtn(), "achieved" == this.goalObj.status && this.addGoalAchievedBtn(), "active" == this.goalObj.status && this.addGoalRemoveBtn()
        }, G.GlobalGoalPanel.prototype = Object.create(Phaser.Group.prototype), G.GlobalGoalPanel.prototype.replaceSelfWithNewGoal = function() {
            G.globalGoalMgr.removeAndPushNew(this.goalObj)
        }, G.GlobalGoalPanel.prototype.addGoalFailedBtn = function() {
            this.timer && this.timer.destroy(), this.failedIcon = G.makeImage(this.label.x + this.label.width, this.label.y, "task_fail", [0, .5], this), this.replaceBtn = new G.Button(200, 10, "btn_trash", function() {
                this.replaceSelfWithNewGoal()
            }, this), this.replaceBtn.pulse(), this.add(this.replaceBtn)
        }, G.GlobalGoalPanel.prototype.addGoalAchievedBtn = function() {
            this.timer && this.timer.destroy(), this.successIcon = G.makeImage(this.label.x + this.label.width, this.label.y, "task_complete", [0, .5], this);
            var a = this.goalObj.rewardHidden;
            this.replaceBtn = new G.Button(200, 10, a ? "btn_present" : "btn_buy", function() {
                this.replaceSelfWithNewGoal(), a ? (G.sb("closeAndOpenWindow").dispatch("gift", !1, this.goalObj.reward), G.sb("pushWindow").dispatch("globalGoals")) : (G.sfx.match_4.play(), "coin" == this.goalObj.reward[0] ? this.state.uiTargetParticles.createCoinBatch(game.world.bounds.x + this.replaceBtn.worldPosition.x, this.replaceBtn.worldPosition.y, this.state.panel.coinsTxt, this.goalObj.reward[1]) : G.gift.applyGift(this.goalObj.reward)), G.gameTracking.design("MissionRewardCollected")
            }, this), this.replaceBtn.pulse(), this.add(this.replaceBtn)
        }, G.GlobalGoalPanel.prototype.addGoalRemoveBtn = function() {
            this.goalRemoveBtn = new G.Button(200, 10, "btn_trash_buy", function() {
                G.sfx.cash_register.play(), G.saveState.getCoins() >= this.goalObj.cancelationPrice ? (G.saveState.changeCoins(-this.goalObj.cancelationPrice), this.replaceSelfWithNewGoal(), G.gameTracking.design("MissionSkipped"), G.gameTracking.sink("Coins", "MissionSkip", "Map", this.goalObj.cancelationPrice)) : game.incentivised ? G.sb("closeAndOpenWindow").dispatch("moreMoney", "globalGoals") : G.saveState.getCoins() < this.goalObj.cancelationPrice && (16711680 !== this.goalRemoveBtn.price.tint && (this.goalRemoveBtn.price.tint = 16711680, this.goalRemoveBtn.price.updateCache()), this.goalRemoveBtn.alpha = .5)
            }, this), this.goalRemoveBtn.price = new G.Text(-7, 26, this.goalObj.cancelationPrice.toString(), {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "25px"
            }, [0, .5], 40), this.goalRemoveBtn.addChild(this.goalRemoveBtn.price), this.add(this.goalRemoveBtn), !game.incentivised && G.saveState.getCoins() < this.goalObj.cancelationPrice && (this.goalRemoveBtn.price.tint = 16711680, this.goalRemoveBtn.price.updateCache(), this.goalRemoveBtn.alpha = .5)
        }, G.GlobalGoalPanel.prototype.onGoalFinish = function(a) {
            this.goalRemoveBtn && this.goalRemoveBtn.destroy(), "achieved" == a ? this.addGoalAchievedBtn() : this.addGoalFailedBtn()
        }, G.GlobalGoalPanelGroup = function(a, b, c) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.maxHeight = G.l(c), this.panelDistance = this.maxHeight / 3, this.panels = [], G.globalGoalMgr.goals.forEach(function(a, b) {
                this.createGoalPanel(a, b)
            }, this), G.sb("onGoalCreated").add(this.onGoalCreated, this), G.sb("onGlobalGoalRemove").add(this.onGoalRemove, this)
        }, G.GlobalGoalPanelGroup.prototype = Object.create(Phaser.Group.prototype), G.GlobalGoalPanelGroup.prototype.createGoalPanel = function(a, b) {
            var c = new G.GlobalGoalPanel(0, b * this.panelDistance, a, b);
            this.panels.push(c), this.add(c)
        }, G.GlobalGoalPanelGroup.prototype.onGoalRemove = function(a, b) {
            var c = this.panels.splice(b, 1)[0];
            c.igonreChildInput = !1, this.bringToTop(c), game.add.tween(c).to({
                alpha: 0
            }, 400, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(c.destroy, c), game.add.tween(c.scale).to({
                x: 1.1,
                y: 1.1
            }, 400, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(c.destroy, c), this.refreshPanelsPosition()
        }, G.GlobalGoalPanelGroup.prototype.refreshPanelsPosition = function() {
            this.panels.forEach(function(a) {
                var c = G.globalGoalMgr.goals.indexOf(a.goalObj);
                c != a.goalIndex && (G.stopTweens(a), a.alpha = 1, game.add.tween(a).to({
                    y: c * this.panelDistance
                }, 400, Phaser.Easing.Linear.None, !0))
            }, this)
        }, G.GlobalGoalPanelGroup.prototype.onGoalCreated = function(a, b) {
            var c = new G.GlobalGoalPanel(0, b * this.panelDistance, a, b);
            c.igonreChildInput = !1, this.panels.push(c), this.add(c), game.add.tween(c).from({
                y: c.y + G.l(100),
                alpha: 0
            }, 400, Phaser.Easing.Linear.None, !0).onComplete.add(function() {
                c.igonreChildInput = !0
            })
        }, G.JewelsBlitzMoneyCounter = function() {
            Phaser.Group.call(this, game), this.x = 0, this.y = 0, this.amountTxt = new G.Text(0, 0, G.lvl.moneyGained, {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "30px"
            }, [0, .5], 100), this.add(this.amountTxt), this.coinIcon = G.makeImage(0, 0, "coin_1", [0, .5], this), this.coinIcon.scale.setTo(.4), this.amountTxt.cacheAsBitmap = !1, G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize(), this.alpha = 0, this.levelFinished = !1, G.sb("onLevelFinished").add(function() {
                this.levelFinished = !0
            }, this)
        }, G.JewelsBlitzMoneyCounter.prototype = Object.create(Phaser.Group.prototype), G.JewelsBlitzMoneyCounter.prototype.update = function() {
            this.levelFinished ? this.alpha = Math.max(0, this.alpha - .05) : (this.alpha = Math.min(1, this.alpha + .05), this.amountDisplayed !== G.lvl.moneyGained && this.updateCoinsAmount(G.lvl.moneyGained))
        }, G.JewelsBlitzMoneyCounter.prototype.updateCoinsAmount = function(a) {
            G.stopTweens(this), this.scale.setTo(1), game.add.tween(this.scale).to({
                x: 1.3,
                y: 1.3
            }, 200, Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0), this.amountTxt.setText(a.toString());
            var b = -.5 * (this.amountTxt.width + this.coinIcon.width);
            this.amountTxt.x = b, this.coinIcon.x = this.amountTxt.x + this.amountTxt.width + G.l(5), this.amountDisplayed = a
        }, G.JewelsBlitzMoneyCounter.prototype.onScreenResize = function() {
            G.horizontal ? (this.x = 0, this.y = G.l(440)) : (this.x = G.l(415), this.y = G.l(74))
        }, G.LabelTextT = function(a, b, c, d, e, f, g) {
            Phaser.Group.call(this, game), this.str = a, this.tagArray = G.LabelParser.changeIntoTagArray(a), this.x = b, this.y = c, this.textStyle = G.Text.getStyle(d), this.fontSize = parseInt(d.fontSize), this.distanceBetween = g || 0, "number" == typeof e ? this.anchorX = this.anchorY = e : (this.anchorX = e[0], this.anchorY = e[1]), this.maxWidth = f || 0, this.processTagArray()
        }, G.LabelTextT.prototype = Object.create(Phaser.Group.prototype), G.LabelTextT.prototype.processTagArray = function() {
            for (var a = 0; a < this.tagArray.length; a++)
                if ("img" == this.tagArray[a].type)(b = G.makeImage(0, 0, this.tagArray[a].content, 0, this)).tagScale = this.tagArray[a].scale;
                else if ("separator" == this.tagArray[a].type) {
                var b;
                (b = G.makeImage(0, 0, null, 0, this)).SEPARATOR = !0, b.SEP_LENGTH = .5 * this.tagArray[a].length
            } else this.add(new G.Text(0, 0, this.tagArray[a].content, this.textStyle));
            this.refresh()
        }, G.LabelTextT.prototype.refresh = function() {
            if (this.applySizeAndAnchor(), 0 < this.maxWidth && this.getWholeWidth() > this.maxWidth)
                for (; this.getWholeWidth() > this.maxWidth;) this.distanceBetween = Math.floor(.9 * this.distanceBetween), this.fontSize = Math.floor(.9 * this.fontSize), this.applySizeAndAnchor();
            this.spreadElements()
        }, G.LabelTextT.prototype.applySizeAndAnchor = function() {
            this.children.forEach(function(a) {
                a.anchor.setTo(this.anchorX, this.anchorY), a.fontSize ? (a.fontSize = this.fontSize, a.updateTransform(), a.y += a.padding.y) : (a.height = this.fontSize * (a.tagScale || 1), a.scale.x = a.scale.y), a.SEPARATOR && (a.width = this.fontSize * a.SEP_LENGTH)
            }, this)
        }, G.LabelTextT.prototype.getWholeWidth = function() {
            var a = (this.children.length - 1) * this.distanceBetween,
                b = 0;
            return this.children.forEach(function(a) {
                b += a.width
            }), a + b
        }, G.LabelTextT.prototype.spreadElements = function() {
            var a = this.getWholeWidth() * this.anchorX * -1;
            this.children.forEach(function(b, c, d) {
                b.left = 0 == c ? a : d[c - 1].right + this.distanceBetween
            }, this)
        }, G.LabelTextT.prototype.addOffsetYToText = function(a) {
            this.children.forEach(function(b) {
                b.fontSize && (b.y += a)
            })
        }, G.LevelGenerator = {}, G.LevelGenerator.generate = function(a) {
            var b = {
                    mapX: 400 * Math.random() - 200,
                    mapY: -400 * Math.random(),
                    moves: a.movesNr,
                    nrOfTypes: a.typesOfCandy,
                    goal: ["collect", []],
                    bgImg: a.bgImg,
                    starsReq: [3e3, 5e3, 7e3],
                    drops: {
                        chest: a.chestDrop,
                        chain: a.chainDrop,
                        infection: a.infectionDrop
                    }
                },
                c = new G.GridArray(8, 8);
            c.loop(function(a, b, c, d) {
                d[b][c] = []
            });
            var d = this.pickBlockers(b, a);
            return this.putBlockers(c, a, d), b.levelData = c.data, b.goal[1] = this.makeGoal(c, a, b, d), this.fillWithRandom(c, a), b
        }, G.LevelGenerator.putBlockers = function(a, b, c) {
            for (var d = 0; d < c.length; d++) switch (c[d]) {
                case "concrete":
                    this.putSymmetrical(a, [!1, "cn3", "cn2", "cn1"], this.getRandomEvenInRange(b.concrete[0], b.concrete[1]), ["dirt3", "dirt2", "dirt1", "cn3", "cn2", "cn1", "infection"], 2);
                    break;
                case "ice":
                    this.putSymmetrical(a, "ice", this.getRandomEvenInRange(b.ice[0], b.ice[1]), ["ice", "dirt3", "dirt2", "dirt1", "infection"], 3);
                    break;
                case "chain":
                    this.putWrapped(a, b);
                    break;
                case "dirt":
                    this.putSymmetrical(a, ["dirt3", "dirt2", "dirt1"], this.getRandomEvenInRange(b.dirt[0], b.dirt[1]), ["ice", "dirt3", "dirt2", "dirt1", "cn3", "cn2", "cn1"], 0);
                    break;
                case "infection":
                    this.putSymmetrical(a, "infection", this.getRandomEvenInRange(b.infection[0], b.infection[1]), ["infection", "cn3", "cn2", "cn1", "ice", "W1", "W2", "W3", "W4", "W5", "W6"], 0)
            }
        }, G.LevelGenerator.pickBlockers = function(a, b) {
            var c = [];
            ["concrete", "ice", "chain", "dirt", "infection"].forEach(function(a) {
                0 < b[a][1] && c.push(a)
            }), Phaser.ArrayUtils.shuffle(c);
            for (var d = [], e = game.rnd.between(b.blockersTypes[0], b.blockersTypes[1]), f = 0; f < Math.min(c.length, e); f++) d.push(c[f]);
            return d
        }, G.LevelGenerator.putWrapped = function(a, b) {
            for (var c = [!1], d = 1; d <= b.typesOfCandy; d++) c.push("W" + d.toString());
            this.putSymmetrical(a, c, this.getRandomEvenInRange(b.chain[0], b.chain[1]), ["infection", "W1", "W2", "W3", "W4", "W5", "W6"])
        }, G.LevelGenerator.fillWithRandom = function(a) {
            var c = ["W1", "W2", "W3", "W4", "W5", "W6", "infection"];
            a.loop(function(b, d, e) {
                this.shouldAvoidCell(a, d, e, c) || b.unshift("r")
            }, this)
        }, G.LevelGenerator.getRandomEven = function(a) {
            var b = game.rnd.between(0, a);
            return b % 2 == 1 && (b < a ? b++ : b--), b
        }, G.LevelGenerator.getRandomEvenInRange = function(a, b) {
            var c = game.rnd.between(a, b);
            return c % 2 == 1 && (c < b ? c++ : c--), c
        }, G.LevelGenerator.makeGoal = function(a, b, c, d) {
            for (var e = [], f = 1; f <= b.typesOfCandy; f++) e.push([f.toString(), 5 * Math.ceil(game.rnd.between(b.normReq[0], b.normReq[1]) / 5)]);
            var g = {
                concrete: ["cn3", "cn2", "cn1"],
                ice: ["ice"],
                chain: ["W1", "W2", "W3", "W4", "W5", "W6"],
                dirt: ["dirt3", "dirt2", "dirt1"],
                infection: ["infection"]
            };
            for (f = 0; f < d.length; f++) e.push([d[f], this.countOnBoard(a, g[d[f]])]);
            var h = game.rnd.between(b.goalRange[0], b.goalRange[1]);
            return Phaser.ArrayUtils.shuffle(e), e.splice(0, h)
        }, G.LevelGenerator.countEmptySpaces = function(a) {
            return this.countOnBoard(a, "X")
        }, G.LevelGenerator.countOnBoard = function(a, b) {
            var c = 0;
            Array.isArray(b) || (b = Array.prototype.slice.call(arguments).splice(1));
            for (var d = 0; d < b.length; d++) {
                var e = b[d];
                a.loop(function(a) {
                    -1 !== a.indexOf(e) && c++
                })
            }
            return c
        }, G.LevelGenerator.putSymmetrical = function(a, b, c, d, e) {
            if (e = e || 0, Array.isArray(b)) var f = b,
                g = f.shift();
            if (console.log("PUT SYMETRIC: " + b + " x " + c), 0 != c) {
                var h = Math.random() < .5;
                console.log(h);
                for (var i = Math.ceil(.5 * a.width), j = h ? Math.ceil(.5 * a.height) : a.height, k = [], l = 0; 0 < c;) {
                    if (400 == l++) return;
                    f && g && (b = f[Math.floor(Math.random() * f.length)]), k = [];
                    var m = Math.floor(Math.random() * i),
                        n = Math.floor(Math.random() * j),
                        o = a.width - 1 - m,
                        p = a.height - 1 - n;
                    !this.shouldAvoidCell(a, m, n, d) && 0 < c && e <= n && (console.log("PUT: " + m + "x" + n), f && !g && (b = f[Math.floor(Math.random() * f.length)]), a.data[m][n].push(b), c--, k.push(!0)), !this.shouldAvoidCell(a, o, n, d) && 0 < c && e <= n && (console.log("PUT XR: " + o + "x" + n), f && !g && (b = f[Math.floor(Math.random() * f.length)]), a.data[o][n].push(b), c--, k.push(!0)), h && (!this.shouldAvoidCell(a, m, p, d) && 0 < c && e <= p && (f && !g && (b = f[Math.floor(Math.random() * f.length)]), a.data[m][p].push(b), console.log("PUT YR: " + m + "x" + p), c--, k.push(!0)), !this.shouldAvoidCell(a, o, p, d) && 0 < c && e <= p && (f && !g && (b = f[Math.floor(Math.random() * f.length)]), a.data[o][p].push(b), console.log("PUT XR YR: " + o + "x" + p), c--, k.push(!0))), k.length % 2 == 1 && c--
                }
            }
        }, G.LevelGenerator.shouldAvoidCell = function(a, b, c, d) {
            for (var e = a.data[b][c], f = 0; f < d.length; f++)
                if (-1 !== e.indexOf(d[f])) return !0;
            return !1
        }, G.LvlGoalMgr = function(a) {
            this.onGoalAchieved = new Phaser.Signal, this.onGoalNumberChanged = new Phaser.Signal, this.goalsSettings = G.json.settings.goals, this.bindings = [], "collect" === a[0] ? (this.COLLECT = !0, this.tasksMap = this.processCollectGoals(a[1]), this.bindings.push(G.sb("onCollectableRemove").add(this.onCollectableRemove, this), G.sb("onCollectableAdded").add(this.onCollectableAdded, this))) : (this.POINTS = !0, this.pointsTarget = a[1], this.bindings.push(G.sb("onPointsChange").add(this.onPointsChange, this)))
        }, G.LvlGoalMgr.prototype = {
            isPointBased: function() {
                return this.POINTS
            },
            getPointTarget: function() {
                return this.pointsTarget
            },
            isGoal: function(a) {
                return !(!this.tasksMap || !this.tasksMap[a]) && !this.tasksMap[a].completed
            },
            goalAchieved: function() {
                this.bindings.forEach(function(a) {
                    a.detach()
                }), this.onGoalAchieved.dispatch()
            },
            onPointsChange: function(a) {
                a >= this.pointsTarget && this.goalAchieved()
            },
            processCollectGoals: function(a) {
                var b = {};
                return a.forEach(function(a) {
                    var c = a[0],
                        d = a[1],
                        e = this.goalsSettings[c],
                        f = {
                            target: d,
                            dynamic: e.dynamic || !1,
                            uiAnimation: e.toUIAnimation,
                            completed: !1
                        };
                    b[c] = f
                }, this), b
            },
            onCollectableAdded: function(a) {
                var b = this.tasksMap[a];
                b && b.dynamic && !b.completed && (b.target++, G.sb("onTaskAmountChanged").dispatch(a, 1))
            },
            onCollectableRemove: function(a, b, c) {
                var d = this.tasksMap[a];
                d && !d.completed && (d.uiAnimation ? G.sb("onCandyToUIAnim").dispatch(a, b, c, function() {
                    G.sb("onTaskAmountChanged").dispatch(a, -1)
                }) : G.sb("onTaskAmountChanged").dispatch(a, -1), d.target--, 0 == d.target && (G.sb("onCollectableTaskFinished").dispatch(a), d.completed = !0, this.areAllCompleted() && this.goalAchieved()))
            },
            areAllCompleted: function() {
                var a = !0;
                return Object.keys(this.tasksMap).forEach(function(b) {
                    this.tasksMap[b].completed || (a = !1)
                }, this), a
            }
        }, G.LvlObject = function() {
            this.state = game.state.getCurrentState(), this.lvlNr = this.state.lvlNr, this.latestLevel = this.lvlNr === G.saveState.getLastPassedLevelNr(), this.coinChanceProb = 0 == G.saveState.getStars(this.lvlNr) ? 1 : G.json.settings.completedLevelCoinsProb, this.stars = 0, this.combo = 0, this.data = G.lvlData, this.goalAchieved = !1, this.moves = G.lvlData.moves, this.points = 0, this.boosterInUse = !1, this.movesMade = 0, this.goal = G.lvlData.goal, this.goalMgr = new G.LvlGoalMgr(G.lvlData.goal), this.goalMgr.onGoalAchieved.add(function() {
                this.goalAchieved = !0, G.sb("onGoalAchieved").dispatch()
            }, this), this.items = [], this.firstMoveMade = !1, this.extraMovesBoughtNr = 0, this.outOfMovesPopUp = 0, this.moneyGained = 0, this.comboBonus = G.json.settings.comboBonus, this.moneyGainedChest = 0, G.sb("onLevelMoneyGain").add(function(a) {
                this.moneyGained += a
            }, this)
        }, G.LvlObject.prototype = {
            getPriceOfExtraMoves: function() {
                return G.json.settings.priceOfExtraMoves * (this.extraMovesBoughtNr + 1)
            },
            buyExtraMoves: function(a, b) {
                var c = b || G.json.settings.priceOfExtraMoves * (a ? 2 : 1);
                G.saveState.data.coins -= c, G.saveState.save(), this.extraMovesBoughtNr++, this.changeMoveNumber(5), G.sb("onExtraMovesUsed").dispatch(), G.gameTracking.sink("Coins", "Moves", "InGame", c)
            },
            isGoalAchieved: function() {
                return this.goalAchieved
            },
            madeMove: function() {
                G.IMMEDIATE || this.changeMoveNumber(-1), this.goalAchieved || (this.movesMade++, G.sb("userMadeMove").dispatch()), G.sb("madeMove").dispatch()
            },
            changeMoveNumber: function(a) {
                this.moves += a, G.sb("changeMoveNumber").dispatch()
            },
            changePointsNumber: function(a) {
                this.points += a, G.sb("onPointsAdded").dispatch(a), G.sb("onPointsChange").dispatch(this.points)
            },
            increaseCombo: function() {
                this.combo++, G.sb("onComboIncrease").dispatch(this.combo)
            },
            endCombo: function() {
                this.combo = 0, G.sb("onComboBreak").dispatch()
            },
            processMatch: function(a, b, c, d) {
                var e = a * (10 + this.getComboBonus());
                this.changePointsNumber(e);
                var f = this.state.board.cellToPxOut([b, c]);
                G.sb("displayPoints").dispatch(f[0], f[1], e, d), this.firstMoveMade || (this.firstMoveMade = !0, 0 === this.lvlNr || 1 === this.lvlNr || this.lvlNr)
            },
            getComboBonus: function() {
                return this.comboBonus[Math.min(this.combo, this.comboBonus.length - 1)]
            },
            isGoal: function(a) {
                return this.goalMgr.isGoal(a)
            }
        }, G.MapGift = function() {
            Phaser.Group.call(this, game), this.position.setTo(0, 220), G.saveState.data.lastMapGiftOpenTime || (G.saveState.data.lastMapGiftOpenTime = 0), this.msGiftCooldown = 60 * G.json.settings.mapGiftTimeMinutes * 1e3, this.active = Date.now() - G.saveState.data.lastMapGiftOpenTime > this.msGiftCooldown, this.addGlow(), this.btn = new G.Button(3, 0, "gift", this.open, this), this.btnDarkOverlay = G.makeImage(0, 0, "gift", .5, this.btn), this.btnDarkOverlay.tint = 0, this.btnDarkOverlay.alpha = .5, this.btn.scale.setTo(.4), this.add(this.btn), this.btn.addTerm(function() {
                return this.active
            }, this), this.addTimer(), this.active || this.startTimer(), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.MapGift.prototype = Object.create(Phaser.Group.prototype), G.MapGift.prototype.update = function() {
            this.glow.angle++, Date.now() - G.saveState.data.lastMapGiftOpenTime > this.msGiftCooldown ? (this.active = !0, this.ignoreChildInput = !1) : (this.active && this.startTimer(), this.active = !1, this.ignoreChildInput = !0), this.glow.visible = this.active, this.btnDarkOverlay.visible = !this.active, this.timer.visible = !this.active
        }, G.MapGift.prototype.onResize = function() {
            var a = game.world.bounds.x + Math.floor(.5 * game.width);
            this.x = game.width < 1070 ? a - 265 : a - 265 - 235
        }, G.MapGift.prototype.open = function() {
            G.gameTracking.design("FreeGiftButtonClicked"), G.sb("pushWindow").dispatch("mapGift")
        }, G.MapGift.prototype.addTimer = function() {
            this.timer = new G.TextTimer(5, 55, null, {
                fill: "#fdfbe4",
                font: "ComicSansBold",
                fontSize: "25px",
                stroke: "#73461c",
                strokeThickness: 7
            }, .5, 130), this.add(this.timer), this.add(this.timer)
        }, G.MapGift.prototype.startTimer = function() {
            var a = Math.floor((G.saveState.data.lastMapGiftOpenTime + this.msGiftCooldown - Date.now()) / 1e3);
            this.timer.setSecLeft(a), this.timer.active = !0
        }, G.MapGift.prototype.addGlow = function() {
            this.glow = G.makeImage(0, 0, "popup_lighht", .5, this), this.glow.alpha = .5, this.glow.scale.setTo(.5), this.glow.blendMode = 1
        }, G.MapTilesRenderer = function() {
            Phaser.Group.call(this, game), this.marker = G.makeImage(0, 0, null), this.rts = [], this.imgs = [];
            for (var a = this.getMapTotalHeight(), b = a, c = Math.ceil(b / 600), d = {
                    totalHeight: a,
                    tiles: []
                }, e = 0; e < c; e++) Math.min(600, b), this.rts[e] = game.make.renderTexture(1200, 600, "map-tile-" + e, !0), this.drawMap(this.rts[e], G.json.map, 600 * e), b -= 600, d.tiles.push({
                rt: "map-tile-" + e,
                y: 600 * -e
            });
            G.json.settings.mapTiles = d, this.marker.destroy()
        }, G.MapTilesRenderer.prototype = Object.create(Phaser.Group.prototype), G.MapTilesRenderer.prototype.getMapTotalHeight = function() {
            for (var a = 0; a < G.json.map.length; a++)
                if (G.json.map[a].label && "ENDMARKER" === G.json.map[a].label) return Math.floor(-1 * G.json.map[a].y)
        }, G.MapTilesRenderer.prototype.drawMap = function(a, b, c) {
            for (var d = .5 * a.width, e = a.height + c, f = 0; f < b.length; f++) {
                var g = b[f];
                g.label && "ENDMARKER" === g.label || this.drawElementXY(g.x + d, g.y + e, g, a)
            }
        }, G.MapTilesRenderer.prototype.drawElementXY = function(a, b, c, d) {
            this.marker.position.setTo(a, b), this.marker.anchor.setTo(c.anchor[0], c.anchor[1]), this.marker.angle = c.angle, this.marker.scale.setTo(c.scale[0], c.scale[1]), G.changeTexture(this.marker, c.frame), this.marker.updateTransform(), d.renderXY(this.marker, a, b)
        }, G.MapTutHand = function(a) {
            G.Image.call(this, 0, 0, "tut_hand", 0);
            var b = G.saveState.getLastPassedLevelNr();
            this.map = a, G.json.levels[b] && (this.levelPos = {
                x: G.json.levels[b].mapX,
                y: G.json.levels[b].mapY
            }), b === G.saveState.getFirstClosedGateLvLIndex() && (this.levelPos.y += 35), this.closestBubble = G.json.settings.bubbleGifts.find(function(a) {
                return !G.saveState.isBubbleGiftUsed(a.levelNumber) && a.levelNumber - 1 <= b && Math.abs(b - a.levelNumber) < 2
            }), this.closestBubble && (this.bubblePos = {
                x: G.json.levels[this.closestBubble.levelNumber - 1].mapX + 20,
                y: G.json.levels[this.closestBubble.levelNumber - 1].mapY - 90
            }, this.bubbleLvlNr = this.closestBubble.levelNumber), this.closestBubble ? (this.position.setTo(this.bubblePos.x, this.bubblePos.y), G.sb("onBubbleGiftOpened").add(this.onBubbleGiftOpened, this), this.showingBubble = !0) : this.levelPos ? this.position.setTo(this.levelPos.x, this.levelPos.y) : this.visible = !1, game.add.tween(this.anchor).to({
                x: -.1,
                y: -.1
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), game.add.existing(this)
        }, G.MapTutHand.prototype = Object.create(G.Image.prototype), G.MapTutHand.prototype.onBubbleGiftOpened = function(a) {
            this.showingBubble && this.bubbleLvlNr === a && (this.levelPos ? (this.showingBubble = !1, game.add.tween(this).to({
                x: this.levelPos.x,
                y: this.levelPos.y
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0)) : game.add.tween(this).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0))
        }, G.MultiLineText = function(a, b, c, d, e, f, g, h, i, j) {
            if (a = G.l(a), b = G.l(b), e = G.l(e), f = G.l(f), g = G.l(g), Phaser.BitmapText.call(this, game, a, b, c, "", e), this.splitText(d, f), this.align = h || "center", g)
                for (; this.height > g;) this.fontSize -= 2, this.splitText(d, f), this.updateText();
            this.hAnchor = "number" == typeof i ? i : .5, this.vAnchor = "number" == typeof j ? j : 0, this.cacheAsBitmap = !0, this._cachedSprite.anchor.setTo(this.hAnchor, this.vAnchor)
        }, G.MultiLineText.prototype = Object.create(Phaser.BitmapText.prototype), G.MultiLineText.prototype.splitText = function(a, b) {
            for (var c = a, d = [], e = 0, f = 0; 0 < c.length;)
                if (e = f, this.setText(-1 == (f = c.indexOf(" ", f + 1)) ? c : c.substring(0, f)), this.updateText(), this.width > b) {
                    if (0 == e && -1 == f) {
                        d.push(c), c = "", f = 0;
                        continue
                    }
                    if (0 == e) {
                        d.push(c.substring(0, f)), c = c.substring(f + 1), f = 0;
                        continue
                    }
                    d.push(c.substring(0, e)), c = c.substring(e + 1), f = 0
                } else -1 == f && (d.push(c), c = "");
            this.setText(d.join("\n"))
        }, G.MultiLineText.prototype.popUpAnimation = function() {
            this.cacheAsBitmap = !1;
            for (var a = this.children.length, b = [], c = 0; c < a; c++) b[c] = c;
            b = Phaser.ArrayUtils.shuffle(b), delay_index = 0, this.activeTweens = 0, this.children.forEach(function(a) {
                0 == a.anchor.x && (a.x = a.x + .5 * a.width, a.y = a.y + a.height, a.anchor.setTo(.5, 1));
                var c = a.scale.x;
                a.scale.setTo(0, 0), this.activeTweens++;
                var d = game.add.tween(a.scale).to({
                    x: 1.5 * c,
                    y: 1.5 * c
                }, 200, Phaser.Easing.Quadratic.In, !1, 25 * b[delay_index]).to({
                    x: c,
                    y: c
                }, 200, Phaser.Easing.Sinusoidal.In);
                d.onComplete.add(function() {
                    this.activeTweens--, 0 == this.activeTweens && this.alive && (this.cacheAsBitmap = !0)
                }, this), d.start(), delay_index++
            }, this)
        }, G.NoMoreAds = function() {
            Phaser.Image.call(this, game), this.bg = G.makeImage(0, 0, "text_shade_bg", .5, this), this.txt = new G.Text(0, 0, G.txt("You watched all videos for today. Come back tomorrow!"), {
                font: "ComicSansBold",
                fill: "white",
                fontSize: "50px",
                lineSpacing: -25
            }, .5, 600, 300, !0, "center"), this.addChild(this.txt), this.bg.width = this.txt.width + G.l(100), this.bg.height = this.txt.height + G.l(100), this.fixedToCamera = !0, this.cameraOffset.x = .5 * game.width, this.cameraOffset.y = .5 * game.height, game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 2500).onComplete.add(function() {
                this.destroy()
            }, this), game.add.tween(this).from({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0), game.add.existing(this)
        }, G.NoMoreAds.prototype = Object.create(Phaser.Image.prototype), G.NoMoreAds.prototype.update = function() {
            this.cameraOffset.x = .5 * game.width, this.cameraOffset.y = .5 * game.height
        }, G.OneLineText = function(a, b, c, d, e, f, g, h) {
            var i = {
                font: "ComicSansBold",
                fontSize: e + "px"
            };
            "font-white" === c && (i.fill = "white"), "font-green" === c && (i.fill = "#f7ffdb", i.stroke = "#005700", i.strokeThickness = 5), "font-beige" === c && (i.fill = "#FDFBE4"), "font-beige-header" === c && (i.fill = "#ece9e5", i.stroke = "#85511f", i.strokeThickness = 5), "font-white-stroke" === c && (i.fill = "white", i.fontSize = 40, i.stroke = "#85511f", i.strokeThickness = 5), "font-brown" === c && (i.fill = "#ece9e5", i.stroke = "#A0692E", i.strokeThickness = 7), "font-red" === c && (i.fill = "#ffe9d0", i.stroke = "#961400", i.strokeThickness = 7), "font-blue-out" === c && (i.fill = "#ffffe8", i.stroke = "#004455", i.strokeThickness = 10), "font-blue-out-small" === c && (i.fill = "#ffffe8", i.stroke = "#004455", i.strokeThickness = 5), "font-gray" === c && (i.fill = "white", i.stroke = "#393939", i.strokeThickness = 7), G.Text.call(this, a, b, d, i, [g, h], f)
        }, G.OneLineText.prototype = Object.create(G.Text.prototype), G.OneLineText.prototype.constructor = G.OneLineText, G.OneLineText.prototype.popUpAnimation = function() {}, G.OneLineText.prototype.scaleOut = function() {}, G.OneLineCounter = function(a, b, c, d, e, f, g, h, i, j) {
            G.OneLineText.call(this, a, b, c, "", e, f, g, h), this.amount = d, this.amountDisplayed = d, this.amountMaxInterval = 5, this.amountMaxNegInterval = -5, this.absoluteDisplay = !1, this.fixedToDecimal = 0, this.stepCurrent = 0, this.step = 0, this.preText = i || "", this.postText = j || "", this.setText(this.preText + d + this.postText)
        }, G.OneLineCounter.prototype = Object.create(G.OneLineText.prototype), G.OneLineCounter.prototype.update = function() {
            if (this.lerp) this.lerpUpdate();
            else if (this.amountDisplayed != this.amount && this.stepCurrent-- <= 0 && (this.stepCurrent = this.step, this.amountDisplayed != this.amount)) {
                var a = this.amount - this.amountDisplayed;
                this.amountDisplayed += game.math.clamp(a, this.amountMaxNegInterval, this.amountMaxInterval);
                var b = this.amountDisplayed;
                this.absoluteDisplay && (b = Math.abs(b)), 0 != this.fixedTo && (b = b.toFixed(this.fixedToDecimal)), this.setText(this.preText + b + this.postText)
            }
        }, G.OneLineCounter.prototype.changeAmount = function(a) {
            this.amount = a
        }, G.OneLineCounter.prototype.increaseAmount = function(a) {
            this.amount += a
        }, G.OneLineCounter.prototype.changeIntervals = function(a, b) {
            void 0 === b ? (this.amountMaxInterval = a, this.amountMaxNegInterval = -a) : (this.amountMaxInterval = a, this.amountMaxNegInterval = b)
        }, G.OneLineCounter.prototype.lerpUpdate = function() {
            this.amountDisplayed != this.amount && this.stepCurrent-- <= 0 && (this.stepCurrent = this.step, this.amountDisplayed = Math.round(G.lerp(this.amountDisplayed, this.amount, .5, .6)), this.setText(this.amountDisplayed.toString()))
        }, G.PlayFabLogger = function() {
            G.BuildEnvironment.PLAYFAB_ID && (PlayFab.settings.titleId = G.BuildEnvironment.PLAYFAB_ID, this.loginToPlayFabWithFBID())
        }, G.PlayFabLogger.prototype.loginToPlayFabWithFBID = function() {
            return -1 !== window.location.href.indexOf("player2") && -1 !== window.location.href.indexOf("sandbox") && sgSettings.config.user.userId++, this.userAvatarUrl = sgSettings.config.user.avatar, this.userDisplayName = sgSettings.config.user.name, new Promise(function(a, b) {
                console.log("LOGIN WITH PLAYFAB"), PlayFabClientSDK.LoginWithCustomID({
                    TitleId: PlayFab.settings.titleId,
                    CustomId: sgSettings.config.user.userId,
                    CreateAccount: !0,
                    InfoRequestParameters: {
                        GetPlayerProfile: !0
                    }
                }, function(c, d) {
                    d ? (console.log(d), b()) : (G.playFabLoginResult = c, G.playFabLoginResult.data.InfoResultPayload.PlayerProfile ? G.playFabLoginResult.data.InfoResultPayload.PlayerProfile.DisplayName !== sgSettings.config.user.userId && PlayFabClientSDK.UpdateUserTitleDisplayName({
                        DisplayName: sgSettings.config.user.userId
                    }, function() {
                        G.playFabLoginResult.data.NewlyCreated && this.sendFBFriends()
                    }.bind(this)) : PlayFabClientSDK.UpdateUserTitleDisplayName({
                        DisplayName: sgSettings.config.user.userId
                    }, function() {
                        this.sendFBFriends()
                    }.bind(this)), a())
                }.bind(this))
            }.bind(this))
        }, G.PlayFabLogger.prototype.sendFBFriends = function() {
            sdkHandler.trigger("social.getFriends", {
                callback: function(a, b) {
                    console.log(b), a ? console.log(a) : !b || b.length <= 0 || this.preparePlayFabIdsOfFriends(b, function(a) {
                        var b = {
                            FunctionName: "storeFriendsForBroadcast",
                            FunctionParameter: {
                                connectedPlayers: a,
                                userFBId: sgSettings.config.user.userId,
                                userFBName: sgSettings.config.user.name,
                                userFBAvatar: sgSettings.config.user.avatar
                            },
                            GeneratePlayStreamEvent: !0
                        };
                        console.log("call storeFriendsForBroadcast"), PlayFabClientSDK.ExecuteCloudScript(b, function(a) {
                            console.log(a)
                        })
                    })
                }
            }, this)
        }, G.PlayFabLogger.prototype.preparePlayFabIdsOfFriends = function(a, b) {
            console.log("preparePlayFabIdsOfFriends");
            for (var c = a.length, d = [], e = 0; e < a.length; e++) try {
                PlayFabClientSDK.GetAccountInfo({
                    TitleDisplayName: a[e].userId
                }, function(a, e) {
                    if (a && !e) {
                        var f = a.data.AccountInfo.PlayFabId;
                        d.push(f)
                    }
                    0 === --c && b(d)
                })
            } catch (a) {}
        }, G.PlayFabLogger.prototype._broadcastNewUserBotMessage = function() {
            sdkHandler.trigger("social.getFriends", {
                callback: function(a, b) {
                    if (a) console.log(a);
                    else if (connectedPlayers = b.map(function(a) {
                            return {
                                id: a.userId,
                                name: a.name,
                                photo: a.avatar
                            }
                        }), connectedPlayers && !(connectedPlayers.length <= 0)) {
                        var c = {
                            FunctionName: "broadcastNewUserBotMessage",
                            FunctionParameter: {
                                connectedPlayers: connectedPlayers,
                                sender: sgSettings.config.user.name,
                                senderId: sgSettings.config.user.userId
                            },
                            GeneratePlayStreamEvent: !0
                        };
                        PlayFabClientSDK.ExecuteCloudScript(c, function(a, b) {
                            return b ? console.error(b) : (console.log("Successfully notified players friends that he started playing the game"), void console.log(a))
                        })
                    }
                }
            }, this)
        }, G.PlayFabLogger.prototype.getGingerEvent = function() {
            console.log("GET GINGER EVENT"), PlayFabClientSDK.ExecuteCloudScript({
                FunctionName: "getGingerEvent"
            }, function(a) {
                this.gingerEvent = a.data.FunctionResult, console.log(a)
            }.bind(this))
        }, G.PlayFabLogger.prototype.getGingerGroup = function() {
            PlayFabClientSDK.ExecuteCloudScript({
                FunctionName: "getGingerGroupData",
                FunctionParameter: {
                    contextId: "test-group-id"
                }
            }, function(a) {
                this.gingerGroup = a.data.FunctionResult, this.processGingerGroupUpdate()
            }.bind(this))
        }, G.PlayFabLogger.prototype.updateGingerAmount = function(a) {
            PlayFabClientSDK.ExecuteCloudScript({
                FunctionName: "updateGingerAmount",
                FunctionParameter: {
                    gingerAmount: a,
                    groupId: this.gingerGroup.id,
                    playerId: sgSettings.config.user.userId
                }
            }, function(a) {
                this.gingerGroup.data = a.data.FunctionResult, this.processGingerGroupUpdate()
            }.bind(this))
        }, G.PlayFabLogger.prototype.processGingerGroupUpdate = function() {
            var b = this.gingerGroup.data[sgSettings.config.user.userId];
            G.saveState.data.gingerAmount = b ? parseInt(b.Value) : 0
        }, G.PlayFabLogger.prototype.getTitleData = function() {
            return new Promise(function(a, b) {
                PlayFabClientSDK.GetTitleData(null, function(c, d) {
                    d ? b(d) : c && (this.rawTitleData = c.data.Data, a(this.rawTitleDataToParsed(this.rawTitleData)))
                }.bind(this))
            }.bind(this))
        }, G.PlayFabLogger.prototype.rawTitleDataToParsed = function(a) {
            var b = {};
            return Object.keys(a).forEach(function(c) {
                b[c] = JSON.parse(a[c])
            }), b
        }, G.PopOutMoneyLayer = function() {
            Phaser.Group.call(this, game), G.sb("newPopOutMoney").add(this.onPopOutMoney, this), this.deadArray = []
        }, G.PopOutMoneyLayer.prototype = Object.create(Phaser.Group.prototype), G.PopOutMoneyLayer.prototype.getFreePart = function() {
            var a;
            return 0 < this.deadArray.length ? a = this.deadArray.pop() : (a = new G.UI_PopOutMoney).events.onKilled.add(this.onElemKilled, this), this.add(a), a
        }, G.PopOutMoneyLayer.prototype.onElemKilled = function(a) {
            this === a.parent && (this.deadArray.push(a), this.removeChild(a))
        }, G.PopOutMoneyLayer.prototype.onPopOutMoney = function(a, b) {
            this.getFreePart().init(a, b)
        }, G.StartBoosterBubble = function(a, b, c, d, e) {
            Phaser.Image.call(this, game, 0, 0), this.anchor.setTo(.5), this.state = game.state.getCurrentState(), this.board = this.state.board, this.x = this.board.x + this.board.width * a[0], this.y = this.board.y + this.board.height * a[1], this.tweenFloating = game.add.tween(this).to({
                y: this.y + G.l(30)
            }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), game.add.tween(this.scale).from({
                x: 0,
                y: 0
            }, 1e3, Phaser.Easing.Elastic.Out, !0), G.changeTexture(this, b), this.target = c || null, this.onPop = d || function() {}, this.onPopContext = e || this, this.goingToTarget = !1
        }, G.StartBoosterBubble.prototype = Object.create(Phaser.Image.prototype), G.StartBoosterBubble.prototype.update = function() {}, G.StartBoosterBubble.prototype.goToTarget = function(a) {
            null == this.target ? game.time.events.add(a + 500, function() {
                this.tweenFloating.stop(), this.pop()
            }, this) : game.time.events.add(a, function() {
                this.tweenFloating.stop(), game.add.tween(this).to({
                    x: game.world.bounds.x + this.target.worldPosition.x,
                    y: game.world.bounds.y + this.target.worldPosition.y
                }, 300, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(this.pop, this), game.add.tween(this.scale).to({
                    x: .6,
                    y: .6
                }, 300, Phaser.Easing.Sinusoidal.In, !0)
            }, this)
        }, G.StartBoosterBubble.prototype.pop = function() {
            G.sfx["match_" + game.rnd.between(1, 5)].play(), this.onPop.call(this.onPopContext), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), this.destroy()
        }, G.StartBoosterConfig = function() {
            this.data = []
        }, G.StartBoosterConfig.prototype.select = function(a, b) {
            this.data[a] || (this.data[a] = []), this.data[a][b] = !0
        }, G.StartBoosterConfig.prototype.deselect = function(a, b) {
            this.data[a] || (this.data[a] = []), this.data[a][b] = !1
        }, G.StartBoosterConfig.prototype.isSelected = function(a, b) {
            return !!this.data[a] && this.data[a][b]
        }, G.StartBoosterConfig.prototype.getConfigForLevel = function(a) {
            return this.data[a] || []
        }, G.Text = function(a, b, c, d, e, f, g, h, i) {
            for (d = G.Text.getStyle(d), this.userMaxWidth = f || 1 / 0, this.userMaxHeight = g || 1 / 0, h && (d.wordWrap = !0, d.wordWrapWidth = f, d.align = i || "left"), Phaser.Text.call(this, game, a, b, c, d), d.lineSpacing && (this.lineSpacing = d.lineSpacing), d.shadow && (this.setShadow.apply(this, d.shadow), this.padding.setTo(d.shadow[0], d.shadow[1])), e && ("number" == typeof e ? this.anchor.setTo(e) : this.anchor.setTo(e[0], e[1]));
                (this.width > this.userMaxWidth || this.height > this.userMaxHeight) && (this.fontSize -= 2, !(this.fontSize < 10)););
        }, G.Text.prototype = Object.create(Phaser.Text.prototype), G.Text.styles = {}, G.Text.addStyle = function(a, b) {
            G.Text.styles[a] = b
        }, G.Text.getStyle = function(a) {
            var b;
            if ("object" != typeof a) b = JSON.parse(JSON.stringify(G.Text.styles[a]));
            else if (a.style || a.fontStyle) {
                a.style = a.fontStyle || a.style;
                var c = JSON.parse(JSON.stringify(G.Text.styles[a.style]));
                if (a.scaleStroke && a.fontSize && c.fontSize && c.strokeThickness) {
                    var d = c.strokeThickness / parseInt(c.fontSize);
                    a.strokeThickness = Math.ceil(parseInt(a.fontSize) * d)
                }
                b = Object.assign(c, a)
            } else b = a;
            return "vi" === G.lang && "Lobster" === b.font && (delete b.font, b.fontWeight = "bold"), b
        }, G.Text.prototype.setText = function(a) {
            Phaser.Text.prototype.setText.call(this, a), this.scale.setTo(1), this.width = Math.min(this.width, this.userMaxWidth), this.height = Math.min(this.height, this.userMaxHeight)
        }, G.Text.prototype.setStyle = function(a, b) {
            a = G.Text.getStyle(a), Phaser.Text.prototype.setStyle.call(this, a, b)
        }, G.TextCounter = function(a, b, c, d, e, f, g) {
            this.amount = c, this.amountDisplayed = c, G.Text.call(this, a, b, null === c ? "..." : c.toString(), d, e, f), g = g || {
                lerpValue: .5
            }, this.lerp = !0, this.lerpValue = g.lerpValue, this.stepCurrent = 0, this.step = 0
        }, G.TextCounter.prototype = Object.create(G.Text.prototype), G.TextCounter.prototype.setAmount = function(a, b) {
            this.amount = a, b && (this.amountDisplayed = a, this.setText(this.amountDisplayed.toString()))
        }, G.TextCounter.prototype.changeAmount = function(a, b) {
            this.amount += a, b && (this.amountDisplayed = this.amount, this.setText(this.amountDisplayed.toString()))
        }, G.TextCounter.prototype.increaseAmount = function(a) {
            this.changeAmount(a)
        }, G.TextCounter.prototype.update = function() {
            this.amountDisplayed != this.amount && this.stepCurrent-- <= 0 && (this.stepCurrent = this.step, this.lerp && this.lerpUpdate())
        }, G.TextCounter.prototype.lerpUpdate = function() {
            this.amountDisplayed = G.lerp(this.amountDisplayed, this.amount, this.lerpValue, .2), this.setText(Math.round(this.amountDisplayed).toString())
        }, "function" != typeof Object.assign && Object.defineProperty(Object, "assign", {
            value: function(a) {
                "use strict";
                if (null == a) throw new TypeError("Cannot convert undefined or null to object");
                for (var c = Object(a), d = 1; d < arguments.length; d++) {
                    var e = arguments[d];
                    if (null != e)
                        for (var f in e) Object.prototype.hasOwnProperty.call(e, f) && (c[f] = e[f])
                }
                return c
            },
            writable: !0,
            configurable: !0
        }), G.TextTimer = function(a, b, c, d, e, f, g) {
            G.Text.call(this, a, b, "???", d, e, f), this.secLeft = 0, this.active = !1, this.timerFormat = g || "hms", this.dots = !0, this.timerBinding = G.sb("onWallClockTimeUpdate").add(this.updateTimer, this), this.events.onDestroy.add(function() {
                this.timerBinding.detach()
            }, this), c && this.setDate(c)
        }, G.TextTimer.prototype = Object.create(G.Text.prototype), G.TextTimer.prototype.sfx = null, G.TextTimer.prototype.updateTimer = function() {
            this.active && (this.sfx && this.sfx.play(), this.secLeft = Math.max(0, this.secLeft - 1), this.updateTimerText(this.secLeft, this.dots), this.dots = !this.dots)
        }, G.TextTimer.prototype.setSecLeft = function(a) {
            this.secLeft = Math.max(0, a), this.updateTimerText(this.secLeft, !0)
        }, G.TextTimer.prototype.updateTimerText = function() {
            var c = G.changeSecToDHMS(this.secLeft),
                d = []; - 1 < this.timerFormat.indexOf("d") && d.push(c[0]), -1 < this.timerFormat.indexOf("h") && d.push(c[1]), -1 < this.timerFormat.indexOf("m") && d.push(c[2]), -1 < this.timerFormat.indexOf("s") && d.push(c[3]), this.setText(d.join(":"))
        }, G.TextTimer.prototype.start = function(a) {
            a && this.setSecLeft(a), this.active = !0
        }, G.TextTimer.prototype.setDate = function(a) {
            var b = new Date(a).getTime(),
                c = Date.now(),
                d = Math.ceil((b - c) / 1e3);
            this.setSecLeft(d), this.active = !0
        }, G.Timer = function(a, b, c, d, e, f, g, h) {
            G.OneLineText.call(this, a, b, c, h ? G.changeSecToTimerFormat(h) : "???", d, e, f, g), this.secLeft = h || 0, this.dhms = !1, this.active = !1, this.timerBinding = G.sb("onWallClockTimeUpdate").add(this.updateTimer, this), this.events.onDestroy.add(function() {
                this.timerBinding.detach()
            }, this)
        }, G.Timer.prototype = Object.create(G.OneLineText.prototype), G.Timer.prototype.updateTimer = function() {
            this.active && (this.secLeft = Math.max(0, this.secLeft - 1), this.setText(G.changeSecToTimerFormat(this.secLeft, this.dhms)))
        }, G.Timer.prototype.setSecLeft = function(a) {
            this.secLeft = a, this.setText(G.changeSecToTimerFormat(this.secLeft, this.dhms))
        }, G.Timer.prototype.start = function() {
            this.setText(G.changeSecToTimerFormat(this.secLeft, this.dhms)), this.active = !0
        }, G.TitleScreenGemsThrower = function() {
            Phaser.Group.call(this, game), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize(), this.chanceForShoot = .1, this.horizontal = !1;
            for (var a = 0; a < 20; a++) this.addChild(new G.TitleScreenGem)
        }, G.TitleScreenGemsThrower.prototype = Object.create(Phaser.Group.prototype), G.TitleScreenGemsThrower.prototype.onScreenResize = function() {
            this.x = game.world.bounds.x, this.y = 0
        }, G.TitleScreenGemsThrower.prototype.throwGem = function() {
            var a, b, c, d, e = this.getFreeGem();
            null != e && (d = this.horizontal ? (a = Math.random() < .5 ? game.world.bounds.x - G.l(50) : -game.world.bounds.x + game.width + G.l(50), b = .5 * game.height + .5 * game.height * Math.random(), c = G.l(3 + 6 * Math.random()) * Math.sign(a) * -1, G.l(-2 * Math.random() - 2)) : (a = Math.random() * game.width, b = game.height + G.l(50), c = G.l(1 + -2 * Math.random()), G.l(-3 * Math.random() - 1)), e.init(a, b, c, d))
        }, G.TitleScreenGemsThrower.prototype.getFreeGem = function() {
            return this.getFirstDead()
        }, G.TitleScreenGemsThrower.prototype.update = function() {
            Math.random() < this.chanceForShoot && this.throwGem();
            for (var a = 0; a < this.children.length; a++) this.children[a].update()
        }, G.TitleScreenGem = function() {
            Phaser.Image.call(this, game, 0, 0), this.anchor.setTo(.5), this.grav = G.lnf(.02), this.kill()
        }, G.TitleScreenGem.prototype = Object.create(Phaser.Image.prototype), G.TitleScreenGem.prototype.init = function(a, b, c, d) {
            G.changeTexture(this, "candy_" + game.rnd.between(1, 6)), this.x = a, this.y = b, this.velX = c, this.velX *= .99, this.velY = d, this.angleSpeed = 3 * Math.random() - 1.5, this.revive()
        }, G.TitleScreenGem.prototype.update = function() {
            this.alive && (this.x += this.velX, this.angle += this.angleSpeed, this.y += this.velY, this.velY += this.grav, this.y > game.height + 100 && this.kill())
        }, G.TrackData = function(a, b) {
            this.data = {
                boosterBought: [0, 0, 0, 0],
                boosterUsed: [0, 0, 0, 0],
                startBoosterUsed: [0, 0, 0, 0],
                lvlNr: a + 1,
                extraMovesBought: 0,
                continues: 0,
                stars: 0,
                passed: !1,
                movesLeft: b.moves
            }, G.sb("onBoosterBought").add(function(a) {
                this.data.boosterBought[a - 1]++
            }, this), G.sb("onBoosterUsed").add(function(a) {
                this.data.boosterUsed[a - 1]++
            }, this), G.sb("onStartBoosterUsed").add(function(a) {
                this.data.startBoosterUsed[a - 5] = 1
            }, this), G.sb("onExtraMovesUsed").add(function() {
                this.data.extraMovesBought++
            }, this), G.sb("onOutOfMovesWatch").add(function() {
                this.data.continues++
            }, this), G.sb("onOutOfMovesBuy").add(function() {
                this.data.continues++
            }, this), G.sb("madeMove").add(function() {
                this.data.passed || this.data.movesLeft--
            }, this), G.sb("onGoalAchieved").add(function() {
                this.data.passed = !0
            }, this), G.sb("onLevelFinished").add(function(a, b) {
                this.data.stars = b
            }, this), game.state.onStateChange.addOnce(this.send, this)
        }, G.TrackData.prototype.send = function() {}, G.UITargetParticles = function(a, b) {
            G.PoolGroup.call(this, G.UITargetParticle), this.minNrOfPart = a || 3, this.maxNrOfPart = b || 100
        }, G.UITargetParticles.prototype = Object.create(G.PoolGroup.prototype), G.UITargetParticles.prototype.createDividedBatch = function(a, b, c, d, e, f, g) {
            var h = new G.UITargetParticles.BatchObj;
            (g = g || 25) < e / f && (f = Math.ceil(e / g));
            for (var i = Math.floor(e / f) + Math.sign(e % f), j = 0; j < i; j++) {
                var k = this.init(a, b, c, d, Math.min(f, e));
                e -= f, h.add(k)
            }
            return h
        }, G.UITargetParticles.prototype.createBatch = function(a, b, c, d, e, f) {
            for (var g = new G.UITargetParticles.BatchObj, h = 0; h < f; h++) {
                var i = this.init(a, b, c, d, e);
                g.add(i)
            }
            return g
        }, G.UITargetParticles.prototype.createCoinBatch = function(a, b, c, d) {
            game.state.getCurrentState();
            var e = this.createDividedBatch(a, b, "coin_1", c, d, 5);
            e.addOnPartStart(function() {
                this.scale.setTo(.75), this.vel.setTo(game.rnd.realInRange(-12, 12), game.rnd.realInRange(-12, 12))
            }), e.addOnPartFinish(function() {
                G.sfx.pop.play(), G.saveState.changeCoins(this.carriedValue, !0)
            }), e.start(), e.onFinish.add(function() {
                G.saveState.save()
            })
        }, G.UITargetParticles.BatchObj = function() {
            this.parts = [], this.nrOfParts = 0, this.nrOfFinished = 0, this.onFinish = new Phaser.Signal
        }, G.UITargetParticles.BatchObj.prototype.add = function(a) {
            this.parts.push(a), a.onFinish.addOnce(this.onPartFinish, this), this.nrOfParts++
        }, G.UITargetParticles.BatchObj.prototype.onPartFinish = function() {
            this.nrOfFinished++, this.nrOfFinished == this.nrOfParts && this.onFinish.dispatch()
        }, G.UITargetParticles.BatchObj.prototype.addOnPartStart = function(a, b) {
            this.parts.forEach(function(c) {
                c.onStart.addOnce(a, b || c, 1)
            })
        }, G.UITargetParticles.BatchObj.prototype.addOnPartFinish = function(a, b) {
            this.parts.forEach(function(c) {
                c.onFinish.addOnce(a, b || c, 1)
            })
        }, G.UITargetParticles.BatchObj.prototype.start = function(a) {
            var b = 0;
            this.parts.forEach(function(c) {
                c.start(b), b += a || 0
            })
        }, G.UITargetParticle = function() {
            G.Image.call(this, 0, 0, null, .5), this.onStart = new Phaser.Signal, this.onFinish = new Phaser.Signal, this.speed = 0, this.speedMax = 30, this.speedDelta = .75, this.vel = new Phaser.Point(0, 0), this.velInit = new Phaser.Point(0, 0), this.kill()
        }, G.UITargetParticle.prototype = Object.create(G.Image.prototype), G.UITargetParticle.prototype.init = function(a, b, c, d, e) {
            this.position.setTo(a, b), this.changeTexture(c), this.onStart.removeAll(), this.onFinish.removeAll(), this.carriedValue = e || 1, this.targetObj = d, this.stopTweens(this), this.scale.setTo(1), this.alpha = 1, this.speed = 0, this.speedMax = 30, this.speedDelta = .75, this.vel.setTo(0, 0)
        }, G.UITargetParticle.prototype.start = function(a) {
            a ? game.time.events.add(a, this.start, this) : (this.revive(), this.worldPosition.x = 9999, this.worldPosition.y = 9999, this.onStart.dispatch(this, this.carriedValue))
        }, G.UITargetParticle.prototype.update = function() {
            if (this.alive) {
                this.position.add(this.vel.x, this.vel.y), this.vel.x *= .95, this.vel.y *= .95, this.speed += this.speedDelta, this.speed = Math.min(this.speed, this.speedMax);
                var a = Phaser.Point.distance(this.worldPosition, this.targetObj.worldPosition),
                    b = Phaser.Point.angle(this.targetObj.worldPosition, this.worldPosition);
                this.position.add(G.lengthDirX(b, Math.min(a, this.speed), !0), G.lengthDirY(b, Math.min(a, this.speed), !0)), a < this.speedMax && (this.onFinish.dispatch(this, this.carriedValue), this.kill())
            }
        }, G.UI_BoosterButton = function(a, b, c) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.orgY = this.y, this.state = game.state.getCurrentState(), this.boosterNr = c, this.overlay = this.state.overlay, this.selected = !1, this.highlighted = !1, this.hl = G.makeImage(0, 0, "popup_lighht", .5, this), this.hl.blendMode = 1, this.hl.alpha = 0, this.hl.angle2 = 0, this.openLock = !1, G.sb("onTutorialFinish").add(function() {
                this.hideSuggestion()
            }, this), this.btn = new G.Button(0, 0, "ui_booster_" + c, function() {
                return this.selected && !G.tutorialOpened ? G.sb("onBoosterDeselect").dispatch(this.boosterNr) : void(0 < this.state.board.actionManager.actionList.length || (0 < G.saveState.getBoosterAmount(this.boosterNr) || G.saveState.isEnoughToBuyBooster(this.boosterNr) ? G.sb("onBoosterSelect").dispatch(this.boosterNr) : game.incentivised ? G.sb("pushWindow").dispatch("moreMoney") : (G.stopTweens(this.priceLabel), this.priceLabel.scale.setTo(1), game.add.tween(this.priceLabel.scale).to({
                    x: .6,
                    y: 1.4
                }, 150, Phaser.Easing.Bounce.InOut, !0, 0, 2, !0))))
            }, this), this.add(this.btn), this.btn.addTerm(function() {
                return 0 == this.state.board.actionManager.actionList.length || this.selected
            }, this), this.boosterActiveOffset = G.l(20), this.tweenObj = {
                angle: -15,
                alpha: 1
            }, game.add.tween(this.tweenObj).to({
                angle: 15
            }, 2e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), game.add.tween(this.tweenObj).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.angleMulti = 0, this.priceLabel = new G.LabelGroupT(G.json.settings["priceOfBooster" + c] + "@currency@", 0, 35, {
                font: "ComicSansBold",
                fontSize: "35px",
                fill: "#fdfbe4",
                stroke: "#73461c",
                strokeThickness: 7
            }, .5, 85), this.add(this.priceLabel), this.plus = G.makeImage(40, 30, "booster_plus", .5, this), this.amount = new G.Text(40, 33, G.saveState.getBoosterAmount(c).toString(), {
                style: "font-beige-standard",
                fontSize: "25px"
            }, .5, 100), this.add(this.amount), this.hand = G.makeImage(0, 0, "tut_hand", 0, this), this.hand.alpha = 0, this.alphaTween = !1, this.refreshBoosterAmount(), G.sb("refreshBoosterAmount").add(function(a) {
                a == this.boosterNr && this.refreshBoosterAmount()
            }, this), G.sb("onBoosterSelect").add(function(a) {
                a == this.boosterNr ? this.select() : this.squeeze()
            }, this), G.sb("onBoosterUsed").add(function(a) {
                a == this.boosterNr ? this.deselect() : this.unsqueeze()
            }, this), G.sb("onBoosterDeselect").add(function(a) {
                a == this.boosterNr ? this.deselect() : this.unsqueeze()
            }, this)
        }, G.UI_BoosterButton.prototype = Object.create(Phaser.Group.prototype), G.UI_BoosterButton.prototype.refreshBoosterAmount = function() {
            0 == G.saveState.getBoosterAmount(this.boosterNr) ? (this.plus.visible = !1, this.amount.visible = !1, this.priceLabel.visible = !0) : (G.changeTexture(this.plus, "booster_ammount"), this.plus.visible = !0, this.amount.visible = !0, this.priceLabel.visible = !1, this.amount.setText(G.saveState.getBoosterAmount(this.boosterNr).toString()))
        }, G.UI_BoosterButton.prototype.update = function() {
            this.angle = this.angleMulti * this.tweenObj.angle, this.y = this.orgY - this.angleMulti * this.boosterActiveOffset, this.x = this.orgX, this.hl.angle2++, this.hl.angle = -this.angle + this.hl.angle2, this.hl.alpha = G.lerp(this.hl.alpha, this.selected ? .5 : 0, .1)
        }, G.UI_BoosterButton.prototype.select = function() {
            G.sb("startOverlay").dispatch([
                ["clearBoard"],
                ["moveToAboveGroup", this, "boosterGroup"]
            ]), this.selected = !0, game.add.tween(this).to({
                angleMulti: 1
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0)
        }, G.UI_BoosterButton.prototype.deselect = function() {
            G.sb("closeOverlay").dispatch(), this.selected = !1, game.add.tween(this).to({
                angleMulti: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0)
        }, G.UI_BoosterButton.prototype.squeeze = function() {
            game.add.tween(this.scale).to({
                x: .8,
                y: .8
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.UI_BoosterButton.prototype.unsqueeze = function() {
            1 != this.scale.x && game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.UI_BoosterButton.prototype.lock = function() {
            this.ignoreChildInput = !0
        }, G.UI_BoosterButton.prototype.unlock = function() {
            this.ignoreChildInput = !1
        }, G.UI_BoosterButton.prototype.hideSuggestion = function() {
            0 != this.hand.alpha && (this.alphaTween && this.alphaTween.stop(), G.stopTweens(this.hand), this.alphaTween = game.add.tween(this.hand).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0))
        }, G.UI_BoosterButton.prototype.showSuggestion = function() {
            this.openLock || (this.alphaTween && this.alphaTween.stop(), this.alphaTween = game.add.tween(this.hand).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.hand.position.setTo(0, 0), game.add.tween(this.hand).to({
                x: G.l(20),
                y: G.l(20)
            }, 800, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.openLock = !0, G.tutorialOpened || game.time.events.add(5e3, function() {
                this.hideSuggestion()
            }, this), game.time.events.add(15e3, function() {
                this.openLock = !1
            }, this))
        }, G.UI_BoosterLabel = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.ico = G.makeImage(0, 0, null, .5, this), this.txt = new G.Text(0, 0, " ", {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "white",
                lineSpacing: -10
            }, .5, 400, 200, !0, "center"), this.txt.anchor.setTo(.5), this.txt.setShadow(0, 10, "rgba(0,0,0,1)", 10), this.add(this.txt), this.topBar = this.state.topBar, this.textLookup = {
                1: G.txt("Use the swap booster to change the place of two cookies!") + " ",
                2: G.txt("Use the star wand to crush one cookie!") + " ",
                3: G.txt("Use the horizontal pin to clear the whole row!") + " ",
                4: G.txt("Use the vertical pin to clear the whole column!") + " "
            }, G.sb("onScreenResize").add(this.resize, this), this.resize(), G.sb("onBoosterSelect").add(this.init, this), G.sb("closeOverlay").add(this.hide, this)
        }, G.UI_BoosterLabel.prototype = Object.create(Phaser.Group.prototype), G.UI_BoosterLabel.prototype.init = function(a) {
            G.changeTexture(this.ico, "ui_booster_" + a), this.txt.setText(this.textLookup[a.toString()]), this.alpha = 0, G.stopTweens(this), game.add.tween(this).to({
                alpha: 1
            }, 500, Phaser.Easing.Sinusoidal.Out, !0), this.resize()
        }, G.UI_BoosterLabel.prototype.hide = function() {
            G.stopTweens(this), game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.UI_BoosterLabel.prototype.resize = function() {
            G.horizontal ? (this.position.setTo(-79, 194), this.txt.position.setTo(0, 60), this.txt.anchor.y = 0, this.txt.wordWrapWidth = G.l(200)) : (this.position.setTo(132, 70), this.txt.position.setTo(260, 0), this.txt.anchor.y = .5, this.txt.wordWrapWidth = G.l(350)), this.txt.setText(this.txt.text)
        }, G.UI_CoinCounter = function() {
            Phaser.Group.call(this, game), this.x = 100, this.y = 100, this.state = game.state.getCurrentState(), this.text = new G.TextCounter(0, 0, G.saveState.data.coins, {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "40px"
            }, [1, .5], 200), this.add(this.text), this.ico = G.makeImage(0, 0, "currency", [0, .5], this), this.alpha = 0, G.sb("onScreenResize").add(this.resize, this), this.resize(), G.sb("onBoosterSelect").add(this.init, this), G.sb("closeOverlay").add(this.hide, this), G.sb("onCoinsChange").add(this.text.setAmount, this.text)
        }, G.UI_CoinCounter.prototype = Object.create(Phaser.Group.prototype), G.UI_CoinCounter.prototype.resize = function() {
            G.horizontal ? (this.x = 0, this.y = G.l(700)) : (this.x = G.l(330), this.y = this.state.board.y - G.l(60), this.x += Math.floor(.5 * this.text.width))
        }, G.UI_CoinCounter.prototype.init = function(a) {
            G.saveState.getBoosterAmount(a) <= 0 && (this.alpha = 0, G.stopTweens(this), game.add.tween(this).to({
                alpha: 1
            }, 500, Phaser.Easing.Sinusoidal.Out, !0), this.resize())
        }, G.UI_CoinCounter.prototype.hide = function() {
            G.stopTweens(this), game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.UI_ComboIndicator = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.bg = G.makeImage(0, 0, "combo_bg", .5, this), this.coinGroup = this.add(game.add.group()), this.comboTxt = new G.OneLineCounter(0, 5, "font-score-4", 0, 50, 100, .5, .5, "x"), this.add(this.comboTxt), G.sb("onComboIncrease").add(this.increaseCombo, this), G.sb("onComboBreak").add(this.breakCombo, this), this.lvl = G.lvl, this.scale.setTo(0), this.breakTimerAmount = 30, this.breakTimer = -1, this.combo = 0, this.board = game.state.getCurrentState().board, this.x = this.board.x + .5 * this.board.width, this.y = this.board.y + .5 * this.board.height
        }, G.UI_ComboIndicator.prototype = Object.create(Phaser.Group.prototype), G.UI_ComboIndicator.prototype.update = function() {
            this.x = this.board.x + .9 * this.board.width, this.y = this.board.y + .02 * this.board.height, this.comboTxt.update(), 0 == this.breakTimer-- && (G.stopTweens(this), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.worldPosition.x + game.world.bounds.x, this.worldPosition.y, "whiteStarPart"), game.add.tween(this.scale).to({
                x: 0,
                y: 0
            }, 200, Phaser.Easing.Cubic.In, !0)), this.coinGroup.update()
        }, G.UI_ComboIndicator.prototype.increaseCombo = function(a) {
            G.lvl.combo < 2 || (3 == G.lvl.combo && (this.breakTimer = -1, G.stopTweens(this), game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 300, Phaser.Easing.Cubic.In, !0)), G.stopTweens(this.comboTxt), this.comboTxt.changeAmount(a), this.comboTxt.scale.setTo(1), game.add.tween(this.comboTxt.scale).to({
                x: 1.3,
                y: 1.3
            }, 200, Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0), this.combo = a)
        }, G.UI_ComboIndicator.prototype.breakCombo = function() {
            this.combo < 3 || (this.combo = 0, this.breakTimer = this.breakTimerAmount)
        }, G.UI_ComboIndicatorCoin = function(a, b) {
            Phaser.Image.call(this, game, a, b, null), this.anchor.setTo(.5), this.scale.setTo(.7), G.changeTexture(this, "coin_1"), this.angle = game.rnd.between(0, 360), this.velX = game.rnd.realInRange(G.l(-5), G.l(5)), this.velY = game.rnd.realInRange(G.l(-10), G.l(-5)), this.grav = G.lnf(.35), this.alphaDelay = 20
        }, G.UI_ComboIndicatorCoin.prototype = Object.create(Phaser.Image.prototype), G.UI_ComboIndicatorCoin.prototype.update = function() {
            this.x += this.velX, this.y += this.velY, this.velX *= .98, this.velY += this.grav, this.angle += .5 * this.velX, this.alphaDelay-- < 0 && (this.alpha -= .03, this.alpha <= 0 && this.destroy())
        }, G.UI_DailyChallengeIcon = function(a, b) {
            this.state = game.state.getCurrentState(), Phaser.Group.call(this, game), this.unlocked = G.saveState.getLastPassedLevelNr() >= G.json.settings.featuresUnlock.dailyChallenge, this.x = G.l(a), this.y = G.l(b), this.glow = G.makeImage(0, 0, "popup_lighht", .5, this), this.glow.alpha = .5, this.glow.scale.setTo(.5), this.glow.blendMode = 1, this.glow.update = function() {
                this.angle++
            }, this.icon = new G.Button(0, 0, "btn_daily_challenge", function() {
                this.available && G.sb("pushWindow").dispatch(["dailyChallenge", G.saveState.getDailyChallengeLevel()])
            }, this), this.add(this.icon), this.freeText = new G.Text(0, 65, G.txt("Daily Challenge"), {
                fill: "#fdfbe4",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#73461c",
                strokeThickness: 7
            }, .5, 150, 150, !0, "center"), this.freeText.inputEnabled = !0, this.freeText.input.useHandCursor = !0, this.freeText.events.onInputDown.add(function() {
                this.available && G.sb("pushWindow").dispatch(["dailyChallenge", G.saveState.getDailyChallengeLevel()])
            }, this), this.freeText.lineSpacing = -20, this.freeText.setShadow(0, 0, "black", 3), this.add(this.freeText), game.add.tween(this.freeText.scale).to({
                x: .9,
                y: .9
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.checkAvailability(), G.sb("onScreenResize").add(this.onResize, this), this.onResize();
            var c = this.state.lastLevelData;
            c && c.challenge && game.time.events.add(1e3, function() {
                this.batchesWaitingForFinish = 0, this.createParticlesBatch(c)
            }, this)
        }, G.UI_DailyChallengeIcon.prototype = Object.create(Phaser.Group.prototype), G.UI_DailyChallengeIcon.prototype.update = function() {
            this.glow.angle++
        }, G.UI_DailyChallengeIcon.prototype.checkAvailability = function() {
            this.unlocked && G.saveState.isChallengeAvailable() ? (this.available = !0, this.freeText.visible = this.glow.visible = !0, this.visible = !0) : (this.freeText.visible = this.glow.visible = !1, this.available = !1, this.visible = !1, game.time.events.add(5e3, this.checkAvailability, this))
        }, G.UI_DailyChallengeIcon.prototype.onResize = function() {
            var a = game.world.bounds.x + Math.floor(.5 * game.width);
            this.x = game.width < 1070 ? a + 260 : a + 260 + 230
        }, G.UI_DailyChallengeIcon.prototype.createParticlesBatch = function(a) {
            0 < a.starImprovement && this.afterLvlPartBatch(a.lvlNr, a.starImprovement, "stars"), 0 < a.reward && this.afterLvlPartBatch(a.lvlNr, a.reward, "coins")
        }, G.UI_DailyChallengeIcon.prototype.afterLvlPartBatch = function(a, b, c) {
            var d = "coins" == c,
                e = this.state.uiTargetParticlesBW.createDividedBatch(game.world.bounds.x + this.worldPosition.x, this.worldPosition.y, d ? "coin_1" : "map_star_1", d ? this.state.panel.coinsTxt : this.state.panel.starsTxt, b, d ? 3 : 1);
            e.addOnPartStart(function() {
                this.scale.setTo(d ? .9 : 1.2), this.speedDelta = .5, this.speedMax = 20, this.vel.x = game.rnd.realInRange(-20, 20), this.vel.y = game.rnd.realInRange(-20, 20)
            }), e.addOnPartFinish(function() {
                if (G.sfx.pop.play(), d) G.saveState.changeCoins(this.carriedValue, !0);
                else {
                    var a = this.state.panel.starsTxt;
                    a.setText(parseInt(a.text) + 1)
                }
            }), this.batchesWaitingForFinish++, e.onFinish.add(function() {
                this.batchesWaitingForFinish--, 0 == this.batchesWaitingForFinish && G.saveState.save()
            }, this), e.start()
        }, G.UI_DailyIcon = function(a, b) {
            this.active = G.saveState.getLastPassedLevelNr() >= G.json.settings.featuresUnlock.daily, this.tutorial = this.active && !G.saveState.data.sawDailyTut, this.state = game.state.getCurrentState(), Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.addIcon(), this.active ? (this.addGlow(), this.addTimerAndFreeText()) : this.addUnlockTxt(), this.update(), this.tutorial && (this.tutHand = G.makeImage(0, 20, "tut_hand", 0, this), game.add.tween(this.tutHand).to({
                x: G.l(20),
                y: G.l(50)
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.UI_DailyIcon.prototype = Object.create(Phaser.Group.prototype), G.UI_DailyIcon.prototype.update = function() {
            this.active && (this.glow.angle++, this.freeText.visible = this.glow.visible = G.saveState.data.freeSpin, this.timer.visible = !this.freeText.visible), this.iconDark.visible = !this.active || !G.saveState.data.freeSpin
        }, G.UI_DailyIcon.prototype.onResize = function() {
            var a = game.world.bounds.x + Math.floor(.5 * game.width);
            this.x = game.width < 1070 ? a + 260 : a + 260 + 230
        }, G.UI_DailyIcon.prototype.addIcon = function() {
            this.icon = new G.Button(0, 0, "daily_icon", function() {
                this.active && (game.incentivised || G.saveState.data.freeSpin) && (G.sb("pushWindow").dispatch(["daily2", this.tutorial]), this.tutorial && (this.tutHand && this.tutHand.destroy(), G.saveState.data.sawDailyTut = !0, G.saveState.save(), G.sb("onWindowClosed").addOnce(function() {
                    var a = game.state.getCurrentState();
                    a.lvlTutHand && game.add.tween(a.lvlTutHand).to({
                        alpha: 1
                    }, 500, Phaser.Easing.Sinusoidal.Out, !0)
                })))
            }, this), this.add(this.icon), this.iconDark = G.makeImage(0, 0, "daily_icon_dark", .5, this.icon)
        }, G.UI_DailyIcon.prototype.addGlow = function() {
            this.glow = G.makeImage(0, 0, "popup_lighht", .5, this), this.glow.alpha = .5, this.glow.scale.setTo(.5), this.glow.blendMode = 1, this.glow.update = function() {
                this.angle++
            }, this.sendToBack(this.glow)
        }, G.UI_DailyIcon.prototype.addTimerAndFreeText = function() {
            this.timer = new G.Timer(0, 0, "font-white-stroke", 30, 130, .5, .5, (G.saveState.data.lastDaily + 864e5 - Date.now()) / 1e3), this.timer.active = !0, this.add(this.timer), G.sb("onDailyFreeSpinGain").add(function() {
                this.timer.setSecLeft((G.saveState.data.lastDaily + 864e5 - Date.now()) / 1e3)
            }, this), this.freeText = new G.Text(0, 0, G.txt("Free spin!"), {
                fill: "#ffffe8",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#004455",
                strokeThickness: 5
            }, .5, 150, 150, !0, "center"), this.freeText.lineSpacing = -15, this.freeText.setShadow(0, 0, "black", 3), this.add(this.freeText), game.add.tween(this.freeText.scale).to({
                x: .9,
                y: .9
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.UI_DailyIcon.prototype.addUnlockTxt = function() {
            this.unlockTxt = new G.Text(0, 0, G.txt("Unlock at Level X").replace("X", G.json.settings.featuresUnlock.daily + 1), {
                fill: "#fdfbe4",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#73461c",
                strokeThickness: 5
            }, .5, 150, 150, !0, "center"), this.unlockTxt.lineSpacing = -15, this.unlockTxt.setShadow(0, 0, "black", 3), this.add(this.unlockTxt), game.add.tween(this.unlockTxt.scale).to({
                x: .9,
                y: .9
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.UI_ExtraMovesBuyButton = function() {
            Phaser.Group.call(this, game), this.targetY = 0, this.state = game.state.getCurrentState(), this.hl = G.makeImage(0, 0, "popup_lighht", .5, this), this.hl.alpha = .2, this.hl.scale.setTo(.6), this.hl.blendMode = 1, this.floating = {
                offset: G.l(-10)
            }, game.add.tween(this.floating).to({
                offset: G.l(10)
            }, 700, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.btn = new G.Button(0, 0, "ui_booster_5", this.btnClick, this), this.btn.sfx = G.sfx.cash_register, this.btn.addTerm(function() {
                return G.lvl.moves < 5
            }), this.add(this.btn), this.labelBg = G.makeImage(0, 45, "move_extra_label", .5, this), G.sb("madeMove").add(function() {
                G.lvl.goalAchieved || G.saveState.data.coins >= G.lvl.getPriceOfExtraMoves() && 4 == G.lvl.moves && this.show()
            }, this), G.sb("onWindowOpened").add(function() {
                this.hide()
            }, this), G.sb("onWindowClosed").add(function() {
                this.visible || G.saveState.data.coins >= G.lvl.getPriceOfExtraMoves() && G.lvl.moves <= 4 && 0 < G.lvl.moves && this.show()
            }, this), this.scale.setTo(0), this.visible = !1, G.sb("onGoalAchieved").add(this.hide, this)
        }, G.UI_ExtraMovesBuyButton.prototype = Object.create(Phaser.Group.prototype), G.UI_ExtraMovesBuyButton.prototype.update = function() {
            this.y = this.targetY + this.floating.offset, this.hl.angle++
        }, G.UI_ExtraMovesBuyButton.prototype.btnClick = function() {
            if (G.saveState.data.coins >= G.lvl.getPriceOfExtraMoves()) {
                var a = this.worldPosition;
                G.sb("UIfx").dispatch(a.x + game.world.bounds.x, a.y, "whiteStarPart"), G.sb("UIfx").dispatch(a.x + game.world.bounds.x, a.y, "whiteStarPart"), G.sb("UIfx").dispatch(a.x + game.world.bounds.x, a.y, "whiteStarPart"), G.sb("UIfx").dispatch(a.x + game.world.bounds.x, a.y, "whiteStarPart"), G.lvl.buyExtraMoves(), this.hide()
            } else this.state.windowLayer.pushWindow(["moreMoney"])
        }, G.UI_ExtraMovesBuyButton.prototype.show = function() {
            !game.incentivised && G.saveState.getCoins() < G.lvl.getPriceOfExtraMoves() || (this.priceTxt && this.priceTxt.destroy(), this.priceTxt = new G.LabelGroupT("$+5 moves$ " + G.lvl.getPriceOfExtraMoves() + "@coin_1@", 5, 45, {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "white"
            }, .5, 180), this.add(this.priceTxt), this.visible = !0, G.stopTweens(this), this.scale.setTo(0), game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 2e3, Phaser.Easing.Elastic.Out, !0))
        }, G.UI_ExtraMovesBuyButton.prototype.hide = function() {
            G.stopTweens(this), game.add.tween(this.scale).to({
                x: 0,
                y: 0
            }, 400, Phaser.Easing.Cubic.Out, !0).onComplete.add(function() {
                this.visible = !1
            }, this)
        }, G.UI_Life = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.lifeIcon = new G.Button(0, 0, "top-panel-heardsBg", function() {
                G.gameTracking.design("GetLivesButtonClicked"), G.sb("pushWindow").dispatch("buyLives")
            }, this), this.add(this.lifeIcon), this.currentLivesNr = G.saveState.getCurrentLivesNr(), this.livesMax = G.json.settings.livesMax, this.livesNrTxt = new G.Text(-50, 0, this.currentLivesNr.toString(), {
                style: "font-red",
                fontSize: "29px"
            }, .5, 150), this.add(this.livesNrTxt), this.timer = new G.TextTimer(25, 4, 0, {
                style: "font-beige",
                fontSize: 30
            }, .5, 140, "ms"), this.add(this.timer), this.timerMax = new G.Text(25, 4, G.txt("Max"), {
                style: "font-beige",
                fontSize: 30
            }, .5, 100), this.add(this.timerMax), this.timer.start(), G.sb("onWallClockTimeUpdate").add(this.onTickUpdate, this), G.sb("onLifeAdded").add(this.onTickUpdate, this), G.sb("onLifeTimerUpdate").add(this.timer.setSecLeft, this.timer), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onAllWindowsClosed").add(this.unlockInput, this)
        }, G.UI_Life.prototype = Object.create(Phaser.Group.prototype), G.UI_Life.prototype.onTickUpdate = function() {
            var a = G.saveState.getCurrentLivesNr();
            this.currentLivesNr !== a && (this.currentLivesNr = a, this.livesNrTxt.setText(this.currentLivesNr.toString()))
        }, G.UI_Life.prototype.update = function() {
            this.currentLivesNr !== this.livesMax ? (this.timer.visible = !0, this.timerMax.visible = !1) : (this.timer.visible = !1, this.timerMax.visible = !0), this.lifeIcon.inputEnabled = 0 === this.currentLivesNr ? !0 : !1
        }, G.UI_Life.prototype.lockInput = function() {
            this.ignoreChildInput = !0
        }, G.UI_Life.prototype.unlockInput = function() {
            this.ignoreChildInput = !1
        }, G.UI_PopOutMoney = function() {
            Phaser.Image.call(this, game, 0, 0, null), this.state = game.state.getCurrentState(), this.double = this.state.doubleMoney, G.changeTexture(this, this.double ? "coin_2" : "coin_1"), this.anchor.setTo(.5), this.kill()
        }, G.UI_PopOutMoney.prototype = Object.create(Phaser.Image.prototype), G.UI_PopOutMoney.prototype.init = function(a, b) {
            G.stopTweens(this), this.revive(), G.saveState.changeCoins(this.double ? 2 : 1), G.sb("onLevelMoneyGain").dispatch(this.double ? 2 : 1), G.sfx.cash_register.play(), this.x = a, this.y = b, this.scale.setTo(0), this.angle = -10, game.add.tween(this).to({
                y: this.y - G.l(20 * Math.random() + 30)
            }, 500, Phaser.Easing.Cubic.InOut, !0, 0, 0, !0), game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 500, Phaser.Easing.Cubic.InOut, !0, 0, 0, !0).onComplete.add(this.kill, this)
        }, G.UI_ShoutOuts = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.board = this.state.board, this.glowImg = G.makeImage(0, 0, "popup_lighht", .5, this), this.glowImg.alpha = .5, this.glowImg.visible = !1, this.shoutOut = new G.Text(0, 0, " ", {
                style: "font-red",
                fontSize: 70
            }, .5, 600), this.add(this.shoutOut), this.shoutOut.visible = !1, this.combo = 0, G.sb("onComboIncrease").add(this.increaseCombo, this), G.sb("onComboBreak").add(this.breakCombo, this), G.sb("onGoalAchieved").add(this.cookieCrush, this), G.sb("madeMove").add(function() {
                G.lvl.goalAchieved || (10 == G.lvl.moves && this.lockedShoutOut(G.txt("10 moves left")), 5 == G.lvl.moves && this.lockedShoutOut(G.txt("5 moves left")))
            }, this), this.locked = !1, this.board = game.state.getCurrentState().board, this.x = this.board.x + .5 * (this.board.width - 2 * this.board.tilesize), this.y = this.board.y + .45 * (this.board.height - 2 * this.board.tilesize)
        }, G.UI_ShoutOuts.prototype = Object.create(Phaser.Group.prototype), G.UI_ShoutOuts.prototype.update = function() {
            this.x = this.board.x + .5 * (this.board.width - 2 * this.board.tilesize), this.y = this.board.y + .45 * (this.board.height - 2 * this.board.tilesize), this.glowImg.angle++
        }, G.UI_ShoutOuts.prototype.increaseCombo = function(a) {
            if (!this.locked && !G.lvl.goalAchieved) {
                this.combo = a;
                var b = !1;
                3 == this.combo && (b = G.txt("Sweet!"), G.sfx.sweet.play()), 5 == this.combo && (b = G.txt("Tasty!"), G.sfx.tasty.play()), 7 == this.combo && (b = G.txt("Delicious!"), G.sfx.delicious.play()), 9 == this.combo && (b = G.txt("Divine!"), G.sfx.divine.play()), b && (G.stopTweens(this.shoutOut), this.shoutOut.visible = !0, this.shoutOut.alpha = 1, this.shoutOut.setText(b), this.shoutOut.scale.setTo(0), game.add.tween(this.shoutOut.scale).to({
                    x: 1,
                    y: 1
                }, 700, Phaser.Easing.Elastic.Out, !0), game.add.tween(this.shoutOut).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.In, !0, 1e3).onComplete.add(function() {
                    this.shoutOut.visible = !1
                }, this))
            }
        }, G.UI_ShoutOuts.prototype.lockedShoutOut = function(a) {
            this.locked = !0, G.stopTweens(this.shoutOut), this.shoutOut.visible = !0, this.shoutOut.alpha = 1, this.shoutOut.setText(a), this.shoutOut.scale.setTo(0), game.add.tween(this.shoutOut.scale).to({
                x: 1,
                y: 1
            }, 700, Phaser.Easing.Elastic.Out, !0), game.add.tween(this.shoutOut).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0, 1500).onComplete.add(function() {
                this.shoutOut.visible = !1, this.locked = !1
            }, this)
        }, G.UI_ShoutOuts.prototype.cookieCrush = function() {
            G.sfx.sugarcrush.play(), this.glowImg.scale.setTo(0), this.glowImg.visible = !0, game.add.tween(this.glowImg.scale).to({
                x: 1.5,
                y: 1.5
            }, 500, Phaser.Easing.Elastic.Out, !0), game.add.tween(this.glowImg).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0, 1500), G.stopTweens(this.shoutOut), this.shoutOut.visible = !0, this.shoutOut.alpha = 1, this.shoutOut.setText(G.txt("SUGAR CRUSH!")), this.shoutOut.scale.setTo(0), game.add.tween(this.shoutOut.scale).to({
                x: 1,
                y: 1
            }, 700, Phaser.Easing.Elastic.Out, !0), game.add.tween(this.shoutOut).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0, 1500).onComplete.add(function() {
                this.shoutOut.visible = !1
            }, this);
            for (var a = 0; a < 10; a++) G.sb("UIfx").dispatch(this.x - 100 + 20 * a, this.y, "whiteStarPart")
        }, G.UI_ShoutOuts.prototype.breakCombo = function() {
            this.combo = 0
        }, G.UI_StartBoosterButton = function(a, b, c, d) {
            Phaser.Group.call(this, game), this.unlocked = G.saveState.isBoosterUnlocked(c), this.x = G.l(a), this.y = G.l(b), this.nr = c, this.lvlNr = d, this.unlocked ? (this.initUnlocked(c, d), G.saveState.data.startBoosterAnim[c - 5] && (G.saveState.data.startBoosterAnim[c - 5] = !1, G.saveState.save(), this.initUlockAnimation())) : this.img = G.makeImage(0, 0, "ui_booster_" + c + "_locked", .5, this)
        }, G.UI_StartBoosterButton.prototype = Object.create(Phaser.Group.prototype), G.UI_StartBoosterButton.prototype.update = function() {
            this.hl && (this.hl.angle++, this.hl.alpha = game.math.clamp(this.hl.alpha + (this.selected ? .05 : -.05), 0, 1), this.priceTxt.alpha = game.math.clamp(this.priceTxt.alpha + (0 != this.amount || this.selected ? -.05 : .05), 0, 1));
            for (var a = this.children.length; a--;) this.children[a].update()
        }, G.UI_StartBoosterButton.prototype.select = function() {
            this.startBoosterConfig.select(this.levelNr, this.boosterNr), this.selected = !0, this.amount--, this.amountTxt.setText(this.amount.toString())
        }, G.UI_StartBoosterButton.prototype.deselect = function() {
            this.startBoosterConfig.deselect(this.levelNr, this.boosterNr), this.selected = !1, this.amount++, this.amountTxt.setText(this.amount.toString())
        }, G.UI_StartBoosterButton.prototype.initUnlocked = function(a, b) {
            this.startBoosterConfig = game.state.getCurrentState().startBoosterConfig, this.boosterNr = a, this.levelNr = b, this.hl = G.makeImage(0, 0, "popup_lighht", .5, this), this.hl.scale.setTo(.6), this.hl.angle = 360 * Math.random(), this.hl.alpha = 0, this.btn = new G.Button(0, 0, "ui_booster_" + a, function() {
                this.selected ? this.deselect() : 0 < this.amount ? this.select() : G.saveState.isEnoughToBuyBooster(this.boosterNr) ? (G.saveState.buyBooster(this.boosterNr), this.amount++, this.amountTxt.setText(this.amount.toString())) : game.incentivised ? (this.parent.state.windowLayer.pushWindow(["moreMoney", "level"]), this.parent.closeWindow()) : (this.alpha = .5, this.btn.inputEnabled = !1)
            }, this), this.add(this.btn), this.selected = !1, this.amountBg = G.makeImage(-40, -40, "booster_ammount", .5, this), this.amount = G.saveState.getBoosterAmount(a), this.amountTxt = new G.Text(-40, -40, this.amount.toString(), {
                style: "font-beige-standard",
                fontSize: "25px"
            }, .5, 100), this.add(this.amountTxt), this.priceTxt = new G.LabelGroupT(G.json.settings["priceOfBooster" + this.boosterNr] + "@coin_1@", 10, 45, {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "white"
            }, .5, 100), this.add(this.priceTxt), 0 < this.amount && (this.priceTxt.alpha = 0), this.startBoosterConfig.isSelected(this.levelNr, this.boosterNr) && this.select(), 0 == this.amount && !game.incentivised && G.saveState.getCoins() < G.json.settings["priceOfBooster" + this.boosterNr] && (this.alpha = .5, this.btn.inputEnabled = !1)
        }, G.UI_StartBoosterButton.prototype.initUlockAnimation = function() {
            this.ignoreChildInput = !0, this.amountTxt.alpha = 0, this.amountBg.alpha = 0;
            var a = G.makeImage(0, 0, "circle", .5, this),
                b = a.width,
                c = a.height;
            a.scale.setTo(0), a.blendMode = 1, game.add.tween(a).to({
                width: 2 * b,
                height: 2 * c,
                alpha: 0
            }, 600, Phaser.Easing.Cubic.Out, !0, 500), game.time.events.add(500, function() {
                G.sfx.match_1.play();
                for (var a = 0; a < 5; a++) {
                    var b = G.makeImage(0, 0, "starPart", .5, this);
                    b.angle = 360 * Math.random(), b.velX = Math.random(20) * G.lnf(-20) + G.lnf(10), b.velY = Math.random() * G.lnf(-9) - G.lnf(3), b.gravity = G.lnf(.5), b.update = function() {
                        this.x += this.velX * G.deltaTime, this.y += this.velY * G.deltaTime, this.angle += .1 * this.velX, this.velX *= .99, this.velY += this.gravity * G.deltaTime, this.alpha -= .02, this.alpha <= 0 && this.kill()
                    }
                }
                game.add.tween(this.amountTxt).to({
                    alpha: 1
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.amountBg).to({
                    alpha: 1
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.ignoreChildInput = !1
            }, this), this.lock = G.makeImage(0, 0, "ui_booster_" + this.nr + "_locked", .5, this), game.add.tween(this.lock).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 500)
        }, G.makeExtImage = function(a, b, c, d, e, f, g, h) {
            var i;
            if (G.extLoader || (G.extLoader = new G.ExtLoader(game), G.extLoader.crossOrigin = "anonymous"), G.extLoader.loadedUrls[c]) return i = G.makeImage(a, b, G.extLoader.loadedUrls[c], e, f), h.call(i), i;
            (i = G.makeImage(a, b, d, e, f)).onImgLoaded = new Phaser.Signal, G.extImagesKeys || (G.extImagesKeys = []);
            var j = "extImgBlankName" + G.extImagesKeys.length;
            G.extImagesKeys.push(j);
            var k = G.extLoader.onFileComplete.add(function(a, b, d) {
                b == j && d && (G.extLoader.loadedUrls[c] = j, G.changeTexture(i, j), h && h.call(i), k.detach())
            });
            return G.extLoader.image(j, c, !0), i
        }, G.changeSecToDHMS = function(a) {
            var b = parseInt(a, 10),
                c = Math.floor(b / 86400),
                d = Math.floor((b - 86400 * c) / 3600),
                e = Math.floor((b - 86400 * c - 3600 * d) / 60),
                f = b - 86400 * c - 3600 * d - 60 * e;
            return [this.zeroPad(c), this.zeroPad(d), this.zeroPad(e), this.zeroPad(f)]
        }, G.zeroPad = function(a) {
            return a < 10 ? "0" + a : a
        }, G.WaitingIcon = function(a, b) {
            Phaser.Image.call(this, game, a, b), G.changeTexture(this, "waiting_icon"), this.anchor.setTo(.5, .5), this.frameCounter = 0
        }, G.WaitingIcon.prototype = Object.create(Phaser.Image.prototype), G.WaitingIcon.prototype.update = function() {
            this.frameCounter++ % 5 == 0 && (this.angle += 45)
        }, G.WorldMapBubbleGiftDynamicLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.map = a, this.freeInstances = [], this.activeBubbleGiftsData = JSON.parse(JSON.stringify(G.json.settings.bubbleGifts)).filter(function(a) {
                return !G.saveState.isBubbleGiftUsed(a.levelNumber)
            }), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this)
        }, G.WorldMapBubbleGiftDynamicLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapBubbleGiftDynamicLayer.prototype.unlockInput = function() {
            this.ignoreChildInput = !1, this.children.forEach(function(a) {
                a.ignoreChildInput = !1
            })
        }, G.WorldMapBubbleGiftDynamicLayer.prototype.lockInput = function() {
            this.ignoreChildInput = !0, this.children.forEach(function(a) {
                a.ignoreChildInput = !0
            })
        }, G.WorldMapBubbleGiftDynamicLayer.prototype.update = function() {
            for (var a = 0, b = this.activeBubbleGiftsData.length; a < b; a++) {
                var c = this.activeBubbleGiftsData[a];
                if (G.json.levels[c.levelNumber - 1]) {
                    var d = this.y + G.json.levels[c.levelNumber - 1].mapY; - 500 < d && d < game.height + 500 ? c.instance || G.saveState.isBubbleGiftUsed(c.levelNumber) || this.placeInstance(c) : c.instance && this.hideInstance(c)
                }
            }
        }, G.WorldMapBubbleGiftDynamicLayer.prototype.placeInstance = function(a) {
            a.instance = this.getFreeInstance(), a.instance.init(a), this.add(a.instance)
        }, G.WorldMapBubbleGiftDynamicLayer.prototype.hideInstance = function(a) {
            a.instance.hide(), a.instance.parent.removeChild(a.instance), this.freeInstances.push(a.instance), a.instance = null
        }, G.WorldMapBubbleGiftDynamicLayer.prototype.getFreeInstance = function() {
            return this.freeInstances.shift() || new G.WorldMapBubbleGiftDynamicLayer.BubbleGift
        }, G.WorldMapBubbleGiftDynamicLayer.BubbleGift = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.iconImg = G.makeImage(0, 0, null, .5, this), this.bubbleImg = G.makeImage(0, 0, null, .5, this), this.bubbleImg2 = G.makeImage(0, 0, null, .5, this), this.bubbleImg2.blendMode = 1, this.bubbleImg2.scale = this.bubbleImg.scale, this.bubbleImg2.alpha = .3, game.add.tween(this.bubbleImg2).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), game.add.tween(this.pivot).to({
                y: 20
            }, 2600, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.WorldMapBubbleGiftDynamicLayer.BubbleGift.prototype = Object.create(Phaser.Group.prototype), G.WorldMapBubbleGiftDynamicLayer.BubbleGift.prototype.init = function(a) {
            this.config = a, this.levelNumber = this.config.levelNumber, this.lvlData = G.json.levels[a.levelNumber - 1], this.position.setTo(this.lvlData.mapX, this.lvlData.mapY), this.config.offset ? (this.position.x += this.config.offset.x, this.position.y += this.config.offset.y) : this.position.y -= 120;
            var b = G.gift.getIcon(this.config.gift);
            G.changeTexture(this.iconImg, "coin_1" === b ? "coin_3" : b), this.iconImg.scale.setTo("coin_3" === b ? .9 : 1), this.bubbleImg.scale.setTo(1), this.unlocked = this.config.levelNumber - 1 <= G.saveState.getLastPassedLevelNr(), G.changeTexture(this.bubbleImg, this.unlocked ? "giftBubble_active" : "giftBubble"), G.changeTexture(this.bubbleImg2, this.unlocked ? "giftBubble_active" : "giftBubble"), this.unlocked ? (this.bubbleImg.inputEnabled = !0, this.bubbleImg.input.useHandCursor = !0, this.bubbleImg.events.onInputDown.addOnce(this.open, this), this.bubbleImg2.visible = !0, this.alpha = 1) : (this.bubbleImg.inputEnabled = !1, this.bubbleImg2.visible = !1, this.alpha = .75)
        }, G.WorldMapBubbleGiftDynamicLayer.BubbleGift.prototype.hide = function() {
            G.stopTweens(this), G.stopTweens(this.bubbleImg), G.stopTweens(this.iconImg), this.bubbleImg.events.onInputDown.removeAll(), this.rewardLabel && (this.rewardLabel.destroy(), this.rewardLabel = null)
        }, G.WorldMapBubbleGiftDynamicLayer.BubbleGift.prototype.open = function() {
            G.saveState.markBubbleGiftAsUsed(this.config.levelNumber), G.gift.applyGift(this.config.gift), G.sb("onBubbleGiftOpened").dispatch(this.config.levelNumber), G.sfx.pop.play(), game.time.events.add(300, G.sfx.line.play, G.sfx.line), this.bubbleImg.inputEnabled = !1;
            var a = G.gift.getLabelString(this.config.gift, 1.2);
            game.add.tween(this.bubbleImg.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Cubic.In, !0), game.add.tween(this.iconImg.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Cubic.In, !0), this.rewardLabel = this.add(new G.LabelTextT(a, 0, 0, {
                font: "ComicSansBold",
                fontSize: "45px",
                fill: "#A0692E",
                stroke: "#85511f",
                strokeThickness: 4
            }, .5, 300)), this.rewardLabel.scale.setTo(0), game.add.tween(this.rewardLabel.scale).to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !0, 300), game.add.tween(this).to({
                alpha: 0
            }, 400, Phaser.Easing.Sinusoidal.Out, !0, 1200)
        }, G.WorldMapBubbleGiftLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.init(), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this)
        }, G.WorldMapBubbleGiftLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapBubbleGiftLayer.prototype.unlockInput = function() {
            this.ignoreChildInput = !1, this.children.forEach(function(a) {
                a.ignoreChildInput = !1
            })
        }, G.WorldMapBubbleGiftLayer.prototype.lockInput = function() {
            this.ignoreChildInput = !0, this.children.forEach(function(a) {
                a.ignoreChildInput = !0
            })
        }, G.WorldMapBubbleGiftLayer.prototype.init = function() {
            G.json.settings.bubbleGifts.forEach(function(a) {
                G.saveState.isBubbleGiftUsed(a.levelNumber) || this.add(new G.WorldMapBubbleGiftLayer.BubbleGift(a))
            }, this)
        }, G.WorldMapBubbleGiftLayer.BubbleGift = function(a) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.config = a, this.levelNumber = this.config.levelNumber, this.lvlData = G.json.levels[a.levelNumber - 1], this.position.x = this.lvlData.mapX, this.position.y = this.lvlData.mapY, this.config.offset ? (this.position.x += this.config.offset.x, this.position.y += this.config.offset.y) : this.position.y -= 120, this.unlocked = this.config.levelNumber - 1 <= G.saveState.getLastPassedLevelNr();
            var b = G.gift.getIcon(this.config.gift);
            "coin_1" === b && (b = "coin_3"), this.iconImg = G.makeImage(0, 0, b, .5, this), "coin_3" === b && this.iconImg.scale.setTo(.9), this.bubbleImg = G.makeImage(0, 0, this.unlocked ? "giftBubble_active" : "giftBubble", .5, this), this.unlocked ? (this.bubbleImg.inputEnabled = !0, this.bubbleImg.input.useHandCursor = !0, this.bubbleImg.events.onInputDown.addOnce(this.open, this), this.bubbleImg2 = G.makeImage(0, 0, this.unlocked ? "giftBubble_active" : "giftBubble", .5, this), this.bubbleImg2.blendMode = 1, this.bubbleImg2.scale = this.bubbleImg.scale, this.bubbleImg2.alpha = .3, game.add.tween(this.bubbleImg2).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)) : this.alpha = .75, game.add.tween(this).to({
                y: this.y + 20
            }, 2600, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.WorldMapBubbleGiftLayer.BubbleGift.prototype = Object.create(Phaser.Group.prototype), G.WorldMapBubbleGiftLayer.BubbleGift.prototype.update = function() {
            var a = this.state.map.y + this.y;
            this.visible = a < -400 || a > game.height + 400 ? !1 : !0
        }, G.WorldMapBubbleGiftLayer.BubbleGift.prototype.open = function() {
            G.saveState.markBubbleGiftAsUsed(this.config.levelNumber), G.gift.applyGift(this.config.gift), G.sb("onBubbleGiftOpened").dispatch(this.config.levelNumber), G.sfx.pop.play(), game.time.events.add(300, G.sfx.line.play, G.sfx.line), this.bubbleImg.inputEnabled = !1;
            var a = G.gift.getLabelString(this.config.gift, 1.2);
            game.add.tween(this.bubbleImg.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Cubic.In, !0), game.add.tween(this.iconImg.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Cubic.In, !0), this.rewardLabel = this.add(new G.LabelGroupT(a, 0, 0, {
                font: "ComicSansBold",
                fontSize: "45px",
                fill: "#A0692E",
                stroke: "#85511f",
                strokeThickness: 4
            }, .5, 300)), this.rewardLabel.scale.setTo(0), game.add.tween(this.rewardLabel.scale).to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Elastic.Out, !0, 300), game.time.events.add(1200, function() {
                game.add.tween(this).to({
                    alpha: 0
                }, 400, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                    this.destroy()
                }, this)
            }, this)
        }, G.WorldMapChestDynamicLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.map = a, this.freeInstances = [], this.activeChestsData = JSON.parse(JSON.stringify(G.json.settings.mapChests)).filter(function(a) {
                return !G.saveState.data.mapChests[a.id]
            }), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this)
        }, G.WorldMapChestDynamicLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapChestDynamicLayer.prototype.unlockInput = function() {
            this.ignoreChildInput = !1, this.children.forEach(function(a) {
                a.ignoreChildInput = !1
            })
        }, G.WorldMapChestDynamicLayer.prototype.lockInput = function() {
            this.ignoreChildInput = !0, this.children.forEach(function(a) {
                a.ignoreChildInput = !0
            })
        }, G.WorldMapChestDynamicLayer.prototype.update = function() {
            for (var a = 0, b = this.activeChestsData.length; a < b; a++) {
                var c = this.activeChestsData[a],
                    d = this.y + c.mapY; - 500 < d && d < game.height + 500 ? c.instance || c.opened || G.saveState.data.mapChests[c.id] || this.placeInstance(c) : c.instance && this.hideInstance(c)
            }
            for (var e = this.children.length; e--;) this.children[e].update()
        }, G.WorldMapChestDynamicLayer.prototype.placeInstance = function(a) {
            a.instance = this.getFreeInstance(), a.instance.init(a), this.add(a.instance)
        }, G.WorldMapChestDynamicLayer.prototype.hideInstance = function(a) {
            a.instance.hide(), a.instance.parent.removeChild(a.instance), this.freeInstances.push(a.instance), a.instance = null
        }, G.WorldMapChestDynamicLayer.prototype.getFreeInstance = function() {
            return this.freeInstances.shift() || new G.WorldMapChestDynamicLayer.ChestInstance
        }, G.WorldMapChestDynamicLayer.ChestInstance = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.shadow = G.makeImage(0, 40, "chest_shadow", .5, this), this.chest = new G.Button(0, 0, "chest", this.onClick, this), this.chest.IMMEDIATE = !0, this.chestGlow = G.makeImage(0, 0, "chest", .5, this.chest), this.chestGlow.blendMode = 1, this.chestGlow.alpha = .4, game.add.tween(this.chestGlow).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.add(this.chest), game.time.events.loop(2e3, this.setJumpRepeat, this)
        }, G.WorldMapChestDynamicLayer.ChestInstance.prototype = Object.create(Phaser.Group.prototype), G.WorldMapChestDynamicLayer.ChestInstance.prototype.init = function(a) {
            G.changeTexture(this.chest, "chest"), G.changeTexture(this.chestGlow, "chest"), this.chestData = a, this.position.setTo(a.mapX, a.mapY), this.orgX = this.x, this.orgY = this.y, this.chest.inputEnabled = !0, this.chest.input.useHandCursor = !0, this.chest.scale.x = this.x < 0 ? 1 : -1, this.shadow.scale.x = this.chest.scale.x, this.alpha = 1, this.opened = !1, this.currentStars = G.saveState.getAllStars(), this.unlocked = this.currentStars >= a.req, this.unlocked ? (this.chestGlow.visible = !0, this.setJumpRepeat()) : (this.chestGlow.visible = !1, this.label = new G.LabelTextT(Math.min(this.currentStars, a.req) + "/" + this.chestData.req + "@map_star_1@", 0, 50, {
                font: "ComicSansBold",
                fontSize: "35px",
                fill: "#fdfbe4",
                stroke: "#73461c",
                strokeThickness: 5
            }, .5, 150), this.add(this.label))
        }, G.WorldMapChestDynamicLayer.ChestInstance.prototype.update = function() {
            this.shadow.alpha = 1 + this.chest.y / 150
        }, G.WorldMapChestDynamicLayer.ChestInstance.prototype.hide = function() {
            G.stopTweens(this.chest), this.chest.position.setTo(0, 0), this.chest.angle = 0, this.label && this.label.destroy()
        }, G.WorldMapChestDynamicLayer.ChestInstance.prototype.onClick = function() {
            this.unlocked ? (G.changeTexture(this.chest, "chest_open"), G.changeTexture(this.chestGlow, "chest_open"), this.opened = !0, this.chestData.opened = !0, G.saveState.data.mapChests[this.chestData.id] = !0, G.saveState.save(), this.chest.inputEnabled = !1, G.sb("pushWindow").dispatch(["mapChest", this.chestData.gifts]), game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 1e3).onComplete.add(function() {
                this.hide()
            }, this)) : (this.chest.inputEnabled = !1, this.jump(function() {
                this.chest.inputEnabled = !0, this.chest.input.useHandCursor = !0
            }, this))
        }, G.WorldMapChestDynamicLayer.ChestInstance.prototype.setJumpRepeat = function() {
            this.opened || this.unlocked && this.parent && this.jump()
        }, G.WorldMapChestDynamicLayer.ChestInstance.prototype.jump = function(a, b) {
            var c = game.add.tween(this.chest).to({
                    y: -G.l(150)
                }, 300, Phaser.Easing.Cubic.Out),
                d = game.add.tween(this.chest).to({
                    y: 0
                }, 300, Phaser.Easing.Circular.In);
            c.chain(d), c.start();
            var e = game.add.tween(this.chest).to({
                    angle: -15
                }, 200, Phaser.Easing.Cubic.InOut),
                f = game.add.tween(this.chest).to({
                    angle: 15
                }, 375, Phaser.Easing.Sinusoidal.In),
                g = game.add.tween(this.chest).to({
                    angle: 0
                }, 50, Phaser.Easing.Cubic.InOut);
            e.chain(f, g), e.start(), a && g.onComplete.add(a, b)
        }, G.WorldMapChestLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, G.json.settings.mapChests.forEach(function(a) {
                G.saveState.data.mapChests[a.id] || this.add(new G.WorldMapChestLayer.Chest(a))
            }, this), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this)
        }, G.WorldMapChestLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapChestLayer.prototype.unlockInput = function() {
            this.ignoreChildInput = !1, this.children.forEach(function(a) {
                a.ignoreChildInput = !1
            })
        }, G.WorldMapChestLayer.prototype.lockInput = function() {
            this.ignoreChildInput = !0, this.children.forEach(function(a) {
                a.ignoreChildInput = !0
            })
        }, G.WorldMapChestLayer.Chest = function(a) {
            Phaser.Group.call(this, game), this.onChestClicked = new Phaser.Signal, this.chestData = a, this.state = game.state.getCurrentState(), this.shadow = G.makeImage(0, 40, "chest_shadow", .5, this), this.x = G.l(a.mapX), this.y = G.l(a.mapY), this.orgX = this.x, this.orgY = this.y, this.opened = !1, this.currentStars = G.saveState.getAllStars();
            var b = Math.min(this.currentStars, this.chestData.req);
            this.unlocked = this.currentStars >= a.req, this.gift = new G.Button(0, 0, "chest", this.onClick, this), this.add(this.gift), this.gift.scale.x = this.x < 0 ? -1 : 1, this.shadow.scale.x = this.gift.scale.x, this.unlocked ? (this.gift.tweenScale = {
                x: this.gift.scale.x,
                y: this.gift.scale.y
            }, this.glow = G.makeImage(10, -20, "popup_lighht", .5, this), this.glow.update = function() {
                this.angle++
            }, this.glow.scale.setTo(.75), this.glow.blendMode = 1, this.glow.alpha = 0, this.giftGlow = G.makeImage(0, 0, "chest", .5, this.gift), this.giftGlow.blendMode = 1, this.giftGlow.alpha = .4, game.add.tween(this.giftGlow).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.jump()) : (this.gift.IMMEDIATE = !0, this.label = new G.LabelGroupT(b + "/" + this.chestData.req + "@star_small@", 0, 50, {
                font: "ComicSansBold",
                fontSize: "35px",
                fill: "#fdfbe4",
                stroke: "#73461c",
                strokeThickness: 5
            }, .5, 150), this.add(this.label))
        }, G.WorldMapChestLayer.Chest.prototype = Object.create(Phaser.Group.prototype), G.WorldMapChestLayer.Chest.prototype.onClick = function() {
            if (this.currentStars >= this.chestData.req) G.changeTexture(this.gift, "chest_open"), G.changeTexture(this.giftGlow, "chest_open"), this.opened = !0, G.saveState.data.mapChests[this.chestData.id] = !0, G.saveState.save(), this.gift.inputEnabled = !1, game.add.tween(this.glow).to({
                alpha: .2
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.onChestClicked.dispatch(), G.sb("pushWindow").dispatch(["mapChest", this.chestData.gifts]), game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 1e3).onComplete.add(function() {
                this.destroy()
            }, this);
            else {
                this.gift.inputEnabled = !1;
                var a = game.add.tween(this.gift).to({
                        y: -G.l(150)
                    }, 300, Phaser.Easing.Cubic.Out),
                    b = game.add.tween(this.gift).to({
                        y: 0
                    }, 300, Phaser.Easing.Circular.In);
                a.chain(b), a.start();
                var c = game.add.tween(this.gift).to({
                        angle: -15
                    }, 200, Phaser.Easing.Cubic.InOut),
                    d = game.add.tween(this.gift).to({
                        angle: 15
                    }, 375, Phaser.Easing.Sinusoidal.In),
                    e = game.add.tween(this.gift).to({
                        angle: 0
                    }, 50, Phaser.Easing.Cubic.InOut);
                e.onComplete.add(function() {
                    this.gift.inputEnabled = !0, this.gift.input.useHandCursor = !0
                }, this), c.chain(d, e), c.start()
            }
        }, G.WorldMapChestLayer.Chest.prototype.update = function() {
            this.glow && this.glow.update(), this.shadow.alpha = 1 + this.gift.y / 150;
            var a = -1 * (1 - this.gift.y / 150 * .1);
            this.shadow.scale.x = a * this.gift.scale.x * -1, this.shadow.scale.y = Math.abs(a);
            var b = this.state.map.y + this.y;
            this.visible = b < -1e3 || b > game.height + 1e3 ? !1 : !0
        }, G.WorldMapChestLayer.Chest.prototype.jump = function() {
            if (!this.opened) {
                var a = game.add.tween(this.gift).to({
                        y: -G.l(150)
                    }, 300, Phaser.Easing.Cubic.Out),
                    b = game.add.tween(this.gift).to({
                        y: 0
                    }, 300, Phaser.Easing.Circular.In);
                a.chain(b), a.start();
                var c = game.add.tween(this.gift).to({
                        angle: -15
                    }, 200, Phaser.Easing.Cubic.InOut),
                    d = game.add.tween(this.gift).to({
                        angle: 15
                    }, 375, Phaser.Easing.Sinusoidal.In),
                    e = game.add.tween(this.gift).to({
                        angle: 0
                    }, 50, Phaser.Easing.Cubic.InOut);
                c.chain(d, e), c.start(), game.time.events.add(2e3, this.jump, this)
            }
        }, G.WorldMapCloudDynamicLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.map = a, this.freeInstances = [], this.activeGatesData = JSON.parse(JSON.stringify(G.json.settings.gates)).filter(function(a) {
                return G.saveState.checkGate(a), G.json.levels[a.lvlNr - 1] ? (a.savedGateData = G.saveState.getGateData(a.id), !a.savedGateData.open) : void 0
            })
        }, G.WorldMapCloudDynamicLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapCloudDynamicLayer.prototype.update = function() {
            for (var a = this.children.length; a--;) this.children[a].update();
            for (var b = 0, c = this.activeGatesData.length; b < c; b++) {
                var d = this.activeGatesData[b],
                    e = this.y + G.json.levels[d.lvlNr - 1].mapY; - 500 < e && e < game.height + 500 ? d.instance || d.savedGateData.open || this.placeInstance(d) : d.instance && this.hideInstance(d)
            }
        }, G.WorldMapCloudDynamicLayer.prototype.placeInstance = function(a) {
            a.instance = this.getFreeInstance(), a.instance.init(a), this.add(a.instance)
        }, G.WorldMapCloudDynamicLayer.prototype.hideInstance = function(a) {
            a.instance.hide(), a.instance.parent.removeChild(a.instance), this.freeInstances.push(a.instance), a.instance = null
        }, G.WorldMapCloudDynamicLayer.prototype.getFreeInstance = function() {
            return this.freeInstances.shift() || new G.WorldMapCloudDynamicLayer.CloudInstance
        }, G.WorldMapCloudDynamicLayer.CloudInstance = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.cloud1 = G.makeImage(-450, 0, "cloud_1", .5, this), this.cloud1.scale.setTo(2), this.c1tween = game.add.tween(this.cloud1.scale).to({
                x: 2.1,
                y: 2.1
            }, 4e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.c1tween.timeline[0].dt = 2e3, this.cloud1.alpha = .95, this.cloud2 = G.makeImage(0, 50, "cloud_1", .5, this), this.cloud2.scale.setTo(2), this.c2tween = game.add.tween(this.cloud2.scale).to({
                x: 2.1,
                y: 2.1
            }, 8e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.c2tween.timeline[0].dt = 3e3, this.cloud2.alpha = .95, this.cloud3 = G.makeImage(450, 0, "cloud_1", .5, this), this.cloud3.scale.setTo(-2, 2), this.c3tween = game.add.tween(this.cloud3.scale).to({
                x: -2.1,
                y: 2.1
            }, 6e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.c3tween.timeline[0].dt = 1500, this.cloud3.alpha = .95
        }, G.WorldMapCloudDynamicLayer.CloudInstance.prototype = Object.create(Phaser.Group.prototype), G.WorldMapCloudDynamicLayer.CloudInstance.prototype.init = function(a) {
            this.savedGateData = a.savedGateData, this.y = G.json.levels[a.lvlNr - 1].mapY - 370, this.fading = !1, this.cloud1.x = -450, this.cloud1.y = 50, this.cloud2.x = 0, this.cloud2.y = 50, this.cloud2.alpha = .95, this.cloud3.x = 450, this.alpha = 1
        }, G.WorldMapCloudDynamicLayer.CloudInstance.prototype.hide = function() {
            this.fadingTweens && (this.fadingTweens.forEach(function(a) {
                a.stop()
            }), this.fadingTweens = null)
        }, G.WorldMapCloudDynamicLayer.CloudInstance.prototype.fadeAway = function() {
            if (!this.fading) {
                this.fading = !0;
                var a = game.add.tween(this.cloud1).to({
                        x: -900,
                        y: 50
                    }, 3e3, Phaser.Easing.Sinusoidal.Out, !0),
                    b = game.add.tween(this.cloud3).to({
                        x: 900,
                        y: 50
                    }, 3e3, Phaser.Easing.Sinusoidal.Out, !0),
                    c = game.add.tween(this.cloud2).to({
                        alpha: 0
                    }, 3e3, Phaser.Easing.Sinusoidal.Out, !0),
                    d = game.add.tween(this).to({
                        alpha: 0
                    }, 2e3, Phaser.Easing.Sinusoidal.In, !0, 1e3);
                this.fadingTweens = [a, b, c, d]
            }
        }, G.WorldMapCloudDynamicLayer.CloudInstance.prototype.update = function() {
            !this.fading && this.savedGateData.open && this.fadeAway()
        }, G.WorldMapCloudLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.init(), this.minGateY = null
        }, G.WorldMapCloudLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapCloudLayer.prototype.init = function() {
            G.json.settings.gates.forEach(function(a) {
                if (G.saveState.checkGate(a), G.json.levels[a.lvlNr - 1]) {
                    var b = G.saveState.getGateData(a.id);
                    b.open || this.add(new G.WorldMapCloudLayer.CloudWall(a.lvlNr - 1, b))
                }
            }, this)
        }, G.WorldMapCloudLayer.CloudWall = function(a, b) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.savedGateData = b, this.y = G.json.levels[a].mapY - 370, this.cloud1 = G.makeImage(-450, 0, "cloud_1", .5, this), this.cloud1.scale.setTo(2), game.add.tween(this.cloud1.scale).to({
                x: 2.1,
                y: 2.1
            }, 4e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0).timeline[0].dt = 2e3, this.cloud1.alpha = .95, this.cloud2 = G.makeImage(0, 50, "cloud_1", .5, this), this.cloud2.scale.setTo(2), game.add.tween(this.cloud2.scale).to({
                x: 2.1,
                y: 2.1
            }, 8e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0).timeline[0].dt = 3e3, this.cloud2.alpha = .95, this.cloud3 = G.makeImage(450, 0, "cloud_1", .5, this), this.cloud3.scale.setTo(-2, 2), game.add.tween(this.cloud3.scale).to({
                x: -2.1,
                y: 2.1
            }, 6e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0).timeline[0].dt = 1500, this.cloud3.alpha = .95, this.fading = !1
        }, G.WorldMapCloudLayer.CloudWall.prototype = Object.create(Phaser.Group.prototype), G.WorldMapCloudLayer.prototype.update = function() {
            for (var a = 0; a < this.length; a++) this.children.visible = 0 == a, this.children[a].update()
        }, G.WorldMapCloudLayer.CloudWall.prototype.fadeAway = function() {
            this.fading || (this.fading = !0, game.add.tween(this.cloud1).to({
                x: -900,
                y: 50
            }, 3e3, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.cloud3).to({
                x: 900,
                y: 50
            }, 3e3, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.cloud2).to({
                alpha: 0
            }, 3e3, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this).to({
                alpha: 0
            }, 2e3, Phaser.Easing.Sinusoidal.In, !0, 1e3).onComplete.add(function() {
                this.destroy()
            }, this))
        }, G.WorldMapCloudLayer.CloudWall.prototype.update = function() {
            !this.fading && this.savedGateData.open && this.fadeAway(), this.visible = -1e3 < this.state.map.y + this.y
        }, G.WorldMapGateLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.init(), this.minGateY = null, G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this)
        }, G.WorldMapGateLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapGateLayer.prototype.getMinY = function() {
            if (0 == this.children.length) return 1 / 0;
            for (var a = -1 / 0, b = 0; b < this.length; b++) this.children[b].y > a && (a = this.children[b].y);
            return -1 * a
        }, G.WorldMapGateLayer.prototype.unlockInput = function() {
            this.ignoreChildInput = !1, this.children.forEach(function(a) {
                a.ignoreChildInput = !1
            })
        }, G.WorldMapGateLayer.prototype.lockInput = function() {
            this.ignoreChildInput = !0, this.children.forEach(function(a) {
                a.ignoreChildInput = !0
            })
        }, G.WorldMapGateLayer.prototype.init = function() {
            G.json.settings.gates.forEach(function(a) {
                G.saveState.checkGate(a), G.json.levels[a.lvlNr - 1] && (G.saveState.getGateData(a.id).open || this.add(new G.WorldMapGateLayer.Gate(a)))
            }, this)
        }, G.WorldMapGateLayer.Gate = function(a) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.gate = a, this.lvlIndex = this.gate.lvlNr - 1, this.savedData = G.saveState.getGateData(a.id);
            var b = G.json.levels[this.lvlIndex];
            this.x = G.l(b.mapX), this.y = G.l(b.mapY), this.gateImg = G.makeImage(0, 20, "gate", [.5, 1], this), this.active = this.lvlIndex <= G.saveState.getLastPassedLevelNr(), this.active && (G.saveState.activateGate(a), this.unlockBtn = new G.Button(10, 30, "btn_chest_gate", function() {
                this.savedData.readyToOpen ? G.saveState.openGate(this.gate.id) : G.sb("pushWindow").dispatch(["gate", this.gate])
            }, this), this.unlockBtn.addTextLabel("font-beige-standard", G.txt("Unlock"), 40), this.unlockBtn.label.y = -2, this.add(this.unlockBtn), this.savedData.readyToOpen ? (this.unlockBtn.x = 0, this.unlockBtn.pulse()) : this.lockImg = G.makeImage(-73, 28, "lock", .5, this)), this.bursedParts = !1
        }, G.WorldMapGateLayer.Gate.prototype = Object.create(Phaser.Group.prototype), G.WorldMapGateLayer.Gate.prototype.update = function() {
            if (this.visible = -1e3 < this.state.map.y + this.y, this.savedData.open) {
                if (!this.bursedParts) {
                    this.bursedParts = !0;
                    for (var a = 0; a < 10; a++) G.sb("fxMap").dispatch("star", {
                        x: this.worldPosition.x,
                        y: this.worldPosition.y
                    })
                }
                this.alpha -= .05, this.alpha <= 0 && this.destroy()
            }
        }, G.WorldMapPack = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b);
            var c = G.json.settings.packs.find(function(a) {
                return G.saveState.isPackActive(a)
            });
            c && (this.initPack(c), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this), G.sb("onStarterPackBought").add(function() {
                game.add.tween(this).to({
                    y: 140
                }, 400, Phaser.Easing.Sinusoidal.Out, !0)
            }, this), G.saveState.data.sawPackTut || (this.tutHand = G.makeImage(0, 20, "tut_hand", 0, this), game.add.tween(this.tutHand).to({
                x: G.l(20),
                y: G.l(50)
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)), G.sb("onScreenResize").add(this.onResize, this), this.onResize())
        }, G.WorldMapPack.prototype = Object.create(Phaser.Group.prototype), G.WorldMapPack.prototype.onResize = function() {
            this.x = G.horizontal ? -200 : 60
        }, G.WorldMapPack.prototype.initPack = function(a) {
            this.activePack = a, this.currentStage = G.saveState.getPackStage(a), this.glow = G.makeImage(0, 0, "popup_lighht", .5, this), this.glow.update = function() {
                this.angle++
            }, this.glow.scale.setTo(.5), this.glow.alpha = .25, this.glow.blendMode = 1, this.giftBtn = new G.Button(-7, 0, "promo_pack", function() {
                G.saveState.data.sawPackTut = !0, G.saveState.save(), G.sb("pushWindow").dispatch(["pack", this.activePack]), this.tutHand && this.tutHand.destroy()
            }, this), this.add(this.giftBtn);
            var b = G.saveState.getPackSaveData(this.activePack.id),
                c = 60 * this.activePack.timeMinutes - (Date.now() - b.activationTime) / 1e3,
                d = "lbl_50%";
            this.currentStage.promo && (60 == this.currentStage.promo && (d = "lbl_60%"), 70 == this.currentStage.promo && (d = "lbl_70%")), this.lblPromo = G.makeImage(-35, 30, d, .5, this.giftBtn), this.timer = new G.Timer(0, 60, "font-num-orange", 30, 150, .5, .5, c), this.add(this.timer), this.timer.start(), this.update = function() {
                this.glow.angle++, G.saveState.isPackActive(this.activePack) || (this.alpha -= .05, this.alpha <= 0 && this.destroy())
            }
        }, G.WorldMapPack.prototype.unlockInput = function() {
            this.ignoreChildInput = !1
        }, G.WorldMapPack.prototype.lockInput = function() {
            this.ignoreChildInput = !0
        }, G.WorldMapPlayerAvatar = function(a) {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.onAnimFinished = new Phaser.Signal, this.avatar = sgSettings.config.user && sgSettings.config.user.avatar ? G.makeExtImage(0, 0, sgSettings.config.user.avatar, "avatar_m", 0, this, !1, function() {
                this.width = this.height = 80
            }) : G.makeImage(0, 0, "avatar_m", 0, this), this.avatar.anchor.setTo(.5), this.avatar.width = this.avatar.height = 80, this.pivotTween = game.add.tween(this.pivot).to({
                x: 10
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.add(this.avatar), this.frame = G.makeImage(0, 0, "avatar_frame_big", [.5, .52], this), this.frame.position = this.avatar.position, this.worldMap = a, this.position = a.position, this.state.lastLevelData ? this.animPosToLevel(this.state.lastLevelData.lvlNr, G.saveState.getLastPassedLevelNr()) : this.setPosToLevel(G.saveState.getLastPassedLevelNr())
        }, G.WorldMapPlayerAvatar.prototype = Object.create(Phaser.Group.prototype), G.WorldMapPlayerAvatar.prototype.setPosToLevel = function(a) {
            a = game.math.clamp(a, 0, G.json.levels.length - 1);
            var b = G.json.levels[a];
            this.avatar.x = b.mapX - 90, this.avatar.y = b.mapY - 10, this.onAnimFinished.dispatch()
        }, G.WorldMapPlayerAvatar.prototype.animPosToLevel = function(a, b) {
            a = game.math.clamp(a, 0, G.json.levels.length - 1), b = game.math.clamp(b, 0, G.json.levels.length - 1);
            var c = G.json.levels[a],
                d = G.json.levels[b];
            this.avatar.x = c.mapX - 90, this.avatar.y = c.mapY - 10, game.add.tween(this.avatar).to({
                x: d.mapX - 90,
                y: d.mapY - 10
            }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                this.onAnimFinished.dispatch()
            }, this)
        }, G.WorldMapSides = function(a) {
            Phaser.Group.call(this, game), this.worldMap = a, this.leftSide = game.make.tileSprite(-550, 0, 556, game.height, "map_margin"), this.leftSide.anchor.setTo(1, 0), this.add(this.leftSide), this.rightSide = game.make.tileSprite(550, 0, 556, game.height, "map_margin"), this.rightSide.anchor.setTo(1, 0), this.rightSide.scale.x = -1, this.add(this.rightSide), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.WorldMapSides.prototype = Object.create(Phaser.Group.prototype), G.WorldMapSides.prototype.postUpdate = function() {
            this.visible = 1100 < game.width, this.x = this.worldMap.x, this.leftSide.tilePosition.y = this.worldMap.y, this.rightSide.tilePosition.y = this.worldMap.y
        }, G.WorldMapSides.prototype.onResize = function() {
            this.leftSide.height = game.height, this.rightSide.height = game.height
        }, G.WorldMapSocialLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, sdkHandler.trigger("social.getFriends", {
                callback: function(a, b) {
                    a || this.initLabels(b)
                }
            }, this)
        }, G.WorldMapSocialLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapSocialLayer.prototype.initLabels = function(a) {
            if (a)
                for (var b = [], c = 0; c < a.length; c++) {
                    var d = a[c];
                    if (void 0 !== d.maxLevel && 3 !== b[d.maxLevel]) {
                        void 0 === b[d.maxLevel] && (b[d.maxLevel] = 0);
                        var e = 30 * b[d.maxLevel];
                        b[d.maxLevel]++;
                        var f = G.json.levels[d.maxLevel - 1];
                        this.add(new G.WorldMapSocialLayer.MapLabel(f.mapX, f.mapY, d.avatar, e))
                    }
                }
        }, G.WorldMapSocialLayer.MapLabel = function(a, b, c, d) {
            d = d || 0, Phaser.Image.call(this, game, G.l(a) + G.l(1 * (50 + d)), G.l(b - 20)), this.anchor.setTo(.5, .5), this.orgX = G.l(a) + G.l(1 * (70 + d)), this.tweenOffsetX = 0, this.scale.setTo(0);
            var e = this;
            this.avatar = G.makeExtImage(0, 0, c, null, .5, this, !1, function() {
                this.width = 50, this.height = 50, game.add.tween(e.scale).to({
                    x: 1,
                    y: 1
                }, 500, Phaser.Easing.Elastic.Out, !0)
            }), this.border = G.makeImage(0, 0, "avatar_frame", .5, this)
        }, G.WorldMapSocialLayer.MapLabel.prototype = Object.create(Phaser.Image.prototype), G.WorldMapSocialLayer.MapLabel.prototype.update = function() {
            this.x = this.orgX + this.tweenOffsetX * this.scale.x
        }, G.WorldMapStarterPack = function(a, b) {
            this.state = game.state.getCurrentState(), G.saveState.data.sawPackTut || this.state.makeBlackOverlay(), Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this), G.sb("onStarterPackBought").add(function() {
                this.giftBtn.inputEnabled = !1
            }, this), this.initPack(G.json.settings.starterPack), G.saveState.data.sawPackTut || (G.saveState.data.sawPackTut = !0, G.saveState.save(), this.tutHand = G.makeImage(0, 20, "tut_hand", 0, this), game.add.tween(this.tutHand).to({
                x: G.l(20),
                y: G.l(50)
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.WorldMapStarterPack.prototype = Object.create(Phaser.Group.prototype), G.WorldMapStarterPack.prototype.onResize = function() {
            this.x = G.horizontal ? -200 : 60
        }, G.WorldMapStarterPack.prototype.initPack = function(a) {
            this.activePack = a, this.glow = G.makeImage(0, 0, "popup_lighht", .5, this), this.glow.update = function() {
                this.angle++
            }, this.glow.scale.setTo(.5), this.glow.alpha = .25, this.glow.blendMode = 1, this.giftBtn = new G.Button(0, 0, "chest_sale", function() {
                G.sb("pushWindow").dispatch(["starterPack", this.activePack]), this.tutHand && this.tutHand.destroy()
            }, this), this.add(this.giftBtn);
            var b = G.saveState.getPackSaveData(this.activePack.id);
            this.activePack.timeMinutes, Date.now(), b.activationTime, this.update = function() {
                this.glow.angle++, G.saveState.data.starterPackBought && (this.alpha -= .05, this.alpha <= 0 && this.destroy())
            }
        }, G.WorldMapStarterPack.prototype.unlockInput = function() {
            this.ignoreChildInput = !1
        }, G.WorldMapStarterPack.prototype.lockInput = function() {
            this.ignoreChildInput = !0
        }, G.LevelBg = function() {
            Phaser.Image.call(this, game, 0, 0), this.anchor.setTo(.5), G.changeTexture(this, "background_1"), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize(), game.add.existing(this)
        }, G.LevelBg.prototype = Object.create(Phaser.Image.prototype), G.LevelBg.prototype.onScreenResize = function() {
            this.x = game.world.bounds.x + .5 * game.width, this.y = game.world.bounds.y + .5 * game.height, this.scale.setTo(1), this.width = Math.max(this.width, game.width), this.height = Math.max(this.height, game.height), this.width += 10, this.height += 10, this.updateCache()
        }, void 0 === G && (G = {}), G.Logo = function(a, b) {
            Phaser.Group.call(this, game), this.shine = G.makeImage(0, 0, "shine_title", [.5, .5], this), this.shine.scale.setTo(2), this.shine.update = function() {
                this.angle += .17
            }, this.wheel = G.makeImage(0, 0, "whell_1", .5, this), this.wheel.update = function() {
                this.angle += .22
            }, this.wheel2 = G.makeImage(0, 0, "whell_2", .5, this), this.wheel2.update = function() {
                this.angle += .12
            }, this.x = G.l(a), this.y = G.l(b), this.logo = G.makeImage(0, 0, "ja" === G.lang ? "logo-ja" : "logo", .5, this), game.add.tween(this.logo.scale).to({
                x: 1.05,
                y: 1.05
            }, 3e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)
        }, G.Logo.prototype = Object.create(Phaser.Group.prototype), G.Logo.prototype.startGlow = function() {
            game.add.tween(this.logoGlow).to({
                alpha: .5
            }, 1e3 + 1e3 * Math.random(), Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0).onComplete.add(function() {
                game.time.events.add(1500 + Math.floor(1500 * Math.random()), this.startGlow, this)
            }, this)
        }, G.Logo.prototype.startPartGlow = function() {
            this.glows[this.currentGlow++ % this.glows.length].start(), game.time.events.add(2e3 + Math.floor(1e3 * Math.random()), this.startPartGlow, this)
        }, G.MoreGamesBtn = function(a, b) {
            G.Button.call(this, a, b, "btn_moregames", function() {
                sdkHandler.trigger("moreGames")
            }), this.visible = sgSettings.config.moreGames.displayButton, game.add.existing(this)
        }, G.MoreGamesBtn.prototype = Object.create(G.Button.prototype), G.Modify = function() {
            return this === G ? new G.Modify : (Phaser.Group.call(this, game), (G.Modify.instance = this).onLevelObjChange = new Phaser.Signal, this.onCurrentObjChange = new Phaser.Signal, this.onObjDestroy = new Phaser.Signal, this.inputBlocker = new G.ModifyInputBlocked, this.add(this.inputBlocker), game.stage.disableVisibilityChange = !0, game.paused = !1, obj = game.state.getCurrentState(), obj === game.state.getCurrentState() && (game.state.getCurrentState().children = game.world.children), this.objectName = "WORLD", this.currentLevel = [], this.currentChildIndex = 0, this.currentPropIndex = 0, this.mods = [], this.gfx = game.add.graphics(), this.gfx.fixedToCamera = !0, this.add(this.gfx), this.obj = obj, this.propGroup = this.add(new G.ModifyPropGroup(this)), this.childrenPropNames = this.getChildrenPropNames(), this.buttonGroup = new G.ModifyButtonGroup, this.add(this.buttonGroup), this.childList = new G.ModifyChildList, this.add(this.childList), this.addKeyboardControlls(), this.bottomBar = this.add(new G.ModifyBottomBar), this.frameSelector = this.add(new G.ModifyFrameSelector), this.frameSelector.onFrameClicked.add(this.changeFrame, this), this.animationEditor = new G.ModifyAnimationEditor(this), this.add(this.animationEditor), this.removeCash = {}, this.codeGenerator = new G.ModifyCodeGenerator(this), this.defaultNewObjectsNames = !0, this.hideGroupTxt = !1, game.state.states.MODIFYEMPTYSTATE || game.state.add("MODIFYEMPTYSTATE", {
                create: function() {
                    new G.Modify
                }
            }), this.domLayer = new G.ModifyDOMLayer(this), game.input.onDown.add(this.processClick, this), void 0)
        }, G.Modify.prototype = Object.create(Phaser.Group.prototype), G.Modify.prototype.removeCashObjToString = function(a) {
            if (!this.removeCash[a]) return "";
            for (var b = "	REMOVED:", c = 0; c < this.removeCash[a].length; c++) b += "		" + this.removeCash[a][c] + "\n";
            return b
        }, G.Modify.prototype.removeObject = function() {
            console.log("removeObject");
            var a = this.getCurrentObject();
            if (console.log(a), a) {
                var b = this.currentLevel.join("/") || this.currentLevel[0] || game.state.current,
                    c = this.childrenPropNames[this.currentChildIndex].toString();
                a.___NEWOBJECT, this.removeCash[b] || (this.removeCash[b] = []), this.removeCash[b].push(c), a.destroy(), this.refreshLevel()
            }
        }, G.Modify.prototype.refreshLevel = function() {
            this.currentLevel = this.currentLevel, this.childrenPropNames = this.getChildrenPropNames(), this.onLevelObjChange.dispatch()
        }, G.Modify.prototype.addToGroup = function(a, b) {
            var c;
            a != game.world && a != game.state.getCurrentState() || (a = game.world, b.x = game.camera.x + .5 * game.width, b.y = game.camera.y + .5 * game.height), a.add ? a.add(b) : a.addChild && a.addChild(b);
            var d = this.getCurrentLevelObject();
            (c = this.defaultNewObjectsNames ? "child_" + d.children.length : prompt("Enter object name")) && (b.___LABEL = c, a == game.world ? game.state.getCurrentState()[c] = b : a[c] = b)
        }, G.Modify.prototype.addGroup = function() {
            var a = this.getCurrentLevelObject(),
                b = game.make.group();
            b.___NEWOBJECT = !0, this.addToGroup(a, b), this.refreshLevel()
        }, G.Modify.prototype.addImage = function() {
            var a = this.getCurrentLevelObject(),
                b = new G.Image(0, 0, "__missing", .5, null);
            return b.___NEWOBJECT = !0, this.addToGroup(a, b), this.refreshLevel(), b
        }, G.Modify.prototype.addButton = function() {
            var a = this.getCurrentLevelObject(),
                b = new G.Button(0, 0, "__missing", function() {}, this);
            b.___NEWOBJECT = !0, this.addToGroup(a, b), this.refreshLevel()
        }, G.Modify.prototype.addOneLineText = function() {
            var a = this.getCurrentLevelObject(),
                b = Object.keys(game.cache._cache.bitmapFont),
                c = new G.OneLineText(0, 0, b[0], "TEXT", 50, 300, .5, .5);
            c.cacheAsBitmap = !1, this.addToGroup(a, c), this.refreshLevel()
        }, G.Modify.prototype.addMultiLineText = function() {
            var a = this.getCurrentLevelObject(),
                b = Object.keys(game.cache._cache.bitmapFont),
                c = new G.MultiLineText(0, 0, b[0], "TEXT", 50, 300, 300, "center", .5, .5);
            c.cacheAsBitmap = !1, this.addToGroup(a, c), this.refreshLevel()
        }, G.Modify.prototype.update = function() {
            this.updateKeyboard(), this.redrawGfx(), this.propGroup.update(), this.hideGroupTxt ? (this.childList.hideList(), this.propGroup.cameraOffset.y = this.childList.cameraOffset.y + 50) : (this.childList.showList(), this.propGroup.cameraOffset.y = this.childList.cameraOffset.y + this.childList.height + 30), this.frameSelector.update(), this.bottomBar.x = game.world.bounds.x, this.bottomBar.y = game.world.bounds.y + game.height - this.bottomBar.height;
            for (var a = 0; a < this.children.length; a++) this.children[a].update()
        }, G.Modify.prototype.getChildrenPropNames = function() {
            game.world.bringToTop(this);
            var a = [],
                b = this.getCurrentLevelObject(),
                c = b;
            b === game.world && (c = game.state.getCurrentState());
            for (var d = 0; d < b.children.length; d++) {
                var e = !1,
                    f = b.children[d];
                if (f !== this)
                    if (f.___LABEL) a.push([f.___LABEL]);
                    else {
                        for (var g in c)
                            if ("children" != g && "cursor" != g && (e || f !== c[g] || (e = !0, f.___LABEL = g, a.push([g])), Array.isArray(c[g]) && "children" !== g))
                                for (var h = 0; h < c[g].length; h++) e || f !== c[g][h] || (e = !0, a.push([g, h]));
                        e || a.push(["children", d])
                    }
                else a.push(["G.MODIFY-EDITOR"])
            }
            return a
        }, G.Modify.prototype.getCurrentObject = function() {
            return this.getCurrentLevelObject().children[this.currentChildIndex]
        }, G.Modify.prototype.changeFrame = function(a) {
            console.log(a);
            var b = this.getCurrentObject();
            this.saveInitPropValue("frameName", a), b.loadTexture && G.changeTexture(b, a)
        }, G.Modify.prototype.getCurrentLevelObject = function() {
            for (var a = this.obj, b = 0; b < this.currentLevel.length; b++) a = a[this.currentLevel[b]];
            return a
        }, G.Modify.prototype.redrawGfx = function() {
            this.gfx.clear();
            var a = this.getCurrentLevelObject();
            if (a !== game.state.getCurrentState()) {
                var b = a.getLocalBounds();
                this.gfx.lineStyle(3, 16711680, .2), this.gfx.drawRect(a.worldPosition.x + b.x, a.worldPosition.y + b.y, b.width, b.height), this.gfx.beginFill(0, .5), this.gfx.drawRect(a.worldPosition.x - 10, a.worldPosition.y - 10, 20, 20)
            }
            this.gfx.beginFill(0, 0), this.childrenPropNames.forEach(function(a, b) {
                var c = b == this.currentChildIndex;
                this.gfx.lineStyle(c ? 3 : 1, 255, c ? 1 : .2);
                var d = this.getCurrentLevelObject().children[b];
                if (d) {
                    var e = d.getBounds(),
                        f = d.getLocalBounds();
                    this.gfx.drawRect(d.worldPosition.x + f.x * d.scale.x, d.worldPosition.y + f.y * d.scale.y, e.width * d.scale.x, e.height * d.scale.y), c && d.maxUserWidth && !d.maxUserHeight ? (this.gfx.lineStyle(2, 65280, .5), this.gfx.drawRect(d.worldPosition.x - d.anchor.x * d.maxUserWidth, d.worldPosition.y - d.anchor.y * d.height, d.maxUserWidth, d.height)) : c && d.maxUserWidth && d.maxUserHeight && (this.gfx.lineStyle(2, 65280, .5), this.gfx.drawRect(d.worldPosition.x - d.anchor.x * d.maxUserWidth, d.worldPosition.y - d.anchor.y * d.maxUserHeight, d.maxUserWidth, d.maxUserHeight))
                }
            }, this), this.getCurrentObject()
        }, G.Modify.prototype.addKeyboardControlls = function() {
            this.keys = game.input.keyboard.addKeys({
                Q: Phaser.Keyboard.Q,
                A: Phaser.Keyboard.A,
                E: Phaser.Keyboard.E,
                UP: Phaser.Keyboard.UP,
                ONE: Phaser.Keyboard.ONE,
                TWO: Phaser.Keyboard.TWO,
                DOWN: Phaser.Keyboard.DOWN,
                RIGHT: Phaser.Keyboard.RIGHT,
                LEFT: Phaser.Keyboard.LEFT,
                ALT: Phaser.Keyboard.ALT,
                Z: Phaser.Keyboard.Z,
                X: Phaser.Keyboard.X,
                C: Phaser.Keyboard.C,
                U: Phaser.Keyboard.U,
                PLUS: 107,
                MINUS: 109,
                ESC: Phaser.Keyboard.ESC,
                NUM8: 104,
                NUM5: 101,
                NUM4: 100,
                NUM6: 102,
                NUM2: 98,
                NUM7: 103,
                NUM9: 105,
                NUMSTAR: 106,
                SPACE: Phaser.Keyboard.SPACEBAR,
                V: Phaser.Keyboard.V,
                L: Phaser.Keyboard.L,
                I: Phaser.Keyboard.I,
                P: Phaser.Keyboard.P,
                O: Phaser.Keyboard.O,
                M: Phaser.Keyboard.M,
                DEL: Phaser.Keyboard.DELETE,
                sqBracketOpen: 219,
                sqBracketClose: 221,
                SHIFT: Phaser.Keyboard.SHIFT
            }), this.keys.sqBracketOpen.onDown.add(function() {
                this.keys.SHIFT.isDown ? this.objToBottom() : this.objMoveDown()
            }, this), this.keys.sqBracketClose.onDown.add(function() {
                this.keys.SHIFT.isDown ? this.objToTop() : this.objMoveUp()
            }, this), this.keys.frameCounter = 0, this.keys.L.onDown.add(function() {
                var a = this.getCurrentLevelObject(),
                    b = this.getCurrentObject();
                this.domLayer.openInputDiv((b.___LABEL || "obj") + " | label", b.___LABEL || "", function(c) {
                    void 0 === a[c] && (b.___LABEL && delete a[b.___LABEL], (a[c] = b).___LABEL = c, this.refreshLevel())
                }, this, "string")
            }, this), this.keys.Q.onDown.add(function() {
                this.changeCurrentChildrenIndex(this.currentChildIndex + 1)
            }, this), this.keys.A.onDown.add(function() {
                console.log("children -1"), this.changeCurrentChildrenIndex(this.currentChildIndex - 1)
            }, this), this.keys.E.onDown.add(function() {
                this.exportChanges()
            }, this), this.keys.NUM5.onDown.add(function() {
                var a = this.getCurrentObject();
                a && (a.scale.setTo(1), a.angle = 0, a.alpha = 1, a.visible = !0, a.anchor.setTo(.5))
            }, this), this.keys.TWO.onDown.add(function() {
                0 < this.getCurrentObject().children.length && (this.currentLevel = this.currentLevel.concat(this.childrenPropNames[this.currentChildIndex]), this.childrenPropNames = this.getChildrenPropNames(), this.currentChildIndex = 0, this.makeTexts())
            }, this), this.keys.ONE.onDown.add(function() {
                0 != this.currentLevel.length && (this.currentLevel = "number" == typeof this.currentLevel[this.currentLevel.length - 1] ? this.currentLevel.splice(0, this.currentLevel.length - 2) : this.currentLevel.splice(0, this.currentLevel.length - 1), this.childrenPropNames = this.getChildrenPropNames(), this.currentChildIndex = 0, this.makeTexts())
            }, this), this.keys.ESC.onDown.add(this.turnOff, this), this.keys.V.onDown.add(function() {
                this.alpha = 1 == this.alpha ? .1 : 1
            }, this), this.keys.O.onDown.add(function() {
                var a = this.getCurrentObject();
                a instanceof Phaser.Group && (a.___CONSTRUCTOR = !0)
            }, this), this.keys.P.onDown.add(function() {
                var a = this.getCurrentObject();
                this.codeGenerator.start(a)
            }, this), this.keys.C.onDown.add(function() {
                var a = game.input.activePointer,
                    b = this.addImage();
                this.setNewCurrentChildren(b), this.moveCurrentObjectToWorldPos(a.x, a.y)
            }, this), this.keys.I.onDown.add(function() {
                void 0 === this.pressCounterI && (this.pressCounterI = 0), this.pressCounterI++, 3 == this.pressCounterI && game.state.start("MODIFYEMPTYSTATE"), game.time.events.add(1e3, function() {
                    this.pressCounterI = 0
                }, this)
            }, this), this.keys.DEL.onDown.add(this.removeObject, this), this.keys.NUMSTAR.onDown.add(function() {
                console.log("numstar"), this.frameSelector.opened ? this.frameSelector.close() : this.frameSelector.open()
            }, this), this.keys.U.onDown.add(function() {
                this.hideGroupTxt = !this.hideGroupTxt
            }, this)
        }, G.Modify.prototype.turnOff = function() {
            if (void 0 === this.escPressed && (this.escPressed = 0), this.escPressed++, game.time.events.add(2e3, function() {
                    this.escPressed = 0
                }, this), !(this.escPressed < 5)) {
                for (key in this.keys) this.keys[key].onDown && this.keys[key].onDown.removeAll();
                this.gfx.destroy(), this.levelTxt.destroy(), this.propGroup.destroy(), this.groupTxt.destroy(), this.destroy()
            }
        }, G.Modify.prototype.modifyCurrentObjProp = function(a, b) {
            var c = this.getCurrentObject();
            this.saveInitPropValue(a, b), G.Utils.setObjProp(c, a, b)
        }, G.Modify.prototype.saveInitPropValue = function(a, b) {
            var c = this.getCurrentObject();
            Array.isArray(a) && (a = a.join(".")), G.Utils.getObjProp(c, a) !== b && (c.___initState || (c.___initState = {}), void 0 === c.___initState[a] && (c.___initState[a] = G.Utils.getObjProp(c, a)))
        }, G.Modify.prototype.updateKeyboard = function() {
            var a = this.getCurrentObject();
            if (a) {
                this.keys.frameCounter++;
                var b = 1,
                    c = !0;
                this.keys.Z.isDown && this.keys.frameCounter % 5 != 0 && (c = !1), this.keys.X.isDown && (b = 5), this.keys.C.isDown && (b = 20), c && this.keys.UP.isDown && this.modifyCurrentObjProp("y", a.y - b), c && this.keys.DOWN.isDown && this.modifyCurrentObjProp("y", a.y + b), c && this.keys.LEFT.isDown && this.modifyCurrentObjProp("x", a.x - b), c && this.keys.RIGHT.isDown && this.modifyCurrentObjProp("x", a.x + b), b = .025, this.keys.X.isDown && (b = .05), this.keys.C.isDown && (b = .1), c && this.keys.NUM8.isDown && this.modifyCurrentObjProp("scale.y", a.scale.y + b), c && this.keys.NUM2.isDown && (this.modifyCurrentObjProp("scale.y", a.scale.y - b), a.scale.y -= b), c && this.keys.NUM4.isDown && this.modifyCurrentObjProp("scale.x", a.scale.x - b), c && this.keys.NUM6.isDown && this.modifyCurrentObjProp("scale.x", a.scale.x + b), c && this.keys.PLUS.isDown && (this.modifyCurrentObjProp("scale.x", a.scale.x + b), this.modifyCurrentObjProp("scale.y", a.scale.y + b)), c && this.keys.MINUS.isDown && (this.modifyCurrentObjProp("scale.x", a.scale.x - b), this.modifyCurrentObjProp("scale.y", a.scale.y - b)), b = 1, this.keys.X.isDown && (b = 2), this.keys.C.isDown && (b = 5), c && this.keys.NUM7.isDown && this.modifyCurrentObjProp("angle", a.angle - b), c && this.keys.NUM9.isDown && this.modifyCurrentObjProp("angle", a.angle + b), this.keys.SPACE.isDown && (this.modifyCurrentObjProp("x", 5 * Math.floor(a.x / 5)), this.modifyCurrentObjProp("y", 5 * Math.floor(a.y / 5)), this.modifyCurrentObjProp("scale.x", .025 * Math.floor(a.scale.x / .025)), this.modifyCurrentObjProp("scale.y", .025 * Math.floor(a.scale.y / .025)), this.modifyCurrentObjProp("angle", Math.floor(a.angle)))
            }
        }, G.Modify.prototype.currentLevelGoUp = function() {
            0 != this.currentLevel.length && (this.currentLevel = "number" == typeof this.currentLevel[this.currentLevel.length - 1] ? this.currentLevel.splice(0, this.currentLevel.length - 2) : this.currentLevel.splice(0, this.currentLevel.length - 1), this.childrenPropNames = this.getChildrenPropNames(), this.currentChildIndex = 0, this.onLevelObjChange.dispatch())
        }, G.Modify.prototype.currentLevelGoDown = function(a) {
            console.log(arguments), console.log(this.childrenPropNames[a]), this.currentLevel = this.currentLevel.concat(this.childrenPropNames[a]), this.childrenPropNames = this.getChildrenPropNames(), this.currentChildIndex = 0, this.onLevelObjChange.dispatch()
        }, G.Modify.prototype.changeCurrentChildrenIndex = function(a) {
            this.currentChildIndex = a, this.currentChildIndex < 0 && (this.currentChildIndex = this.childrenPropNames.length - 1), this.currentChildIndex >= this.childrenPropNames.length && (this.currentChildIndex = 0), this.onCurrentObjChange.dispatch()
        }, G.Modify.prototype.setNewCurrentChildren = function(a) {
            var b = this.getCurrentLevelObject().children.indexOf(a); - 1 != b && this.changeCurrentChildrenIndex(b)
        }, G.Modify.prototype.childPropChange = function(a) {
            var b = this.currentLevel,
                c = this.currentChildIndex;
            this.currentLevel = a || [];
            for (var d = this.currentLevel.join("/") || this.currentLevel[0] || game.state.current, e = this.removeCashObjToString(d), f = "", g = this.getChildrenPropNames(), h = 0; h < g.length; h++) {
                this.currentChildIndex = h;
                var i = this.getCurrentObject();
                if (i !== this) {
                    g[h].toString();
                    var j = i.___NEWOBJECT,
                        k = i.constructor === G.OneLineText || i.constructor === G.MultiLineText;
                    j && (f += "NEW OBJECT \n"), i.___initState && (f += "	" + g[h] + "\n", Object.keys(i.___initState).forEach(function(a) {
                        f += "	" + a + ":  " + G.Utils.getObjProp(i, a) + "\n"
                    }, this), i.___initState = void 0), !k && (j || i.children && 0 < i.children.length) && this.childPropChange(this.currentLevel.concat(g[h]))
                }
            }(0 < f.length || 0 < e.length) && (e.length, f.length, this.export += d + "\n" + e + f), this.currentChildIndex = c, this.currentLevel = b
        }, G.Modify.prototype.exportChanges = function() {
            this.export = "", this.childPropChange(), this.export ? (this.export = this.objectName + "\n" + this.export, G.Utils.copyToClipboard(this.export), console.log(this.export)) : console.log("NO CHANGES TO EXPORT")
        }, G.Modify.prototype.processClick = function() {
            var a = game.input.activePointer;
            this.keys.M.isDown && this.moveCurrentObjectToWorldPos(a.x, a.y)
        }, G.Modify.prototype.moveCurrentObjectToWorldPos = function(a, b) {
            var c = this.getCurrentObject();
            if (c) {
                c.updateTransform();
                var d = a - c.worldPosition.x,
                    e = b - c.worldPosition.y,
                    f = new Phaser.Point(d, e),
                    g = new Phaser.Point(a, b);
                f.normalize();
                for (var h = c.worldPosition.distance(g);;) {
                    var i = h;
                    if (c.x += f.x, c.y += f.y, c.updateTransform(), i < (h = c.worldPosition.distance(g))) break
                }
                c.x = Math.round(c.x), c.y = Math.round(c.y)
            }
        }, G.Modify.prototype.addMouseWheel = function() {
            game.input.mouse.mouseWheelCallback = function() {
                var b = this.getCurrentLevelObject();
                b && b !== game.world && (b.y += 150 * game.input.mouse.wheelDelta)
            }.bind(this)
        }, G.Modify.prototype.exportLvlAsString = function() {
            for (var a = [], b = this.getCurrentLevelObject(), c = 0; c < b.children.length; c++) {
                var d = b.children[c];
                if (d instanceof Phaser.Image) {
                    var e = null;
                    "string" == typeof d.frameName && (e = -1 == d.frameName.indexOf("/") ? d.frameName : d.key);
                    var f = {
                        x: d.x,
                        y: d.y,
                        frame: e,
                        anchor: [d.anchor.x, d.anchor.y],
                        scale: [d.scale.x, d.scale.y],
                        angle: d.angle
                    };
                    d.___LABEL && (f.label = d.___LABEL), d.___DATA && (f.data = d.___DATA), a.push(f)
                }
            }
            console.log(JSON.stringify(a)), G.Utils.copyToClipboard(JSON.stringify(a))
        }, G.Modify.prototype.objToTop = function() {
            var a = this.getCurrentObject();
            a && (this.getCurrentLevelObject().bringToTop(a), this.refreshLevel(), this.setNewCurrentChildren(a))
        }, G.Modify.prototype.objMoveUp = function() {
            var a = this.getCurrentObject();
            a && (this.getCurrentLevelObject().moveUp(a), this.refreshLevel(), this.setNewCurrentChildren(a))
        }, G.Modify.prototype.objMoveDown = function() {
            var a = this.getCurrentObject();
            a && (this.getCurrentLevelObject().moveDown(a), this.refreshLevel(), this.setNewCurrentChildren(a))
        }, G.Modify.prototype.objToBottom = function() {
            var a = this.getCurrentObject();
            a && (this.getCurrentLevelObject().sendToBack(a), this.refreshLevel(), this.setNewCurrentChildren(a))
        }, G.ModifyAnimationEditor = function() {
            Phaser.Group.call(this, game), this.modify = G.Modify.instance, this.tl = new G.ModifyAnimationTL, this.tl.x = 100, this.add(this.tl), this.fw = new G.ModifyAnimationFrameWindow, this.fw.x = -250, this.add(this.fw), this.tl.onFrameSelected.add(this.fw.refresh, this.fw), this.fw.onChange.add(function(a, b) {
                console.log("fw onchange"), this.tl.redrawTl(), a.updateAnimation(b)
            }, this), this.tl.changeTlPxWidth(800), this.visible = !1, this.modify.onLevelObjChange.add(function() {
                var a = this.modify.getCurrentLevelObject();
                a.ANIMATIONELEMENT ? this.open(a) : this.close()
            }, this)
        }, G.ModifyAnimationEditor.prototype = Object.create(Phaser.Group.prototype), G.ModifyAnimationEditor.prototype.open = function(a) {
            this.visible = !0, this.tl.open(a), this.fw.refresh(a, 0)
        }, G.ModifyAnimationEditor.prototype.close = function() {
            this.visible = !1
        }, G.ModifyAnimationFrameGroup = function(a, b) {
            Phaser.Group.call(this, game), this.x = a, this.y = b, this.active = !1, this.currentObj = null, this.currentKeyFrame = null, this.currentFrameNr = 0, this.style = {
                font: "Verdana",
                fontSize: 13,
                fontWeight: "bold"
            }, this.onOffBtn = game.add.text(0, 0, "off", this.style), this.onOffBtn.inputEnabled = !0, this.onOffBtn.hitArea = new Phaser.Rectangle(0, 0, this.onOffBtn.width, this.onOffBtn.height), this.onOffBtn.events.onInputDown.add(this.onOff, this), this.propValue = game.add.text(280, 0, "---", this.style), this.propValue.anchor.x = 1, this.addMultiple([this.onOffBtn, this.propValue]), this.onChange = new Phaser.Signal
        }, G.ModifyAnimationFrameGroup.prototype = Object.create(Phaser.Group.prototype), G.ModifyAnimationFrameGroup.prototype.onOff = function() {
            if (0 != this.currentFrameNr) {
                if (this.active) {
                    this.active = !1, this.alpha = .5, this.onOffBtn.setText("off");
                    var a = this.currentObj.frameTL.indexOf(this.currentKeyFrame);
                    this.currentObj.frameTL.splice(a, 1)
                } else {
                    this.active = !0, this.alpha = 1, this.onOffBtn.setText("on");
                    for (var b = {
                            f: this.currentFrameNr,
                            v: G.Utils.getObjProp(this.currentObj.SPR, "frameName")
                        }, c = this.currentFrameNr, d = this.currentObj.frameTL, e = 0, f = 0; f < d.length; f++) d[f].f < c && e++;
                    d.splice(e, 0, b)
                }
                this.refresh(this.currentObj, this.currentFrameNr)
            }
        }, G.ModifyAnimationFrameGroup.prototype.update = function() {
            if (this.currentObj.playing) this.refresh(this.currentObj, this.currentObj.frameCounter);
            else if (this.currentObj) {
                var a = G.Utils.getObjProp(this.currentObj.SPR, "frameName") || G.Utils.getObjProp(this.currentObj.SPR, "key");
                a.indexOf("/") && (a = a.slice(a.lastIndexOf("/") + 1)), null == this.currentKeyFrame && (a != this.valAtRefresh ? (this.propValue.fill = "red", this.alpha = 1) : (this.alpha = .5, this.propValue.fill = "black")), !this.currentObj.playing && this.currentKeyFrame && this.currentKeyFrame.v !== a && (this.currentKeyFrame.v = a), this.propValue.setText(a)
            } else this.propValue.setText("---")
        }, G.ModifyAnimationFrameGroup.prototype.refresh = function(a, b) {
            this.currentObj = a, this.currentObj.currentAnimationName && (this.currentKeyFrame = a.getKeyFrameAt(a.frameTL, b), this.currentFrameNr = b, this.propValue.fill = "black", this.valAtRefresh = G.Utils.getObjProp(this.currentObj.SPR, "frameName"), this.currentKeyFrame ? (this.active = !0, this.alpha = 1, this.onOffBtn.setText("on"), console.log("frameGroup refresh"), console.log(this.currentObj.getTextureFrameValue(a.frameTL, b)), this.propValue.setText(this.currentObj.getTextureFrameValue(a.frameTL, b) || "---")) : (this.onOffBtn.setText("off"), this.active = !1, this.alpha = .5, this.propValue.setText("---")))
        }, G.ModifyAnimationFrameWindow = function() {
            Phaser.Group.call(this, game), this.onChange = new Phaser.Signal, this.gfx = game.add.graphics(), this.gfx.inputEnabled = !0, this.add(this.gfx), this.gfx.beginFill(14540253), this.gfx.drawRect(0, 0, 300, 500), this.style = {
                font: "Verdana",
                fontSize: 13,
                fontWeight: "bold"
            }, this.currentAnimationTxt = game.add.text(10, 10, "", this.style), this.add(this.currentAnimationTxt), this.currentAnimationTxt.inputEnabled = !0, this.currentAnimationTxt.events.onInputDown.add(function() {
                this.changeAnimation()
            }, this), this.addAnimationBtn = game.add.text(170, 10, "+", this.style), this.add(this.addAnimationBtn), this.addAnimationBtn.inputEnabled = !0, this.addAnimationBtn.events.onInputDown.add(this.addNewAnimation, this), this.renameAnimationBtn = game.add.text(200, 10, "R", this.style), this.add(this.renameAnimationBtn), this.renameAnimationBtn.inputEnabled = !0, this.renameAnimationBtn.events.onInputDown.add(this.renameAnimation, this), this.removeAnimationBtn = game.add.text(230, 10, "-", this.style), this.add(this.removeAnimationBtn), this.removeAnimationBtn.inputEnabled = !0, this.removeAnimationBtn.events.onInputDown.add(this.removeAnimation, this), this.frameNr = game.add.text(290, 10, "", this.style), this.frameNr.anchor.x = 1, this.add(this.frameNr), this.frameGroup = new G.ModifyAnimationFrameGroup(10, 50), this.add(this.frameGroup), this.propGroups = [new G.ModifyAnimationPropGroup(10, 70, "alpha", "#43c9e7"), new G.ModifyAnimationPropGroup(10, 90, "x", "#e08040"), new G.ModifyAnimationPropGroup(10, 110, "y", "#d8ff30"), new G.ModifyAnimationPropGroup(10, 130, "angle", "#072ba0"), new G.ModifyAnimationPropGroup(10, 150, "scale.x", "#6c0674"), new G.ModifyAnimationPropGroup(10, 170, "scale.y", "#d34ed9"), new G.ModifyAnimationPropGroup(10, 190, "anchor.x"), new G.ModifyAnimationPropGroup(10, 210, "anchor.y")], this.propGroups.forEach(function(a) {
                a.onChange.add(this.onChange.dispatch, this.onChange)
            }, this), this.addMultiple(this.propGroups)
        }, G.ModifyAnimationFrameWindow.prototype = Object.create(Phaser.Group.prototype), G.ModifyAnimationFrameWindow.prototype.update = function() {
            this.currentObj && (this.propGroups.forEach(function(a) {
                a.update()
            }, this), this.frameGroup.update())
        }, G.ModifyAnimationFrameWindow.prototype.loadFrame = function(a, b) {
            this.currentObj = a, this.labelObjTxt.setText(a.LABEL || "obj"), this.frameNr.setText(b)
        }, G.ModifyAnimationFrameWindow.prototype.refresh = function(a, b) {
            this.propGroups.forEach(function(c) {
                c.refresh(a, b)
            }), this.frameGroup.refresh(a, b), this.frameNr.setText(b), this.currentFrameNr = b, this.currentObj = a, this.currentAnimationTxt.setText(this.currentObj.currentAnimationName || "------")
        }, G.ModifyAnimationFrameWindow.prototype.changeAnimation = function(a) {
            if (this.currentObj) {
                var b = Object.keys(this.currentObj.dataAnimation);
                if (console.log(JSON.stringify(b)), a) this.currentObj.changeAnimationData(a);
                else if (this.currentObj.currentAnimationName) {
                    var c = b.indexOf(this.currentObj.currentAnimationName),
                        d = (c + 1) % b.length;
                    console.log(c, d), this.currentObj.changeAnimationData(b[d])
                } else this.currentObj.changeAnimationData(b[0]);
                this.refresh(this.currentObj, this.currentFrameNr), this.onChange.dispatch(this.currentObj, 0)
            }
        }, G.ModifyAnimationFrameWindow.prototype.addNewAnimation = function() {
            if (this.currentObj) {
                for (var a = Object.keys(this.currentObj.dataAnimation), b = "newAnimation", c = 0; - 1 !== a.indexOf(b + c);) c++;
                this.currentObj.dataAnimation[b + c] = {
                    eventTL: [],
                    frameTL: [{
                        f: 0,
                        v: null
                    }],
                    propTLS: {
                        alpha: [{
                            f: 0,
                            v: 1
                        }],
                        x: [{
                            f: 0,
                            v: 0
                        }],
                        y: [{
                            f: 0,
                            v: 0
                        }],
                        angle: [{
                            f: 0,
                            v: 0
                        }],
                        "scale.x": [{
                            f: 0,
                            v: 1
                        }],
                        "scale.y": [{
                            f: 0,
                            v: 1
                        }],
                        "anchor.x": [{
                            f: 0,
                            v: .5
                        }],
                        "anchor.y": [{
                            f: 0,
                            v: .5
                        }]
                    }
                }, this.changeAnimation(b + c)
            }
        }, G.ModifyAnimationFrameWindow.prototype.removeAnimation = function() {
            this.currentObj && this.currentObj.currentAnimationName && 1 != Object.keys(this.currentObj.dataAnimation).length && confirm("delete " + this.currentObj.currentAnimationName + "?") && (delete this.currentObj.dataAnimation[this.currentObj.currentAnimationName], this.changeAnimation())
        }, G.ModifyAnimationFrameWindow.prototype.renameAnimation = function() {
            this.currentObj && this.currentObj.currentAnimationName && G.Modify.instance.domLayer.openInputDiv(this.currentObj.currentAnimationName, this.currentObj.currentAnimationName, function(a) {
                var b = this.currentObj.currentAnimationName,
                    c = this.currentObj.currentAnimationData;
                delete this.currentObj.dataAnimation[b], this.currentObj.dataAnimation[a] = c, this.changeAnimation(a)
            }, this, "string")
        }, G.ModifyAnimationPropGroup = function(a, b, c, d) {
            Phaser.Group.call(this, game), this.x = a, this.y = b, this.propKey = c, this.active = !1, this.currentObj = null, this.currentKeyFrame = null, this.currentFrameNr = 0, this.style = {
                font: "Verdana",
                fontSize: 13,
                fontWeight: "bold"
            }, this.easings = ["Back", "Bounce", "Circular", "Cubic", "Elastic", "Exponential", "Linear", "Quadratic", "Quartic", "Quintic", "Sinusoidal"], this.onOffBtn = game.add.text(0, 0, "off", this.style), this.onOffBtn.inputEnabled = !0, this.onOffBtn.hitArea = new Phaser.Rectangle(0, 0, this.onOffBtn.width, this.onOffBtn.height), this.onOffBtn.events.onInputDown.add(this.onOff, this), this.label = game.add.text(30, 0, c, this.style), d && this.label.addColor(d, 0), this.easingLabel0 = game.add.text(120, 0, "", this.style), this.easingLabel0.inputEnabled = !0, this.easingLabel0.hitArea = new Phaser.Rectangle(0, 0, 80, this.easingLabel0.height), this.easingLabel0.events.onInputDown.add(this.changeEasing0, this), this.easingLabel1 = game.add.text(200, 0, "", this.style), this.easingLabel1.inputEnabled = !0, this.easingLabel1.hitArea = new Phaser.Rectangle(0, 0, 50, this.easingLabel1.height), this.easingLabel1.events.onInputDown.add(this.changeEasing1, this), this.propValue = game.add.text(280, 0, "", this.style), this.propValue.anchor.x = 1, this.addMultiple([this.label, this.onOffBtn, this.easingLabel0, this.easingLabel1, this.propValue]), this.onChange = new Phaser.Signal
        }, G.ModifyAnimationPropGroup.prototype = Object.create(Phaser.Group.prototype), G.ModifyAnimationPropGroup.prototype.onOff = function() {
            if (0 != this.currentFrameNr) {
                if (this.active) {
                    this.active = !1, this.alpha = .5, this.onOffBtn.setText("off");
                    var a = this.currentObj.propTLS[this.propKey].indexOf(this.currentKeyFrame);
                    this.currentObj.propTLS[this.propKey].splice(a, 1)
                } else {
                    this.active = !0, this.alpha = 1, this.onOffBtn.setText("on");
                    for (var b = {
                            f: this.currentFrameNr,
                            v: G.Utils.getObjProp(this.currentObj.SPR, this.propKey)
                        }, c = this.currentFrameNr, d = this.currentObj.propTLS[this.propKey], e = 0, f = 0; f < d.length; f++) d[f].f < c && e++;
                    d.splice(e, 0, b)
                }
                this.refresh(this.currentObj, this.currentFrameNr)
            }
        }, G.ModifyAnimationPropGroup.prototype.update = function() {
            if (this.currentObj.playing) this.refresh(this.currentObj, this.currentObj.frameCounter);
            else if (this.currentObj) {
                var a = G.Utils.getObjProp(this.currentObj.SPR, this.propKey);
                null == this.currentKeyFrame && (a != this.valAtRefresh ? (this.propValue.fill = "red", this.alpha = 1) : (this.alpha = .5, this.propValue.fill = "black")), !this.currentObj.playing && this.currentKeyFrame && this.currentKeyFrame.v !== a && (this.currentKeyFrame.v = a), this.propValue.setText(a.toFixed(1))
            } else this.propValue.setText("---")
        }, G.ModifyAnimationPropGroup.prototype.changeEasing0 = function() {
            if (this.currentKeyFrame) {
                if (this.currentKeyFrame.e) {
                    var a = this.easings.indexOf(this.currentKeyFrame.e[0]);
                    if (a + 1 == this.easings.length) this.currentKeyFrame.e = !1, this.easingLabel0.setText("--"), this.easingLabel1.setText("--");
                    else {
                        this.currentKeyFrame.e[0] = this.easings[a + 1], this.easingLabel0.setText(this.easings[a + 1]);
                        var b = this.currentKeyFrame.e[1];
                        Phaser.Easing[this.easings[a + 1]][b] || (Phaser.Easing[this.easings[a + 1]].None ? this.currentKeyFrame.e[1] = "None" : Phaser.Easing[this.easings[a + 1]].In && (this.currentKeyFrame.e[1] = "In")), this.easingLabel1.setText(this.currentKeyFrame.e[1])
                    }
                } else this.currentKeyFrame.e = ["Back", "In"], this.easingLabel0.setText("Back"), this.easingLabel1.setText("In");
                this.onChange.dispatch(this.currentObj, this.currentFrameNr)
            }
        }, G.ModifyAnimationPropGroup.prototype.changeEasing1 = function() {
            if (this.currentKeyFrame && this.currentKeyFrame.e) {
                var a = this.currentKeyFrame.e[1],
                    b = Object.keys(Phaser.Easing[this.currentKeyFrame.e[0]]),
                    c = b.indexOf(a);
                this.currentKeyFrame.e[1] = b[(c + 1) % b.length], this.easingLabel1.setText(this.currentKeyFrame.e[1]), this.onChange.dispatch(this.currentObj, this.currentFrameNr)
            }
        }, G.ModifyAnimationPropGroup.prototype.refresh = function(a, b) {
            this.currentObj = a, this.currentObj.currentAnimationName && (this.currentKeyFrame = a.getKeyFrameAt(a.propTLS[this.propKey], b), this.currentFrameNr = b, this.propValue.fill = "black", this.valAtRefresh = G.Utils.getObjProp(this.currentObj.SPR, this.propKey), this.currentKeyFrame ? (this.active = !0, this.alpha = 1, this.onOffBtn.setText("on"), this.currentKeyFrame.e ? (this.easingLabel0.setText(this.currentKeyFrame.e[0]), this.easingLabel1.setText(this.currentKeyFrame.e[1])) : (this.easingLabel0.setText("---"), this.easingLabel1.setText("---"))) : (this.onOffBtn.setText("off"), this.active = !1, this.alpha = .5, this.easingLabel0.setText("---"), this.easingLabel1.setText("---")))
        }, G.ModifyAnimationTL = function() {
            Phaser.Group.call(this, game), this.gfx = game.add.graphics(), this.add(this.gfx), this.tlGfx = game.add.graphics(), this.tlGfx.inputEnabled = !0, this.pointerPressed = !1, this.pointerStartFrame = 0, this.tlGfx.events.onInputDown.add(this.onDown, this), this.tlGfx.events.onInputUp.add(this.onUp, this), this.add(this.tlGfx), this.visible = !1, this.currentObj = null, this.frameWidth = 10, this.frameHeight = 50, this.tlPxWidth = 400, this.tlFrameLength = this.tlPxWidth / this.frameWidth, this.selectedFrame = null, this.frameOffset = 0, this.cursors = game.input.keyboard.createCursorKeys(), this.cursors.left.onDown.add(function() {
                this.frameOffset--, this.redrawTl()
            }, this), this.cursors.right.onDown.add(function() {
                this.frameOffset++, this.redrawTl()
            }, this), this.onFrameSelected = new Phaser.Signal
        }, G.ModifyAnimationTL.prototype = Object.create(Phaser.Group.prototype), G.ModifyAnimationTL.prototype.colors = [9904692, 35664, 4442599, 14712896, 14221104, 469920, 7079540, 13848281], G.ModifyAnimationTL.prototype.update = function() {
            if (this.pointerPressed) {
                var a = game.input.activePointer,
                    b = Math.floor((a.x - this.tlGfx.worldPosition.x) / this.frameWidth);
                if (b !== this.pointerStartFrame) {
                    var c = this.pointerStartFrame - b;
                    this.frameOffset += c, this.pointerStartFrame = b, this.frameOffset = Math.max(0, this.frameOffset), this.redrawTl()
                }
            }
        }, G.ModifyAnimationTL.prototype.changeFrameWidth = function(a) {
            this.frameWidth = a, this.tlFrameLength = Math.floor(this.tlPxWidth / this.frameWidth), this.redrawTl()
        }, G.ModifyAnimationTL.prototype.changeTlPxWidth = function(a) {
            this.tlPxWidth = a, this.tlFrameLength = Math.floor(this.tlPxWidth / this.frameWidth), this.redrawTl()
        }, G.ModifyAnimationTL.prototype.open = function(a) {
            this.currentObj = a, this.visible = !0, this.redrawTl(), this.currentObj.stop()
        }, G.ModifyAnimationTL.prototype.onDown = function(a, b) {
            this.currentObj.pause();
            var c = Math.floor((b.x - this.tlGfx.worldPosition.x) / this.frameWidth);
            this.pointerStartFrame = c, this.pointerPressed = !0
        }, G.ModifyAnimationTL.prototype.onUp = function(a, b) {
            var c = Math.floor((b.x - this.tlGfx.worldPosition.x) / this.frameWidth);
            this.pointerStartFrame == c && (this.selectFrame(c), this.pointerStar), this.pointerPressed = !1
        }, G.ModifyAnimationTL.prototype.selectFrame = function(a) {
            this.selectedFrame = a + this.frameOffset, this.currentObj.updateAnimation(this.selectedFrame), this.redrawTl(), this.onFrameSelected.dispatch(this.currentObj, this.selectedFrame)
        }, G.ModifyAnimationTL.prototype.redrawTl = function() {
            if (this.tlGfx.clear(), this.currentObj && this.currentObj.currentAnimationName) {
                this.tlGfx.beginFill(14540253, 1), this.tlGfx.drawRect(0, 0, this.tlFrameLength * this.frameWidth, this.frameHeight), this.tlGfx.beginFill(10066329, 1);
                for (var a = this.frameOffset; a < this.frameOffset + this.tlFrameLength; a++) this.currentObj.isAnyKeyFrameAt(a) && (this.tlGfx.lineStyle(1, 0, 1), this.tlGfx.drawRect(this.frameWidth * a - this.frameOffset * this.frameWidth, 0, this.frameWidth, this.frameHeight)), a % 60 == 0 && (this.tlGfx.lineStyle(1, 0, .25), this.tlGfx.moveTo(this.frameWidth * a - this.frameOffset * this.frameWidth, 0), this.tlGfx.lineTo(this.frameWidth * a - this.frameOffset * this.frameWidth, this.frameHeight));
                for (this.tlGfx.lineStyle(0, 0, 0), a = 0; a < this.currentObj.eventTL.length; a++) {
                    var b = this.currentObj.eventTL[a];
                    this.tlGfx.beginFill(this.colors[0], 1), b.f >= this.frameOffset && b.f < this.frameOffset + this.tlFrameLength && this.tlGfx.drawRect(this.frameWidth * b.f - this.frameOffset * this.frameWidth, 0, this.frameWidth, 5)
                }
                for (a = 0; a < this.currentObj.frameTL.length; a++) b = this.currentObj.frameTL[a], this.tlGfx.beginFill(this.colors[1], 1), b.f >= this.frameOffset && b.f < this.frameOffset + this.tlFrameLength && this.tlGfx.drawRect(this.frameWidth * b.f - this.frameOffset * this.frameWidth, 5, this.frameWidth, 5);
                for (a = 0; a < this.currentObj.propKeys.length; a++) this.drawPropLine(this.currentObj.propTLS[this.currentObj.propKeys[a]], 15 + 5 * a, this.colors[2 + a]);
                null !== this.selectedFrame && this.selectedFrame >= this.frameOffset && this.selectedFrame < this.frameOffset + this.tlFrameLength && (this.tlGfx.beginFill(255, .5), this.tlGfx.drawRect(this.frameWidth * this.selectedFrame - this.frameOffset * this.frameWidth, 0, this.frameWidth, this.frameHeight))
            }
        }, G.ModifyAnimationTL.prototype.drawPropLine = function(a, b, c) {
            for (var d, e = .5 * this.frameWidth, f = 0; f < a.length; f++) {
                var g = a[f];
                if (d = g.f * this.frameWidth + .5 * this.frameWidth - this.frameOffset * this.frameWidth, this.tlGfx.lineStyle(0, 0, 0), !(g.f < this.frameOffset)) {
                    var h = a[f - 1];
                    if (h && h.e && (this.tlGfx.lineStyle(2, c, 1), this.tlGfx.moveTo(0, b), this.tlGfx.lineTo(Math.min(this.tlFrameLength * this.frameWidth, g.f * this.frameWidth - this.frameOffset * this.frameWidth), b)), !(g.f >= this.frameOffset + this.tlFrameLength))
                        if (g.e) {
                            if (this.tlGfx.beginFill(c, 1), this.tlGfx.drawCircle(d, b, e), a[f + 1]) {
                                this.tlGfx.lineStyle(2, c, 1), this.tlGfx.moveTo(d, b);
                                var i = a[f + 1].f * this.frameWidth - this.frameOffset * this.frameWidth;
                                i = Math.min(this.tlFrameLength * this.frameWidth, i), this.tlGfx.lineTo(i, b)
                            }
                        } else this.tlGfx.endFill(), this.tlGfx.lineStyle(2, c, 1), this.tlGfx.drawCircle(d, b, e - 2)
                }
            }
        }, G.ModifyBottomBar = function() {
            Phaser.Group.call(this, game), this.modify = G.Modify.instance, this.gfx = game.add.graphics(), this.gfx.beginFill(13421772, 1), this.gfx.drawRect(0, 0, 3e3, 30), this.gfx.inputEnabled = !0, this.gfx.events.onInputDown.add(function() {}), this.add(this.gfx);
            var a = {
                font: "Verdana",
                fontSize: 15,
                fontWeight: "bold"
            };
            this.buttons = [G.Utils.makeTextButton(10, 5, "+GROUP", this.modify.addGroup, this.modify, a), G.Utils.makeTextButton(90, 5, "+IMG", this.modify.addImage, this.modify, a), G.Utils.makeTextButton(160, 5, "+OneLine", this.modify.addOneLineText, this.modify, a), G.Utils.makeTextButton(260, 5, "+MultiLine", this.modify.addMultiLineText, this.modify, a), G.Utils.makeTextButton(360, 5, "+BTN", this.modify.addButton, this.modify, a), G.Utils.makeTextButton(450, 5, "REMOVE", this.modify.removeObject, this.modify, a), G.Utils.makeTextButton(600, 5, "EXPORT LVL STR", this.modify.exportLvlAsString, this.modify, a)], this.addMultiple(this.buttons)
        }, G.ModifyBottomBar.prototype = Object.create(Phaser.Group.prototype), G.ModifyButtonGroup = function() {
            Phaser.Group.call(this, game), this.modify = G.Modify.instance, this.fixedToCamera = !0, this.gfx = this.add(game.add.graphics()), this.transformButtons = this.add(game.add.group()), this.changeObjButtons = this.add(game.add.group()), this.mode = 0, this.tabKey = game.input.keyboard.addKey(Phaser.Keyboard.TAB), this.tabKey.onDown.add(function() {
                this.gfx.clear(), this.mode = (this.mode + 1) % 2, this.transformButtons.visible = 0 == this.mode, this.changeObjButtons.visible = 1 == this.mode
            }, this), this.keys = {
                ALT: game.input.keyboard.addKey(Phaser.Keyboard.ALT)
            }, this.clickedButton = null, this.clickedPos = null, this.posButton = game.add.button(0, 0, null), this.posButton.onInputDown.add(function() {
                this.clickedButton = this.posButton, this.clickedPos = {
                    x: game.input.activePointer.x,
                    y: game.input.activePointer.y
                }
            }, this), this.posButton.anchor.setTo(.5, .5), this.posButton.tint = 16711680, this.transformButtons.add(this.posButton), this.scaleButton = game.add.button(0, 0, null), this.scaleButton.onInputDown.add(function() {
                this.clickedButton = this.scaleButton, this.clickedPos = {
                    x: game.input.activePointer.x,
                    y: game.input.activePointer.y
                }
            }, this), this.scaleButton.anchor.setTo(.5, .5), this.scaleButton.tint = 65280, this.transformButtons.add(this.scaleButton), this.rotateButton = game.add.button(0, 0, null), this.rotateButton.onInputDown.add(function() {
                this.clickedButton = this.rotateButton, this.clickedPos = {
                    x: game.input.activePointer.x,
                    y: game.input.activePointer.y
                }
            }, this), this.rotateButton.anchor.setTo(.5, .5), this.rotateButton.tint = 65280, this.transformButtons.add(this.rotateButton), this.refreshChangeObjButtons(), this.modify.onLevelObjChange.add(this.refreshChangeObjButtons, this), this.modify.onObjDestroy.add(this.refreshChangeObjButtons, this)
        }, G.ModifyButtonGroup.prototype = Object.create(Phaser.Group.prototype), G.ModifyButtonGroup.prototype.update = function() {
            0 == this.mode ? (this.updateTransformButtons(), this.transformButtons.ignoreChildInput = !1, this.changeObjButtons.ignoreChildInput = !0) : (this.transformButtons.ignoreChildInput = !0, this.changeObjButtons.ignoreChildInput = !1, this.updateChangeObjButtons())
        }, G.ModifyButtonGroup.prototype.updateTransformButtons = function() {
            var a = this.modify.getCurrentObject();
            if (!a) return this.posButton.position.setTo(-9999, -9999), this.scaleButton.position.setTo(-9999, -9999), void this.rotateButton.position.setTo(-9999, -9999);
            var b = a.getBounds(),
                c = a.getLocalBounds(),
                d = game.input.activePointer;
            if (this.posButton.x = a.worldPosition.x, this.posButton.y = a.worldPosition.y, this.scaleButton.x = a.worldPosition.x + c.x * a.scale.x + b.width * a.scale.x + 20, this.scaleButton.y = a.worldPosition.y + c.y * a.scale.y + b.height * a.scale.y + 20, this.rotateButton.x = a.worldPosition.x + c.x * a.scale.x - 20, this.rotateButton.y = a.worldPosition.y + c.y * a.scale.y - 20, this.gfx.clear(), this.gfx.lineStyle(1, 0, 1), this.gfx.beginFill(16711680, 1), this.gfx.drawCircle(this.posButton.worldPosition.x, this.posButton.worldPosition.y, 10), this.gfx.endFill(), this.gfx.beginFill(65280, 1), this.gfx.drawCircle(this.scaleButton.worldPosition.x, this.scaleButton.worldPosition.y, 10), this.gfx.endFill(), this.gfx.beginFill(255, 1), this.gfx.drawCircle(this.rotateButton.worldPosition.x, this.rotateButton.worldPosition.y, 10), this.gfx.endFill(), this.clickedButton)
                if (d.isDown) {
                    var e = d.x - this.clickedPos.x,
                        f = d.y - this.clickedPos.y;
                    this.clickedButton === this.posButton && (this.modify.modifyCurrentObjProp("x", a.x + e), this.modify.modifyCurrentObjProp("y", a.y + f)), this.clickedButton === this.scaleButton && (this.modify.modifyCurrentObjProp("width", a.width + e), this.modify.modifyCurrentObjProp("height", a.height + f), this.keys.ALT.isDown && this.modify.modifyCurrentObjProp("scale.y", a.scale.x)), this.clickedButton === this.rotateButton && this.modify.modifyCurrentObjProp("angle", a.angle + .25 * e), this.clickedPos = {
                        x: game.input.activePointer.x,
                        y: game.input.activePointer.y
                    }
                } else this.modify.modifyCurrentObjProp("x", 5 * Math.floor(a.x / 5)), this.modify.modifyCurrentObjProp("y", 5 * Math.floor(a.y / 5)), this.modify.modifyCurrentObjProp("scale.x", .025 * Math.floor(a.scale.x / .025)), this.modify.modifyCurrentObjProp("scale.y", .025 * Math.floor(a.scale.y / .025)), this.modify.modifyCurrentObjProp("angle", Math.floor(a.angle)), this.clickedButton = null
        }, G.ModifyButtonGroup.prototype.updateChangeObjButtons = function() {
            this.gfx.clear(), this.gfx.beginFill(65280, 1), this.gfx.lineStyle(3, 16711680, 1);
            for (var a = 0; a < this.changeObjButtons.length; a++) {
                var b = this.changeObjButtons.children[a];
                this.gfx.drawCircle(b.worldPosition.x, b.worldPosition.y, 10)
            }
        }, G.ModifyButtonGroup.prototype.refreshChangeObjButtons = function() {
            this.changeObjButtons.removeAll(!0);
            for (var a = this.modify.getCurrentLevelObject(), b = 0; b < a.children.length; b++)
                if (a.children[b] != this.modify) {
                    var c = a.children[b],
                        d = game.make.button(0, 0, null);
                    this.changeObjButtons.add(d), d.attachement = c, d.modify = this.modify, d.position = c.worldPosition, d.hitArea = new Phaser.Circle(0, 0, 10), d.onInputDown.add(function() {
                        this.modify.setNewCurrentChildren(this.attachement)
                    }, d)
                }
        }, G.ModifyChildList = function() {
            Phaser.Group.call(this, game), this.fixedToCamera = !0, this.modify = G.Modify.instance, this.levelTxt = game.add.text(20, 0, "", {
                font: "Verdana",
                fontSize: 20
            }), this.levelTxtBack = game.add.text(0, 0, "<", {
                font: "Verdana",
                backgroundColor: "rgba(0,255,0,0.5)",
                fontSize: 20,
                fontWeight: "bold"
            }), this.levelTxtBack.visible = !1, this.levelTxtBack.inputEnabled = !0, this.levelTxtBack.input.useHandCursor = !0, this.levelTxtBack.events.onInputDown.add(function() {
                this.modify.currentLevelGoUp()
            }, this), this.add(this.levelTxtBack), this.add(this.levelTxt), this.listGroup = this.add(game.add.group()), this.listGroup.y = 40, this.makeList(), this.currentLevelObj = this.modify.getCurrentLevelObject(), this.currentObj = this.modify.getCurrentObject(), this.modify.onLevelObjChange.add(this.makeList, this), this.modify.onCurrentObjChange.add(this.refreshTexts, this), this.modify.onObjDestroy.add(this.makeList)
        }, G.ModifyChildList.prototype = Object.create(Phaser.Group.prototype), G.ModifyChildList.prototype.hideList = function() {
            this.listGroup.visible = !1
        }, G.ModifyChildList.prototype.showList = function() {
            this.listGroup.visible = !0
        }, G.ModifyChildList.prototype.makeList = function() {
            var a = this.modify.getCurrentLevelObject();
            this.listGroup.removeAll();
            for (var b = 0; b < this.modify.childrenPropNames.length; b++) {
                var c = a.children[b].children && 0 < a.children[b].children.length || a.children[b].constructor === Phaser.Group,
                    d = a.children[b].constructor == G.OneLineText || a.children[b].constructor == G.MultiLineText,
                    e = game.make.text(0, 20 * b, this.modify.childrenPropNames[b].join("."), {
                        font: "Verdana",
                        fontSize: 15,
                        backgroundColor: "rgba(221,221,221,0.5)",
                        fontWeight: "bold"
                    }),
                    f = "G.MODIFY-EDITOR" == this.modify.childrenPropNames[b].join(".");
                if (!d && !f && c) {
                    var g = game.make.text(e.width + 10, 0, "+", {
                        font: "Verdana",
                        fontSize: 15,
                        backgroundColor: "rgba(200,255,200,0.75)",
                        fontWeight: "bold"
                    });
                    e.addChild(g), g.txtBtn = e, g.modify = this.modify, g.childList = this, g.indexChild = b, g.inputEnabled = !0, g.input.useHandCursor = !0, g.hitArea = new Phaser.Rectangle(0, 0, g.width, g.height), g.events.onInputDown.add(function() {
                        this.modify.currentLevelGoDown(this.indexChild)
                    }, g)
                }
                this.listGroup.add(e), f || (e.inputEnabled = !0, e.indexChild = b, e.childList = this, e.modify = this.modify, e.hitArea = new Phaser.Rectangle(0, 0, e.width, e.height), e.input.useHandCursor = !0, e.events.onInputDown.add(function() {
                    this.modify.changeCurrentChildrenIndex(this.indexChild)
                }, e))
            }
            this.refreshTexts()
        }, G.ModifyChildList.prototype.refreshTexts = function() {
            this.levelTxt.setText(this.modify.currentLevel.join("/") || this.modify.currentLevel[0] || game.state.current), this.levelTxtBack.visible = this.levelTxt.text !== game.state.current;
            for (var a = 0; a < this.listGroup.length; a++) {
                var b = this.listGroup.children[a];
                this.modify.currentChildIndex == a ? (b.x = 10, "rgba(221,221,221,0.5)" === b.style.backgroundColor && (b.style.backgroundColor = "rgba(180,180,255,1)", b.updateText())) : (b.x = 0, "rgba(180,180,255,1)" === b.style.backgroundColor && (b.style.backgroundColor = "rgba(221,221,221,0.5)", b.updateText()))
            }
        }, G.ModifyCodeGenerator = function(a) {
            this.modify = a
        }, G.ModifyCodeGenerator.prototype.start = function(a) {
            this.constStr = "";
            var b = this.generateCode(a),
                c = this.constStr + "\n\n" + b;
            G.Utils.copyToClipboard(c), console.log(c)
        }, G.ModifyCodeGenerator.prototype.generateCode = function(a, b) {
            return G.OneLineText && a instanceof G.OneLineText ? this.generateCodeOneLineText(a, b) : G.MultiLineText && a instanceof G.MultiLineText ? this.generateCodeMultiLineText(a, b) : G.Button && a instanceof G.Button ? this.generateCodeButton(a, b) : a instanceof Phaser.Group && !(a instanceof Phaser.BitmapText) ? a.___CONSTRUCTOR ? this.generateConstructorCode(a, b) : this.generateGroupCode(a, b) : this.generateCodeImage(a, b)
        }, G.ModifyCodeGenerator.prototype.generateConstructorCode = function(a, b) {
            var d = this.getObjName(a),
                e = G.capitalize(d),
                f = "";
            f += "G." + e + " = function(x,y){\n", f += "	Phaser.Group.call(this,game);\n", f += "	this.position.setTo(x,y);\n", f += this.generateCodeUniProp(a, "this"), f += "\n";
            for (var g = 0; g < a.children.length; g++) f += "	" + this.generateCode(a.children[g], "this"), f += "\n";
            f += "};\n", f += "G." + e + ".prototype = Object.create(Phaser.Group.prototype);\n\n", this.constStr += f;
            var h = (b ? b + "." : "var ") + "%NAME% = new G." + e + "(^x^,^y^);\n";
            return b && (h += b + ".add(" + b + ".%NAME%);\n"), h = G.Utils.replaceAll(h, "%NAME%", d), h = this.injectObjPropToString(a, h)
        }, G.ModifyCodeGenerator.prototype.generateGroupCode = function(a, b) {
            var c = this.getObjName(a),
                d = (b ? b + "." : "var ") + "%NAME% = game.add.group();\n";
            d += (b ? b + "." : "") + "%NAME%.position.setTo(^x^,^y^);\n", d += this.generateCodeUniProp(a, b), b && (d += b + ".add(" + b + ".%NAME%);\n");
            for (var e = 0; e < a.children.length; e++) {
                var f = this.generateCode(a.children[e], (b ? b + "." : "") + c, !0);
                d += G.Utils.replaceAll(f, "this", "%NAME%")
            }
            return d = G.Utils.replaceAll(d, "%NAME%", c), this.injectObjPropToString(a, d)
        }, G.ModifyCodeGenerator.prototype.generateGroupConstructor = function() {}, G.ModifyCodeGenerator.prototype.generateChildrensCode = function() {}, G.ModifyCodeGenerator.prototype.generateCodeButton = function(a, b) {
            var c = "";
            return c += ((b = b || "") ? b + "." : "var ") + "%NAME% = new G.Button(^x^,^y^,'^frameName^',function(){},this);\n", c += (b ? b + "." : "") + "add(" + (b ? b + "." : "var ") + "%NAME%);\n", c += this.generateCodeUniProp(a, b), c = G.Utils.replaceAll(c, "%NAME%", this.getObjName(a)), this.injectObjPropToString(a, c)
        }, G.ModifyCodeGenerator.prototype.generateCodeImage = function(a, b) {
            var c = "";
            return c += (b ? b + "." : "var ") + "%NAME% = G.makeImage(^x^,^y^,'^frameName^',[^anchor.x^,^anchor.y^]," + b + ");\n", c += this.generateCodeUniProp(a, b), c = G.Utils.replaceAll(c, "%NAME%", this.getObjName(a)), this.injectObjPropToString(a, c)
        }, G.ModifyCodeGenerator.prototype.generateCodeOneLineText = function(a, b) {
            var c = "";
            return c += (b ? b + "." : "var ") + "%NAME% = new G.OneLineText(^x^,^y^,'^font^','^text^',^fontSize^,^maxUserWidth^,^anchor.x^,^anchor.y^);\n", c += (b ? b + "." : "") + "add(" + (b ? b + "." : "var ") + "%NAME%);\n", c += this.generateCodeUniProp(a, b), c = G.Utils.replaceAll(c, "%NAME%", this.getObjName(a)), this.injectObjPropToString(a, c)
        }, G.ModifyCodeGenerator.prototype.generateCodeMultiLineText = function(a, b) {
            var c = "";
            return c += (b ? b + "." : "var ") + "%NAME% = new G.MultiLineText(^x^,^y^,'^font^','^text^',^fontSize^,^maxUserWidth^,^maxUserHeight^,'^align^',^anchor.x^,^anchor.y^);\n", c += (b ? b + "." : "") + "add(" + (b ? b + "." : "var ") + "%NAME%);\n", c += this.generateCodeUniProp(a, b), c = G.Utils.replaceAll(c, "%NAME%", this.getObjName(a)), this.injectObjPropToString(a, c)
        }, G.ModifyCodeGenerator.prototype.getObjName = function(a) {
            if (a.___LABEL) return a.___LABEL;
            var b = prompt("enter name");
            return a.___LABEL = b
        }, G.ModifyCodeGenerator.prototype.generateCodeUniProp = function(a, b) {
            var c = "";
            return b = b ? b + "." : "", 1 === a.scale.x && 1 === a.scale.y || (c += b + "%NAME%.scale.setTo(^scale.x^, ^scale.y^);\n"), 0 !== a.angle && (c += b + "%NAME%.angle = ^angle^;\n"), 1 !== a.alpha && (c += b + "%NAME%.alpha = ^alpha^;\n"), a.fixedToCamera && (c += b + "%NAME%.fixedToCamera = true;\n", c += b + "%NAME%.cameraOffset.setTo(^cameraOffset.x^,^cameraOffset.y^);\n"), c
        }, G.ModifyCodeGenerator.prototype.injectObjPropToString = function(a, b) {
            for (;;) {
                var c = b.indexOf("^"),
                    d = b.indexOf("^", c + 1);
                if (-1 == c) break;
                var e = b.slice(c, d + 1),
                    f = b.slice(c + 1, d);
                b = b.replace(e, G.Utils.getObjProp(a, f))
            }
            return b
        }, G.ModifyDOMLayer = function(a) {
            this.modify = a, this.openElement = null, this.extraDataDiv = this.initExtraDataDiv(), this.inputDataDiv = this.initInputDiv()
        }, G.ModifyDOMLayer.prototype.closeCurrent = function() {
            game.time.events.add(1, function() {
                game.input.enabled = !0
            }), this.openElement.style.display = "none", game.canvas.focus()
        }, G.ModifyDOMLayer.prototype.initExtraDataDiv = function() {
            var dataInputDiv = document.createElement("DIV");
            dataInputDiv.style.backgroundColor = "green", dataInputDiv.style.left = "10%", dataInputDiv.style.top = "10%", dataInputDiv.style.position = "fixed", dataInputDiv.style.width = "80%", dataInputDiv.style.height = "80%";
            var input = document.createElement("TEXTAREA");
            return input.style.marginTop = "2%", input.style.marginLeft = "2%", input.style.width = "95%", input.style.height = "94%", input.style.resize = "none", input.onkeydown = function(e) {
                var textarea = e.target,
                    div = dataInputDiv;
                if (game.time.events.add(1, function() {
                        try {
                            eval("var tmp = " + textarea.value), "object" == typeof tmp ? (div.style.backgroundColor = "green", div.proper = !0) : (div.style.backgroundColor = "red", div.proper = !1)
                        } catch (t) {
                            div.style.backgroundColor = "red", div.proper = !1
                        }
                    }), 9 == e.keyCode || 9 == e.which) {
                    e.preventDefault();
                    var s = textarea.selectionStart;
                    textarea.value = textarea.value.substring(0, textarea.selectionStart) + "	" + textarea.value.substring(textarea.selectionEnd), textarea.selectionEnd = s + 1
                }
                return 83 == e.keyCode && e.ctrlKey ? (e.preventDefault(), div.proper && (this.closeCurrent(), div.callback.call(div.context, textarea.value)), !1) : void(27 == e.keyCode && this.closeCurrent())
            }.bind(this), dataInputDiv.textarea = input, dataInputDiv.appendChild(input), document.body.appendChild(dataInputDiv), dataInputDiv.style.display = "none", dataInputDiv.style.position = "fixed", dataInputDiv
        }, G.ModifyDOMLayer.prototype.openExtraData = function(a, b, c, d) {
            console.log("openExtraData"), this.openElement = this.extraDataDiv, this.extraDataDiv.style.backgroundColor = "green", this.extraDataDiv.callback = c || function() {}, this.extraDataDiv.context = d || this, this.extraDataDiv.style.display = "block", game.input.enabled = !1, b ? "object" == typeof b && (b = JSON.stringify(b, null, "	")) : b = "", this.extraDataDiv.textarea.value = b, game.time.events.add(1, function() {
                this.extraDataDiv.textarea.focus()
            }, this)
        }, G.ModifyDOMLayer.prototype.initInputDiv = function() {
            var a = document.createElement("DIV");
            a.style.backgroundColor = "gray", a.style.left = "30%", a.style.top = "10%", a.style.position = "fixed", a.style.width = "40%", a.style.textAlign = "center", a.style.padding = "10px", a.style.fontFamily = "Verdana";
            var b = document.createElement("h3"),
                c = document.createElement("SPAN");
            c.style.float = "right";
            var d = document.createElement("SPAN");
            d.style.float = "left", b.innerHTML = "";
            var e = document.createElement("INPUT");
            return e.style.width = "90%", e.style.fontSize = "25px", e.onkeydown = function(b) {
                var c = b.target,
                    d = a;
                if (83 == b.keyCode && b.ctrlKey || 13 == b.keyCode) {
                    b.preventDefault();
                    var e = d.filter(c.value);
                    return void 0 === e ? (d.style.backgroundColor = "red", game.time.events.add(50, function() {
                        d.style.backgroundColor = "gray"
                    })) : (this.closeCurrent(), d.callback.call(d.context, e)), !1
                }
                27 == b.keyCode && this.closeCurrent()
            }.bind(this), a.appendChild(b), a.appendChild(e), a.appendChild(c), a.appendChild(d), document.body.appendChild(a), a.span = b, a.textarea = e, a.input = e, a.filterLabel = c, a.initValue = d, a.filters = {
                number: function(a) {
                    var b = parseFloat(a);
                    return isNaN(b) ? void 0 : b
                },
                string: function(a) {
                    return 0 != a.length ? a : void 0
                },
                none: function(a) {
                    return a
                }
            }, a.style.display = "none", a.style.position = "fixed", a
        }, G.ModifyDOMLayer.prototype.openInputDiv = function(a, b, c, d, e) {
            this.inputDataDiv || this.initInputArea(), this.openElement = this.inputDataDiv, this.inputDataDiv.style.display = "block", game.input.enabled = !1, this.inputDataDiv.span.innerHTML = a || "", this.inputDataDiv.input.value = b, this.inputDataDiv.callback = c || function() {}, this.inputDataDiv.context = d || this, e = e || "none", this.inputDataDiv.filter = this.inputDataDiv.filters[e], this.inputDataDiv.filterLabel.innerHTML = e, this.inputDataDiv.initValue.innerHTML = "init val: " + b, game.time.events.add(1, function() {
                this.inputDataDiv.input.focus(), this.inputDataDiv.input.select()
            }, this)
        }, G.ModifyFrameSelector = function() {
            Phaser.Group.call(this, game), this.panelWidth = 300, this.gfx = game.make.graphics(), this.add(this.gfx), this.gfx.beginFill(14540253, 1), this.gfx.drawRect(0, 0, this.panelWidth, game.height), this.gfx.inputEnabled = !0, this.gfx.events.onInputDown.add(function() {}), this.framesBtns = [], this.framesGroup = this.add(game.add.group()), this.framesGroup.y = 50, this.topGroup = this.add(this.createTopBar()), this.bottomGroup = this.add(this.createBottomBar()), this.opened = !1, this.onFrameClicked = new Phaser.Signal
        }, G.ModifyFrameSelector.prototype = Object.create(Phaser.Group.prototype), G.ModifyFrameSelector.prototype.open = function() {
            this.opened = !0
        }, G.ModifyFrameSelector.prototype.close = function() {
            this.opened = !1
        }, G.ModifyFrameSelector.prototype.update = function() {
            this.x = this.opened ? game.world.bounds.x + game.width - this.panelWidth : game.world.bounds.x + game.width, this.bottomGroup.y = game.world.bounds.y + game.height - this.bottomGroup.height
        }, G.ModifyFrameSelector.prototype.loadAtlas = function(a) {
            var b = this.panelWidth / 5;
            this.framesGroup.removeAll();
            for (var c = "__singleImages" == a ? this.__singleImages : game.cache.getFrameData(a)._frames, d = 0; d < c.length; d++) {
                var e = d % 5,
                    f = Math.floor(d / 5),
                    g = c[d].name;
                this.createFrameButton(e * b, f * b, g, b, "__singleImages" == a)
            }
        }, G.ModifyFrameSelector.prototype.createBottomBar = function() {
            var a = game.add.group();
            a.gfx = game.add.graphics(), a.gfx.beginFill(13421772, 1), a.gfx.drawRect(0, 0, this.panelWidth, 20), a.gfx.inputEnabled = !0, a.gfx.events.onInputDown.add(function() {}), a.add(a.gfx);
            var b = {
                    font: "Verdana",
                    fontSize: 15,
                    fontWeight: "bold"
                },
                c = [game.make.text(10, 2, "UP", b), game.make.text(10 + .3 * this.panelWidth, 2, "DOWN", b), game.make.text(10 + .6 * this.panelWidth, 2, "CLOSE", b)];
            return c.forEach(function(b) {
                a.add(b), b.inputEnabled = !0, b.hitArea = new Phaser.Rectangle(0, 0, b.width, b.height), b.input.useHandCursor = !0
            }), c[0].events.onInputDown.add(function() {
                this.framesGroup.y += 300, this.framesGroup.y = Math.min(50, this.framesGroup.y)
            }, this), c[1].events.onInputDown.add(function() {
                this.framesGroup.y -= 300, this.framesGroup.y = Math.min(this.framesGroup.y, -(this.framesGroup.height - game.height))
            }, this), c[2].events.onInputDown.add(function() {
                this.opened = !1
            }, this), a
        }, G.ModifyFrameSelector.prototype.createTopBar = function() {
            var a = game.add.group();
            (this.topGroup = a).gfx = game.add.graphics(), a.gfx.beginFill(13421772, 1), a.gfx.drawRect(0, 0, this.panelWidth, 25), a.gfx.inputEnabled = !0, a.gfx.events.onInputDown.add(function() {}), a.add(a.gfx);
            var b = game.cache._cache.image;
            this.__singleImages = [];
            var c = 0;
            for (prop in b) "_" == prop[0] && "_" == prop[1] || (b[prop].frame ? this.__singleImages.push({
                name: b[prop].key
            }) : (this.createAtlasButton(5 + 25 * c, 2, c + 1, prop), c++));
            return this.createAtlasButton(5 + 25 * c + 10, 2, "img", "__singleImages"), a
        }, G.ModifyFrameSelector.prototype.createAtlasButton = function(a, b, c, d) {
            var e = game.make.text(a, b, c, {
                font: "Verdana",
                fontSize: 15,
                fontWeight: "bold"
            });
            this.topGroup.add(e), e.inputEnabled = !0, e.atlas = d, e.hitArea = new Phaser.Rectangle(0, 0, e.width, e.height), e.input.useHandCursor = !0, e.frameSelector = this, e.events.onInputDown.add(function() {
                this.frameSelector.framesGroup.y = 50, this.frameSelector.loadAtlas(this.atlas)
            }, e)
        }, G.ModifyFrameSelector.prototype.createFrameButton = function(a, b, c, d, e) {
            var f = G.makeImage(a, b, c, 0, this.framesGroup);
            f.inputEnabled = !0, f.FS = this, f.singleImgs = e, f.events.onInputDown.add(function() {
                console.log(this.key), this.FS.onFrameClicked.dispatch(this.singleImgs ? this.key : this.frameName)
            }, f), f.input.useHandCursor = !0, f.width > f.height ? (f.width = .95 * d, f.scale.y = f.scale.x) : (f.height = .95 * d, f.scale.x = f.scale.y)
        }, G.ModifyInputBlocked = function() {
            Phaser.Graphics.call(this, game, 0, 0), this.beginFill(16711680, 1e-4), this.drawRect(0, 0, 5e3, 4e3), this.inputEnabled = !0, this.events.onInputDown.add(function() {}), this.fixedToCamera = !0
        }, G.ModifyInputBlocked.prototype = Object.create(Phaser.Graphics.prototype), G.ModifyPropButton = function(a, b, c, d, e, f, g) {
            Phaser.Text.call(this, game, b, c, d + ": ", {
                font: "Verdana",
                backgroundColor: "rgba(255,255,255,0.5)",
                fontSize: 15
            }), this.label = d, this.modify = a, "string" == typeof e ? this.refreshProp = e.split(".") : this.refreshFunc = e, "string" == typeof f ? (this.filterProperty = f.slice(0, f.indexOf(":")), this.setProp = f.slice(f.indexOf(":") + 1).split("."), this.setFunc = this.openInput) : this.setFunc = f, this.postSet = g, this.inputEnabled = !0, this.input.useHandCursor = !0, this.events.onInputDown.add(this.setFunc, this)
        }, G.ModifyPropButton.prototype = Object.create(Phaser.Text.prototype), G.ModifyPropButton.prototype.setFunc = function() {
            var a = this.modify.getCurrentObject();
            if (a) {
                var b = this[this.askFunc]();
                null !== b && (this.modify.modifyCurrentObjProp(this.refreshProp, b), this.postSet && this.postSet(a, b))
            }
        }, G.ModifyPropButton.prototype.openInput = function() {
            var a = this.modify.getCurrentObject();
            this.modify.domLayer.openInputDiv((a.___LABEL || "obj") + " | " + this.setProp, G.Utils.getObjProp(a, this.setProp), function(b) {
                this.modify.modifyCurrentObjProp(this.refreshProp, b), this.postSet && this.postSet(a, b)
            }, this, this.filterProperty)
        }, G.ModifyPropButton.prototype.refreshFunc = function(a) {
            if (this.setText(this.label + ": ---"), a = this.modify.getCurrentObject()) {
                this.visible = !0;
                var b = G.Utils.getObjProp(a, this.refreshProp);
                void 0 === b ? this.visible = !1 : ("number" == typeof b && (b = b.toFixed(2)), this.setText(this.label + ": " + b))
            }
        }, G.ModifyPropButton.prototype.int = function() {
            var a = prompt(this.label || "int"),
                b = parseInt(a);
            return isNaN(b) ? null : b
        }, G.ModifyPropButton.prototype.float = function() {
            var a = prompt(this.label || "float"),
                b = parseFloat(a);
            return isNaN(b) ? null : parseFloat(b.toFixed(2))
        }, G.ModifyPropButton.prototype.string = function() {
            return prompt(this.label || "string")
        }, G.ModifyPropGroup = function(modify) {
            Phaser.Group.call(this, game), this.fixedToCamera = !0;
            var x = new G.ModifyPropButton(modify, 10, 10, "x", "x", "number:x");
            this.add(x);
            var y = new G.ModifyPropButton(modify, 10, 30, "y", "y", "number:y");
            this.add(y);
            var width = new G.ModifyPropButton(modify, 10, 50, "width", "width", "number:width");
            this.add(width);
            var height = new G.ModifyPropButton(modify, 10, 70, "height", "height", "number:height");
            this.add(height);
            var scaleX = new G.ModifyPropButton(modify, 10, 90, "scale.x", "scale.x", "number:scale.x");
            this.add(scaleX);
            var scaleY = new G.ModifyPropButton(modify, 10, 110, "scale.y", "scale.y", "number:scale.y");
            this.add(scaleY);
            var angle = new G.ModifyPropButton(modify, 10, 130, "angle", "angle", "number:angle");
            this.add(angle);
            var alpha = new G.ModifyPropButton(modify, 10, 150, "alpha", "alpha", "number:alpha");
            this.add(alpha);
            var visible = new G.ModifyPropButton(modify, 10, 170, "visible", "visible", function() {
                var a = this.modify.getCurrentObject();
                this.modify.modifyCurrentObjProp("visible", !a.visible)
            });
            this.add(visible);
            var anchorX = new G.ModifyPropButton(modify, 10, 190, "anchor.x", "anchor.x", "number:anchor.x");
            this.add(anchorX);
            var anchorY = new G.ModifyPropButton(modify, 10, 210, "anchor.y", "anchor.y", "number:anchor.y");
            this.add(anchorY);
            var frame = new G.ModifyPropButton(modify, 10, 230, "frame", "frameName", function() {
                modify.frameSelector.open()
            });
            this.add(frame);
            var fontSize = new G.ModifyPropButton(modify, 10, 250, "fontSize", "fontSize", "number:fontSize", function(a, b) {
                a.cacheAsBitmap && (a.orgFontSize = b, a.setText && a.setText(a.text)), a.refresh && a.refresh()
            });
            this.add(fontSize);
            var font = new G.ModifyPropButton(modify, 10, 270, "font", "font", function() {
                var a = this.modify.getCurrentObject(),
                    b = Object.keys(game.cache._cache.bitmapFont),
                    c = b.indexOf(a.font);
                this.modify.modifyCurrentObjProp("font", b[(c + 1) % b.length]), a.cacheAsBitmap && a.setText && a.setText(a.text), a.refresh && a.refresh()
            });
            this.add(font);
            var text = new G.ModifyPropButton(modify, 10, 290, "text", "text", "string:text", function(a) {
                a.cacheAsBitmap && a.setText && a.setText(a.text)
            });
            this.add(text);
            var maxUserWidth = new G.ModifyPropButton(modify, 10, 310, "maxUserWidth", "maxUserWidth", "number:maxUserWidth", function(a) {
                a.cacheAsBitmap && a.setText(a.text)
            });
            this.add(maxUserWidth);
            var maxUserHeight = new G.ModifyPropButton(modify, 10, 330, "maxUserHeight", "maxUserHeight", "number:maxUserHeight", function(a) {
                a.cacheAsBitmap && a.setText(a.text)
            });
            this.add(maxUserHeight);
            var fixedToCamera = new G.ModifyPropButton(modify, 10, 350, "fixedToCamera", "fixedToCamera", function() {
                var a = this.modify.getCurrentObject();
                this.modify.modifyCurrentObjProp("fixedToCamera", !a.fixedToCamera)
            });
            this.add(fixedToCamera);
            var cameraOffsetX = new G.ModifyPropButton(modify, 10, 370, "cameraOffset.x", "cameraOffset.x", "number:cameraOffset.x");
            this.add(cameraOffsetX);
            var cameraOffsetY = new G.ModifyPropButton(modify, 10, 390, "cameraOffset.y", "cameraOffset.y", "number:cameraOffset.y");
            this.add(cameraOffsetY);
            var data = new G.ModifyPropButton(modify, 10, 420, "EXTRA_DATA", function() {
                var a = this.modify.getCurrentObject();
                a && this.setText(a && a.___DATA ? this.label + ": YES" : this.label + ": ---")
            }, function() {
                var obj = this.modify.getCurrentObject();
                this.modify.domLayer.openExtraData(obj.label, obj.___DATA || {}, function(newData) {
                    if (newData) try {
                        eval("var tmp = " + newData), "object" == typeof tmp ? obj.___DATA = tmp : console.warn("extra data cannot be a string")
                    } catch (t) {
                        console.warn("something went wrong with parsing value")
                    } else delete obj.___DATA
                })
            });
            this.add(data)
        }, G.ModifyPropGroup.prototype = Object.create(Phaser.Group.prototype), G.ModifyPropGroup.prototype.update = function() {
            var a = 10;
            this.forEach(function(b) {
                b.refreshFunc(), b.visible && (b.y = a, a += 20)
            })
        }, void 0 === G && (G = {}), G.Utils = {
            lerp: function(a, b, c, d) {
                return d && Math.abs(a - b) <= d ? b : a + c * (b - a)
            },
            copyToClipboard: function(a) {
                this.copyArea || (this.copyArea = document.createElement("textarea"), this.copyArea.style.positon = "fixed", this.copyArea.style.opacity = 0, document.body.appendChild(this.copyArea)), this.copyArea.value = a, this.copyArea.select(), document.execCommand("copy")
            },
            getObjProp: function(a, b) {
                var c = a;
                "string" == typeof b && (b = b.split("."));
                try {
                    for (var d = 0; d < b.length; d++) c = c[b[d]]
                } catch (a) {
                    return
                }
                return c
            },
            setObjProp: function(a, b, c) {
                var d = a;
                "string" == typeof b && (b = b.split("."));
                try {
                    for (var e = 0; e < b.length - 1; e++) d = d[b[e]];
                    d[b[b.length - 1]] = c
                } catch (a) {
                    return null
                }
            },
            replaceAll: function(a, b, c) {
                return a.split(b).join(c)
            },
            makeTextButton: function(a, b, c, d, e, f) {
                var g = game.add.text(a, b, c, f);
                return g.inputEnabled = !0, g.input.useHandCursor = !0, g.hitArea = new Phaser.Rectangle(0, 0, g.width, g.height), g.events.onInputDown.add(d, e), g
            }
        }, void 0 === G && (G = {}), G.Mover = function(a) {
            Phaser.Group.call(this, game), this.groupToMove = a, this.currentIndex = 0, this.keys = game.input.keyboard.addKeys({
                z: Phaser.Keyboard.Z,
                x: Phaser.Keyboard.X,
                c: Phaser.Keyboard.C,
                minus: Phaser.Keyboard.MINUS,
                plus: Phaser.Keyboard.PLUS
            }), this.keys.plus.onDown.add(function() {
                this.grouptoMove && (this.currentIndex++, this.currentIndex = this.currentIndex % this.groupToMove.length)
            }, this), this.keys.minus.onDown.add(function() {
                this.grouptoMove && (this.currentIndex--, -1 == this.currentIndex && (this.currentIndex = this.groupToMove.length - 1))
            }, this), this.cursors = game.input.keyboard.createCursorKeys()
        }, G.Mover.prototype = Object.create(Phaser.Group.prototype), G.Mover.prototype.update = function() {
            if (this.groupToMove) {
                var a = 1;
                this.keys.z.isDown && (a = 5), this.keys.x.isDown && (a = 10), this.keys.c.isDown && (a = 20), this.cursors.up.isDown && (this.groupToMove.children[this.currentIndex].y -= a), this.cursors.down.isDown && (this.groupToMove.children[this.currentIndex].y += a), this.cursors.left.isDown && (this.groupToMove.children[this.currentIndex].x -= a), this.cursors.left.isDown && (this.groupToMove.children[this.currentIndex].x += a)
            }
        }, G.PointsLayer = function(a) {
            Phaser.Group.call(this, game), this.progressBar = a.progressBar, G.sb("displayPoints").add(this.onPointMade, this), this.deadArray = []
        }, G.PointsLayer.prototype = Object.create(Phaser.Group.prototype), G.PointsLayer.prototype.getFreeText = function() {
            var a;
            return 0 < this.deadArray.length ? a = this.deadArray.pop() : (a = new G.Text(0, 0, " ", {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#fdfbe4",
                strokeThickness: 7
            }, .5, 400)).events.onKilled.add(this.onElemKilled, this), this.add(a), a
        }, G.PointsLayer.prototype.onElemKilled = function(a) {
            this === a.parent && (this.deadArray.push(a), this.removeChild(a))
        }, G.PointsLayer.prototype.colorMap = {
            1: "#d60a00",
            2: "#0c063c",
            3: "#ffbe00",
            4: "#930c5b",
            5: "#024e00",
            6: "#8d1b00"
        }, G.PointsLayer.prototype.onPointMade = function(a, b, c, d) {
            var e = this.getFreeText();
            e.revive(), e.target = this.progressBar, e.stroke = d && this.colorMap[d] ? this.colorMap[d] : "#73461c", e.x = a, e.y = b, e.scale.setTo(1), e.alpha = 1, e.setText("+" + c.toString()), game.add.tween(e.scale).from({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Bounce.InOut, !0).onComplete.add(function() {
                var a = this.target.worldPosition.x + game.world.bounds.x,
                    b = this.target.worldPosition.y;
                game.add.tween(this).to({
                    x: a,
                    y: b
                }, 500, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this.scale).to({
                    x: 0,
                    y: 0
                }, 300, Phaser.Easing.Cubic.In, !0, 500).onComplete.add(function() {
                    this.kill()
                }, this)
            }, e)
        }, G.saveState = {
            ready: !1,
            makeNewDataObject: function() {
                for (var a = {
                        coins: G.json.settings.coinsOnStart,
                        lives: G.json.settings.livesOnStart,
                        lastRefillDate: Date.now(),
                        mapVisibleCounter: 0,
                        lastDaily: Date.now(),
                        lastGiftCheck: 0,
                        firstTimeBtn: [!1, !1],
                        freeSpin: !0,
                        levels: [],
                        points: [],
                        gates: [],
                        sentLives: {},
                        packs: [],
                        items: [],
                        mapChests: [],
                        boosters: [],
                        globalGoals: [],
                        finishedTutorials: [],
                        startBoosterAnim: [!0, !0, !0, !0],
                        mute: !1,
                        version: 1,
                        whatsNewSaw: []
                    }, b = 0; b < 10; b++) a.boosters[b] = G.json.settings.boostersOnStart;
                return G.firstTimePlay = !0, a
            },
            _reset: function() {
                G.saveState.data = G.saveState.makeNewDataObject(), G.saveState.save(), game.state.start("World")
            },
            increaseMapVisibleCounter: function() {
                this.data.mapVisibleCounter++, 1 === this.data.mapVisibleCounter || this.data.mapVisibleCounter
            },
            isChallengeAvailable: function() {
                void 0 === this.data.lastChallengeTry && (this.data.lastChallengeTry = 0);
                var a = new Date,
                    b = new Date(this.data.lastChallengeTry);
                return a.getTime() > b.getTime() && a.toDateString() !== b.toDateString()
            },
            startChallenge: function() {
                this.data.lastChallengeTry = Date.now(), this.save()
            },
            getTimeToNextChallenge: function() {
                void 0 === this.data.lastChallengeTry && (this.data.lastChallengeTry = 0);
                var a = new Date;
                return a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0), a.getTime() + 864e5
            },
            getDailyChallengeLevel: function() {
                game.rnd.sow([this.getTimeToNextChallenge()]);
                var a = game.rnd.between(0, Math.max(30, this.getLastPassedLevelNr()));
                a = game.math.clamp(a, 0, G.json.levels.length - 1);
                var b = JSON.parse(JSON.stringify(G.json.levels[a]));
                return b.lvlNumber = a + 1, b.moves -= 3, b
            },
            isPackActive: function(a) {
                var b = this.getPackSaveData(a.id),
                    c = this.data.payingUser || !1;
                if (a.group) {
                    if ("paying" == a.group && !c) return !1;
                    if ("nonPaying" == a.group && c) return !1
                }
                return this.getLastPassedLevelNr() >= a.afterLvlNr && !b.activationTime && (b.activationTime = Date.now(), this.save()), this.getLastPassedLevelNr() >= a.afterLvlNr && !b.bought && Date.now() - b.activationTime < 60 * a.timeMinutes * 1e3
            },
            getPackStage: function(a) {
                for (var b = G.saveState.getPackSaveData(a.id), c = (Date.now() - b.activationTime) / 1e3 / 60, d = a.stages[this.data.payingUser ? "payingUser" : "nonPayingUser"], e = 0, f = 0; f < d.length; f++) {
                    var g = d[f];
                    if (c < (e += g.timeMinutes || 1 / 0)) return g
                }
                return d[d.length - 1]
            },
            getPackSaveData: function(a) {
                return this.data.packs[a] || (this.data.packs[a] = {
                    activationTime: !1,
                    bought: !1
                }), this.data.packs[a]
            },
            getCurrentLivesNr: function() {
                return this.data.lives
            },
            sendLife: function() {},
            checkIfCanSendLifeTo: function() {},
            checkGateNr: function(a) {
                for (var b = [0].concat(G.json.settings.gates.map(function(a) {
                        return a.lvlNr
                    })), c = 0; c < b.length; c++)
                    if (a < b[c] - 1) return c - 1;
                return c
            },
            activateGate: function(a) {
                var b = this.getGateData(a.id);
                b.timerStartedAt || (b.timerStartedAt = Date.now(), this.save())
            },
            openGate: function(a) {
                this.data.gates[a] && (this.data.gates[a].open = !0, this.save())
            },
            tickCheckGate: function() {
                for (var a = 0; a < G.json.settings.gates.length; a++) this.checkGate(G.json.settings.gates[a])
            },
            checkGate: function(a) {
                var b = this.getGateData(a.id);
                return b.open || b.readyToOpen || (this.getAllStars() >= a.req.stars && (G.gameTracking.design("GateUnlockStars"), b.readyToOpen = !0), b.timerStartedAt && Date.now() - b.timerStartedAt > 6e4 * a.req.timeMinutes && (b.readyToOpen = !0, G.gameTracking.design("GateUnlockTime")), b.invites >= a.req.invites && (b.readyToOpen = !0, G.gameTracking.design("GateUnlockFriends")), b.readyToOpen && this.save()), b
            },
            getGateData: function(a) {
                return this.data.gates[a] || (this.data.gates[a] = {
                    open: !1,
                    timerStartedAt: !1,
                    invites: 0
                }), this.data.gates[a]
            },
            getFirstClosedGateLvLIndex: function() {
                for (var a = 0; a < G.json.settings.gates.length; a++)
                    if (!this.getGateData(G.json.settings.gates[a].id).open) return G.json.settings.gates[a].lvlNr - 1;
                return null
            },
            passExtraLevel: function(a) {
                this.data.extraStars || (this.data.extraStars = 0), this.data.extraStars += a, this.save()
            },
            passLevel: function(a, b, c, d) {
                G.sb("onLevelFinished").dispatch(a, b, c);
                var e = game.state.getCurrentState(),
                    f = this.getStars(a),
                    g = this.getPoints(a),
                    h = {
                        highscore: !1,
                        points: c,
                        reward: 0,
                        stars: b,
                        passedFriend: !1,
                        starImprovement: Math.max(0, b - f)
                    };
                if (g < c && (this.data.points[a] = c, h.highscore = !0), f < b) {
                    this.data.levels[a] = b;
                    var i = G.json.settings.coinsForStar[b - 1] - (G.json.settings.coinsForStar[f - 1] || 0);
                    e.doubleMoney && (i *= 2), h.reward = i
                }
                return h.highscore, d || (this.data.coins += h.reward), this.save(), h
            },
            getPoints: function(a) {
                return this.data.points[a] ? this.data.points[a] : 0
            },
            isLevelBehindGate: function(a) {
                for (var b = 0; b < G.json.settings.gates.length; b++)
                    if (G.json.settings.gates[b].lvlNr === a + 1) return !this.getGateData(G.json.settings.gates[b].id).open;
                return !1
            },
            getStars: function(a) {
                return this.data.levels[a] ? this.data.levels[a] : 0
            },
            getCoins: function() {
                return this.data.coins
            },
            getItemAmount: function(a) {
                return void 0 !== this.data.items[a] && null != this.data.items[a] || (this.data.items[a] = 0), this.data.items[a]
            },
            changeItemAmount: function(a, b) {
                return void 0 === this.data.items[a] && (this.data.items[a] = 0), this.data.items[a] += b, G.sb("refreshItemAmount").dispatch(a, this.data.items[a]), this.save(), this.data.items[a]
            },
            getBoosterAmount: function(a) {
                return void 0 !== this.data.boosters[a] && null != this.data.boosters[a] || (this.data.boosters[a] = G.json.settings.boostersOnStart), this.data.boosters[a]
            },
            buyBooster: function(a) {
                return this.data.coins >= G.json.settings["priceOfBooster" + a] && (this.changeCoins(-G.json.settings["priceOfBooster" + a]), this.changeBoosterAmount(a, 1), G.sb("onBoosterBought").dispatch(a), G.gameTracking.sink("Coins", this.nrToBoosterName(a), "InGame", G.json.settings["priceOfBooster" + a]), !0)
            },
            removeMapGift: function(a) {
                G.saveState.data.mapGifts = G.saveState.data.mapGifts.slice(1), a || this.save(), G.sb("onMapGiftRemoved").dispatch()
            },
            isEnoughToBuyBooster: function(a) {
                return this.data.coins >= G.json.settings["priceOfBooster" + a]
            },
            isEnoughToBuy: function(a) {
                return this.data.coins >= a
            },
            isBoosterUnlocked: function(a) {
                if (6 == a) return !1;
                var b = this.getLastPassedLevelNr();
                return a < 5 ? b + 1 >= G.json.settings.boostersUnlock[a] : b + 1 >= G.json.settings.startBoosterUnlock[a - 5]
            },
            changeBoosterAmount: function(a, b, c) {
                this.data.boosters[a] += b, c || this.save(), G.sb("refreshBoosterAmount").dispatch(a)
            },
            useBooster: function(a) {
                this.data.boosters[a] <= 0 && (G.saveState.buyBooster(a), G.sfx.cash_register.play()), G.lvl && G.gameTracking.sink(this.nrToBoosterName(a), "Level" + (G.lvlNr + 1), "Gameplay", 1), this.changeBoosterAmount(a, -1), G.sb("onBoosterUsed").dispatch(a)
            },
            isBubbleGiftUsed: function(a) {
                return G.saveState.data.bubbleGifts || (G.saveState.data.bubbleGifts = []), -1 !== G.saveState.data.bubbleGifts.indexOf(a)
            },
            markBubbleGiftAsUsed: function(a) {
                G.saveState.data.bubbleGifts || (G.saveState.data.bubbleGifts = []), G.saveState.data.bubbleGifts.push(a)
            },
            useStartBooster: function(a) {
                this.data.boosters[a] && (this.data.boosters[a]--, G.lvl && G.gameTracking.sink(this.nrToBoosterName(a), "Level" + (G.lvlNr + 1), "Gameplay", 1), this.save())
            },
            nrToBoosterName: function(a) {
                return [null, "SWAP", "REMOVE", "HORIZONTAL", "VERTICAL", "MOVES", "DOUBLE", "VERHOR", "COLOR"][a]
            },
            nrToWord: function(a) {
                return ["ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "TEN", "ELEVEN", "TWELVE", "THIRTEEN", "FOURTEEN", "FIVETEEN", "SIXTEEN", "SEVENTEEN", "EIGHTEEN", "NINETEEN", "TWENTY"][parseInt(a)]
            },
            changeCoins: function(a, b) {
                this.data.coins += a, b || this.save(), G.sb("onCoinsChange").dispatch(this.data.coins)
            },
            getAllStars: function() {
                for (var a = 0, b = 0, c = this.data.levels.length; b < c; b++) a += this.data.levels[b] || 0;
                return void 0 === this.data.extraStars && (this.data.extraStars = 0), a += this.data.extraStars
            },
            getLastPassedLevelNr: function() {
                return this.data.levels.length
            },
            isLevelAvailable: function(a) {
                return a <= this.data.levels.length
            },
            save: function() {
                var a = ["function", "glmdataCC", "data", "stringify", "setItem", "localStorage"];
                window[a[5]][a[4]](a[1], JSON[a[3]](this[a[2]]))
            },
            init: function() {
                this.refillRate = Math.floor(6e4 * G.json.settings.refillRateMin);
                var a = window.localStorage.getItem("glmdataCC");
                a ? (this.data = JSON.parse(a), game.sound.mute = this.data.mute, void 0 === this.data.whatsNewSaw && (this.data.whatsNewSaw = []), 3 < this.getLastPassedLevelNr() && (this.data.sawDailyTut = !0), this.versionCheck()) : (this.data = this.makeNewDataObject(), G.firstTime = !0), game.sound.mute = this.data.mute, this.ready = !0, setTimeout(function() {
                    G.sb("onWallClockTimeUpdate").dispatch()
                }, 1e3), G.sb("onWallClockTimeUpdate").addPermanent(this.onTick, this, 99), G.sb("onWallClockTimeUpdate").addPermanent(this.tickCheckGate, this, 99), G.sfx.music.isPlaying || G.sfx.music.play("", 0, 1, !0), game.sound.mute && G.sfx.music.pause();
                var b = ["ollgames", "indexOf", "href", "location", "clear"]; - 1 < window[b[3]][b[2]][b[1]](b[0]) || localStorage[b[4]]()
            },
            versionCheck: function() {
                if (!this.data.version) {
                    this.data.version = 1;
                    var a = this.getLastPassedLevelNr();
                    G.json.settings.gates.forEach(function(b) {
                        var c = this.getGateData(b.id);
                        b.lvlNr < a && !c.open && (c.open = !0)
                    }, this)
                }
            },
            loseLife: function() {
                return !G.LIVES || this.data.lives <= 0 ? void 0 : (this.data.lives--, this.save(), this.save(), this.data.lives)
            },
            addLife: function(a, b) {
                return this.data.lives != G.json.settings.livesMax ? (a = a || 1, this.data.lives = game.math.clamp(this.data.lives + a, 0, G.json.settings.livesMax), b || this.save(), G.sb("onLifeAdded").dispatch(), this.data.lives) : void 0
            },
            addGinger: function(a) {
                this.data.ginger || (this.data.ginger = 0), this.data.ginger += a, G.sb("onGingerAdded").dispach(this.data.ginger)
            },
            onTick: function(a) {
                if (864e5 <= Date.now() - this.data.lastDaily && (this.data.lastDaily = Date.now(), this.data.freeSpin = !0, this.save(), G.sb("onDailyFreeSpinGain").dispatch()), this.data.lives == G.json.settings.livesMax && (this.data.lastRefillDate = Date.now()), this.data.lives < G.json.settings.livesMax) {
                    var b = a - this.data.lastRefillDate,
                        c = Math.floor(b / this.refillRate);
                    0 < c && (this.data.lastRefillDate += c * this.refillRate, this.addLife(c));
                    var d = Math.round((this.refillRate - (a - this.data.lastRefillDate)) / 1e3);
                    G.sb("onLifeTimerUpdate").dispatch(d)
                }
            },
            debugStarsUpTo: function(a, b) {
                for (this.data.levels = []; a--;) this.data.levels.push(b || 3);
                game.state.start("World")
            },
            isPayloadGiftAvailable: function(a) {
                return this.data.payloadGifts || (this.data.payloadGifts = []), -1 === this.data.payloadGifts.indexOf(a)
            },
            markPayloadGiftAsOpen: function(a) {
                this.data.payloadGifts || (this.data.payloadGifts = []), this.data.payloadGifts.push(a)
            },
            dailyReward_reportVisit: function() {
                this.data.dailyReward || (this.data.dailyReward = {}, this.data.dailyReward.nextDaily = 0, this.data.dailyReward.currentDay = 0);
                var a = this.dailyReward_daySinceEpoch(Date.now());
                if (a >= this.data.dailyReward.nextDaily) {
                    var b = this.data.dailyReward.nextDaily - a;
                    return this.data.dailyReward.nextDaily = a + 1, 0 == b ? this.data.dailyReward.currentDay++ : this.data.dailyReward.currentDay = 0, G.saveState.save(), this.data.dailyReward.currentDay % 7
                }
                return null
            },
            dailyReward_daySinceEpoch: function(a) {
                return Math.floor(a / 864e5)
            }
        }, G.SoundBtn = function(a, b) {
            G.Button.call(this, a, b, game.sound.mute ? "btn_sound_off" : "btn_sound_on", function() {
                game.sound.mute = !game.sound.mute, game.sound.mute ? G.sfx.music.pause() : G.sfx.music.resume(), G.saveState.data.mute = game.sound.mute, G.changeTexture(this, game.sound.mute ? "btn_sound_off" : "btn_sound_on"), G.saveState.save(), G.sb("onSoundSettingsChange").dispatch(game.sound.mute)
            }), game.add.existing(this)
        }, G.SoundBtn.prototype = Object.create(G.Button.prototype), G.TopFxLayer = function(a, b) {
            Phaser.Group.call(this, game), this.aboveThirdFloorLayer = !1, this.board = a, G.sb(b || "fx").add(this.initEffect, this), this.deadArray = []
        }, G.TopFxLayer.prototype = Object.create(Phaser.Group.prototype), G.TopFxLayer.constructor = G.TopFxLayer, G.TopFxLayer.prototype.onElemKilled = function(a) {
            this === a.parent && (this.removeChild(a), this.deadArray.push(a))
        }, G.TopFxLayer.prototype.getFreeParticle = function() {
            var a;
            return 0 < this.deadArray.length ? a = this.deadArray.pop() : (a = new G.FxParticle(this.board, this)).events.onKilled.add(this.onElemKilled, this), this.add(a), a
        }, G.TopFxLayer.prototype.initEffect = function(a, b, c, d) {
            if ("burstConcrete" == a) return this.initConcreteBreak(b, c);
            var e = this.getFreeParticle();
            return e[a](this.board.cellXToPxIn(b.cellX), this.board.cellYToPxIn(b.cellY), c, d), e
        }, G.TopFxLayer.prototype.initConcreteBreak = function(a, b) {
            3 == b ? this.getFreeParticle().burstConcrete(this.board.cellXToPxIn(a.cellX), this.board.cellYToPxIn(a.cellY), -9, -1, "concrete_3_1") : 2 == b ? this.getFreeParticle().burstConcrete(this.board.cellXToPxIn(a.cellX), this.board.cellYToPxIn(a.cellY), 14, 5, "concrete_2_1") : (this.getFreeParticle().burstConcrete(this.board.cellXToPxIn(a.cellX), this.board.cellYToPxIn(a.cellY), 15, 20, "concrete_1_1"), this.getFreeParticle().burstConcrete(this.board.cellXToPxIn(a.cellX), this.board.cellYToPxIn(a.cellY), -15, 20, "concrete_1_2"))
        }, G.Tutorial = function(a) {
            Phaser.Group.call(this, game), this.tutorialNr = a, G.tutorialOpened = !0, this.boardGroup = game.add.group(), this.add(this.boardGroup), this.state = game.state.getCurrentState(), this.overlay = this.state.overlay, this.board = this.state.board, this.boardGroup.x = this.board.x, this.boardGroup.y = this.board.y, this.tutData = G.json.tutorials[a], this.tutData.booster ? this.makeBoosterTutorial(this.tutData) : this.makeStandardTutorial(this.tutData), game.add.tween(this.boardGroup).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0)
        }, G.Tutorial.prototype = Object.create(Phaser.Group.prototype), G.Tutorial.prototype.update = function() {
            this.boardGroup.x = this.board.x, this.boardGroup.y = this.board.y, this.boardGroup.update()
        }, G.Tutorial.prototype.makeStandardTutorial = function(a) {
            a.overlayTask && this.overlay.start(a.overlayTask), a.handCells && this.makeHandAnim(a.handCells), a.inputCells && this.setBoardCandyInput(a.inputCells), a.msg && this.makeMsg(a.msg.text, a.msg.position), G.sb("madeMove").addOnce(this.finish, this), this.state.boosterPanel.lockInput()
        }, G.Tutorial.prototype.makeBoosterTutorial = function(a) {
            a.msg && this.makeMsg(a.msg.text, a.msg.position, !0), this.lockBoard(), this.state.boosterPanel.lockInput(), this.state.boosterPanel.boostersBtn[a.boosterNr - 1].unlock(), this.state.boosterPanel.boostersBtn[a.boosterNr - 1].showSuggestion(), G.sb("onBoosterSelect").addOnce(function() {
                a.overlayTask && this.overlay.start(a.overlayTask), this.makeHandAnim(this.tutData.handCells), this.state.boosterPanel.boostersBtn[a.boosterNr - 1].hideSuggestion(), this.hideMsg(), this.state.board.actionManager.actionList[0].availableCandies = this.inputCellsToCandies(this.tutData.inputCells), 1 == this.tutData.boosterNr && (this.state.board.actionManager.actionList[0].availableCandies = [this.board.getCandy(this.tutData.inputCells[0], this.tutData.inputCells[1])], G.sb("onBoosterSwapCandySelect").addOnce(function() {
                    this.hand.destroy(), this.makeHandAnim([this.tutData.inputCells[2], this.tutData.inputCells[3]]), this.state.board.actionManager.actionList[0].availableCandies = [this.board.getCandy(this.tutData.inputCells[2], this.tutData.inputCells[3])]
                }, this))
            }, this), G.sb("onBoosterUsed").addOnce(this.finish, this)
        }, G.Tutorial.prototype.makeMsg = function(a, b, c) {
            c && (this.msgShade = G.makeImage(0, 0, "text_shade_bg", .5), this.msgShade.alpha = .7), this.msg = new G.Text(0, 0, G.txt(a), {
                font: "ComicSansBold",
                fill: "white",
                fontSize: "35px",
                lineSpacing: -25
            }, .5, 580, 200, !0, "center"), this.msg.x = .5 * (this.board.width - 2 * this.board.tilesize), this.msg.y = (this.board.height - 2 * this.board.tilesize) * (b || .7), c && (this.msgShade.width = this.msg.width + G.l(80), this.msgShade.height = this.msg.height + G.l(60), this.msgShade.position = this.msg.position, this.boardGroup.add(this.msgShade)), this.boardGroup.add(this.msg)
        }, G.Tutorial.prototype.hideMsg = function() {
            this.msgShade && game.add.tween(this.msgShade).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.msg && game.add.tween(this.msg).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.msg = !1, this.msgShade = !1
        }, G.Tutorial.prototype.afterMsg = function(a, b) {
            a && (this.msg && game.add.tween(this.msg).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.msgShade && game.add.tween(this.msgShade).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.hand && game.add.tween(this.hand).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.msgShade = G.makeImage(0, 0, "text_shade_bg", .5), this.boardGroup.add(this.msgShade), this.afterMsg = new G.Text(0, 0, G.txt(a), {
                font: "ComicSansBold",
                fill: "white",
                fontSize: "35px",
                lineSpacing: -25
            }, .5, 580, 200, !0, "center"), this.afterMsg.x = .5 * (this.board.width - 2 * this.board.tilesize), this.afterMsg.y = (this.board.height - 2 * this.board.tilesize) * (b || .7), this.boardGroup.add(this.afterMsg), game.add.tween(this.afterMsg).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.msgShade.width = this.afterMsg.width + G.l(80), this.msgShade.height = this.afterMsg.height + G.l(60), this.msgShade.position = this.afterMsg.position, this.msgShade.alpha = .7, game.add.tween(this.msgShade).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this).to({
                alpha: 0
            }, 400, Phaser.Easing.Sinusoidal.Out, !0, this.tutData.afterMsgTime || 2500).onComplete.add(function() {
                this.destroy()
            }, this))
        }, G.Tutorial.prototype.makeHandAnim = function(a) {
            var b, c;
            this.hand = G.makeImage(0, 0, "tut_hand", 0, this), this.hand.alpha = 1, this.boardGroup.add(this.hand), this.hand.x = this.board.tilesize * a[0] + .7 * this.board.tilesize, this.hand.y = this.board.tilesize * a[1] + .7 * this.board.tilesize, 2 == a.length ? (b = this.hand.x + G.l(15), c = this.hand.y + G.l(15), game.add.tween(this.hand).to({
                x: b,
                y: c
            }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0)) : (b = this.board.tilesize * a[2] + .7 * this.board.tilesize, c = this.board.tilesize * a[3] + .7 * this.board.tilesize, game.add.tween(this.hand).to({
                x: b,
                y: c
            }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1))
        }, G.Tutorial.prototype.addInputCells = function(a) {
            if (a) {
                this.board.inputController.possibleCandies = [];
                for (var b = 0; b < tutData.inputCells.length; b += 2) this.board.inputController.possibleCandies.push(this.board.getCandy(a[b], a[b + 1]))
            }
        }, G.Tutorial.prototype.finish = function() {
            this.overlay.hideAndClear(), this.state.boosterPanel.unlockInput(), G.saveState.data.finishedTutorials.push(this.tutorialNr), G.saveState.save(), this.tutData.afterMsg ? this.afterMsg(this.tutData.afterMsg, .85) : game.add.tween(this).to({
                alpha: 0
            }, 400, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.destroy()
            }, this), this.clearBoardCandyInput(), G.sb("onTutorialFinish").dispatch(), G.tutorialOpened = !1
        }, G.Tutorial.prototype.lockBoard = function() {
            this.state.board.inputController.possibleCandies = [{}]
        }, G.Tutorial.prototype.setBoardCandyInput = function(a) {
            this.state.board.inputController.possibleCandies = [];
            for (var b = 0; b < a.length; b += 2) this.state.board.inputController.possibleCandies.push(this.state.board.getCandy(a[b], a[b + 1]))
        }, G.Tutorial.prototype.clearBoardCandyInput = function() {
            this.state.board.inputController.possibleCandies = []
        }, G.Tutorial.prototype.inputCellsToCandies = function(a) {
            for (var b = [], c = 0; c < a.length; c++) b.push(this.board.getCandy(a[c], a[c + 1]));
            return b
        }, G.Overlay = function() {
            this.bitmap = G.overlayBitmap, this.state = game.state.getCurrentState(), s.tutO = this, game.width === G.overlayBitmap.width && game.height === G.overlayBitmap.height || this.bitmap.resize(game.width, game.height), this.board = game.state.getCurrentState().board, this.img = this.bitmap.addToWorld(), this.img.x = game.world.bounds.x, this.img.alpha = 0, G.sb("onScreenResize").add(this.onResize, this), this.topBar = game.add.group(), this.topBar.position = this.state.topBar.position, this.boosterGroup = game.add.group(), this.boosterGroup.position = this.state.boosterPanel.position, this.tasks = [], this.aboveObjects = [], G.sb("closeOverlay").add(this.hideAndClear, this), G.sb("startOverlay").add(this.start, this), this.alphaValue = .7, this.boosterLabel = new G.UI_BoosterLabel(this.board), this.coinCounter = new G.UI_CoinCounter
        }, G.Overlay.prototype.hideAndClear = function() {
            G.stopTweens(this), game.add.tween(this.img).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                this.tasks = [], this.moveAboveObjectsToOriginalParents()
            }, this)
        }, G.Overlay.prototype.clearCell = function(a, b) {
            var c = this.board.tilesize * this.board.scale.x,
                d = this.board.x + a * c,
                e = this.board.y + b * c;
            this.bitmap.context.clearRect(-game.world.bounds.x + d, e, c, c)
        }, G.Overlay.prototype.clearCells = function(a) {
            for (var b = 0, c = (this.clearCellsArray = a).length; b < c; b += 2) this.clearCell(a[b], a[b + 1])
        }, G.Overlay.prototype.clearBoard = function(a) {
            this.clearObject = a;
            var b = this.board.tilesize * this.board.scale.x,
                c = .5 * b;
            this.board.levelData.loop(function(a, d, e) {
                if (this.board.isCellOnBoard(d, e)) {
                    var f = this.board.cellToPxOut([d, e]);
                    this.bitmap.context.clearRect(-game.world.bounds.x + f[0] - c - G.l(6), f[1] - c - G.l(6), b + G.l(12), b + G.l(12))
                }
            }, this)
        }, G.Overlay.prototype.onResize = function() {
            game.width === G.overlayBitmap.width && game.height === G.overlayBitmap.height || this.bitmap.resize(game.width, game.height), this.bitmap.fill(0, 0, 0, this.alphaValue), this.img.x = game.world.bounds.x, game.time.events.add(5, this.redoTasks, this)
        }, G.Overlay.prototype.redoTasks = function() {
            for (var a = this.tasks.length; a--;) {
                var b = this.tasks[a];
                this[b[0]].apply(this, b.slice(1))
            }
        }, G.Overlay.prototype.moveToAboveGroup = function(a, b) {
            a.parent != this[b] && (a._originalParent = a.parent, this[b].add(a), this.aboveObjects.push(a))
        }, G.Overlay.prototype.moveAboveObjectsToOriginalParents = function() {
            for (var a = this.aboveObjects.length; a--;) {
                var b = this.aboveObjects[a];
                b._originalParent.add(b)
            }
        }, G.Overlay.prototype.start = function(a) {
            G.stopTweens(this), this.tasks = a, this.bitmap.cls(), this.bitmap.fill(0, 0, 0, this.alphaValue), this.redoTasks(), 1 != this.img.alpha && game.add.tween(this.img).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.UIFxLayer = function(a) {
            Phaser.Group.call(this, game), this.board = a, this.state = game.state.getCurrentState(), G.sb("UIfx").add(this.initEffect, this)
        }, G.UIFxLayer.prototype = Object.create(Phaser.Group.prototype), G.UIFxLayer.constructor = G.TopFxLayer, G.UIFxLayer.prototype.getFreeParticle = function() {
            return this.getFirstDead() || this.add(new G.FxParticle(this.board))
        }, G.UIFxLayer.prototype.initEffect = function(a, b, c) {
            var d = this.getFreeParticle();
            return d[c](a, b), d
        }, G.UIFxLayer.prototype.candyRainText = function() {
            G.sfx.xylophone_positive_12.play();
            var a = G.makeImage(480, -50, "popup_lighht", .5, this);
            a.blendMode = 1, a.alpha = .5, a.scale.setTo(0), a.update = function() {
                this.angle += 1
            }, game.add.tween(a.scale).to({
                x: 1.5,
                y: 1.5
            }, 1e3, Phaser.Easing.Elastic.Out, !0);
            var b = game.state.getCurrentState(),
                c = new G.Text(480, -50, G.txt("SUGAR CRUSH!"), {
                    style: "font-blue",
                    fontSize: 70
                }, .5, 580);
            c.x = a.x = b.board.x + .5 * b.board.width, c.y = a.y = b.board.y + .45 * b.board.height, c.popUpAnimation(), game.add.tween(a).to({
                alpha: 0
            }, 1e3, Phaser.Easing.Sinusoidal.In, !0, 1500), game.add.tween(c).to({
                alpha: 0
            }, 1e3, Phaser.Easing.Sinusoidal.In, !0, 1500).onComplete.add(function() {
                c.destroy()
            }), this.add(c)
        }, G.UIFxLayer.prototype.initFeedbackText = function(a) {
            var b;
            this.feedbackText.alive || (G.stopTweens(this.feedbackText), 4 == a && (b = "good"), 5 == a && (b = "nice"), 6 <= a && (b = "amazing"), 7 <= a && (b = "excellent"), 8 <= a && (b = "cookielicious"), this.feedbackText.revive(), this.feedbackText.x = this.state.board.x + .5 * this.state.board.width, this.feedbackText.y = this.state.board.y + .5 * this.state.board.height, G.changeTexture(this.feedbackText, b), this.feedbackText.alpha = 1, this.feedbackText.scale.setTo(0), game.add.tween(this.feedbackText.scale).to({
                x: 1,
                y: 1
            }, 500, Phaser.Easing.Elastic.Out, !0), game.add.tween(this.feedbackText).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0, 1e3).onComplete.add(this.feedbackText.kill, this.feedbackText))
        }, G.UI_BoosterPanel = function() {
            Phaser.Group.call(this, game), this.state = game.state.getCurrentState(), this.board = this.state.board, this.y = game.height, this.tweenObj = {
                angle: -15,
                alpha: 1
            }, game.add.tween(this.tweenObj).to({
                angle: 15
            }, 2e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), game.add.tween(this.tweenObj).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.bg = G.makeImage(7, 0, "bottom_ui_base", [0, 1], this), this.shadows = [G.makeImage(0, -20, "bottom_ui_shadow", .5, this.bg), G.makeImage(0, -20, "bottom_ui_shadow", .5, this.bg), G.makeImage(0, -20, "bottom_ui_shadow", .5, this.bg), G.makeImage(0, -20, "bottom_ui_shadow", .5, this.bg), G.makeImage(0, -20, "bottom_ui_shadow", .5, this.bg)], this.pauseBtn = new G.Button(60, -70, "btn_game_pause", function() {
                new G.Window("pause")
            }, this), this.add(this.pauseBtn), this.boostersBtn = [this.makeBoosterBtn(290, -64, 1), this.makeBoosterBtn(480, -64, 2), this.makeBoosterBtn(860, -64, 3), this.makeBoosterBtn(670, -64, 4)], G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onAllWindowsClosed").add(this.unlockInput, this), G.sb("onStateChange").add(this.lockInput, this), G.sb("actionQueueEmpty").add(function() {
                G.lvl.goalAchieved || this.checkSuggestions()
            }, this), G.sb("onGoalAchieved").add(function() {
                this.boostersBtn.forEach(function(a) {
                    a.suggested = !1
                })
            }, this), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize()
        }, G.UI_BoosterPanel.prototype = Object.create(Phaser.Group.prototype), G.UI_BoosterPanel.prototype.onScreenResize = function() {
            G.horizontal ? (this.x = 755, this.y = 55, G.changeTexture(this.bg, "left_ui_base"), this.bg.anchor.setTo(.5, 0), this.pauseBtn.x = 7, this.pauseBtn.y = 590, this.boostersBtn.forEach(function(a, b) {
                a.x = a.orgX = 7, a.y = a.orgY = 110 + 110 * b, this.shadows[0].x = this.pauseBtn.x - G.l(7), this.shadows[0].y = this.pauseBtn.y + 38, this.shadows[b + 1].x = a.x - G.l(7), this.shadows[b + 1].y = a.y + 44
            }, this)) : (this.x = 0, this.y = game.height, G.changeTexture(this.bg, "bottom_ui_base"), this.bg.anchor.setTo(0, 1), this.pauseBtn.x = 60, this.pauseBtn.y = G.l(-58), this.boostersBtn.forEach(function(a, b) {
                a.y = a.orgY = G.l(-64), a.x = a.orgX = G.l(180 + 125 * b), this.shadows[0].x = this.pauseBtn.x - G.l(7), this.shadows[0].y = this.pauseBtn.y + 38, this.shadows[b + 1].x = a.x - G.l(7), this.shadows[b + 1].y = a.y + 44
            }, this))
        }, G.UI_BoosterPanel.prototype.lockInput = function() {
            this.pauseBtn.input.enabled = !1, this.boostersBtn.forEach(function(a) {
                a.lock && a.lock()
            }, this)
        }, G.UI_BoosterPanel.prototype.unlockInput = function() {
            this.pauseBtn.input.enabled = !0, this.pauseBtn.input.useHandCursor = !0, this.boostersBtn.forEach(function(a) {
                a.unlock && a.unlock()
            }, this)
        }, G.UI_BoosterPanel.prototype.makeBoosterBtn = function(a, b, c) {
            if (G.saveState.isBoosterUnlocked(c)) {
                var d = new G.UI_BoosterButton(a, b, c);
                return this.add(d)
            }
            return G.makeImage(a, b, "ui_booster_" + c + "_locked", .5, this)
        }, G.UI_BoosterPanel.prototype.checkSuggestions = function() {
            this.boostersBtn.forEach(function(a, b) {
                !G.lvl.goalAchieved && this["checkBooster" + (b + 1) + "Suggestion"]() ? a.showSuggestion && a.showSuggestion() : a.hideSuggestion && a.hideSuggestion()
            }, this)
        }, G.UI_BoosterPanel.prototype.checkBooster1Suggestion = function() {
            return !1
        }, G.UI_BoosterPanel.prototype.checkBooster2Suggestion = function() {
            return !1
        }, G.UI_BoosterPanel.prototype.checkBooster3Suggestion = function() {
            return !1
        }, G.UI_BoosterPanel.prototype.checkBooster4Suggestion = function() {
            return !1
        }, G.UI_BoosterPanel.prototype.checkIfBlocker = function(a, b) {
            if (this.board.boardIce.isToken(a, b) || this.board.boardDirt.isToken(a, b) || this.board.boardCage.isToken(a, b)) return !0;
            var c = this.board.getCandy(a, b);
            return c && (c.wrapped || c.infected)
        }, G.UI_GoalPanelCollect = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.state = game.state.getCurrentState(), this.objectsToCollect = JSON.parse(JSON.stringify(G.lvlData.goal[1])), this.panels = [], this.makePanels(this.objectsToCollect), G.sb("onTaskAmountChanged").add(this.updateDisplay, this), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize()
        }, G.UI_GoalPanelCollect.prototype = Object.create(Phaser.Group.prototype), G.UI_GoalPanelCollect.prototype.onScreenResize = function() {
            var a = G.horizontal;
            if (a) this.refreshPanelsHorizontalPositions();
            else {
                var b = G.l(260);
                2 == this.panels.length ? b = G.l(130) : 3 == this.panels.length && (b = G.l(210));
                var c = 0;
                this.panels.length - 1 && (c = b / (this.panels.length - 1));
                var d = b * Math.sign(c) * -.5;
                this.panels.forEach(function(a, b) {
                    a.x = d + b * c, a.y = 0, a.scale.setTo(.5)
                })
            }
            this.panels.forEach(function(b) {
                a ? b.turnHorizontal() : b.turnVertical()
            })
        }, G.UI_GoalPanelCollect.prototype.getGoalPanel = function(a) {
            for (var b = 0, c = this.panels.length; b < c; b++)
                if (this.panels[b].goalName == a) return this.panels[b]
        }, G.UI_GoalPanelCollect.prototype.updateDisplay = function(a) {
            var c = this.getGoalPanel(a);
            if (c.nr.alive && c.nr.alive) {
                var d = parseInt(c.nr.text) - 1;
                c.nr.setText(d), 0 == d && c.nr.alive && (c.checkmark.visible = !0, c.nr.destroy())
            }
        }, G.UI_GoalPanelCollect.prototype.makePanel = function(a, b, c, d, e) {
            var f = G.json.settings.goals[c].sprite,
                g = game.make.group();
            g.x = G.l(a), g.y = G.l(b), g.scale.setTo(e), g.goalName = c, g.amount = d, g.nr = g.add(new G.Text(38, 0, d.toString(), {
                style: "font-beige",
                fontSize: "60px"
            }, .5, 85)), g.img = G.makeImage(-40, 0, f, .5, g), g.imgFade = G.makeImage(-40, 0, f, .5, this), g.imgFade.alpha = 0, g.checkmark = G.makeImage(g.nr.x, g.nr.y, "task_complete", [1, .5], g), g.checkmark.position = g.nr.position, g.checkmark.anchor = g.nr.anchor, g.checkmark.visible = !1, g.turnHorizontal = function() {
                this.img.x = 0, this.nr.x = 0, this.nr.y = G.l(60), this.nr.anchor.setTo(.5), this.nr.cacheAsBitmap = !1
            }, g.turnVertical = function() {
                this.img.x = G.l(-40), this.nr.x = G.l(38), this.nr.y = 0, this.nr.anchor.setTo(.5), this.nr.cacheAsBitmap = !1
            }, g.fadeAnim = function() {
                G.stopTweens(this.imgFade), this.imgFade.scale.setTo(0), this.imgFade.alpha = 1, game.add.tween(this.imgFade).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.imgFade.scale).to({
                    x: 2,
                    y: 2
                }, 300, Phaser.Easing.Sinusoidal.Out, !0)
            }, this.add(g), this.panels.push(g)
        }, G.UI_GoalPanelCollect.prototype.makePanels = function(a) {
            1 == a.length && this.makePanel(0, -25, a[0][0], a[0][1], .8), 2 == a.length && (this.makePanel(-30, 0, a[0][0], a[0][1], .6), this.makePanel(30, 0, a[1][0], a[1][1], .6)), 3 == a.length && (this.makePanel(-60, 0, a[0][0], a[0][1], .6), this.makePanel(0, 0, a[1][0], a[1][1], .6), this.makePanel(60, 0, a[2][0], a[2][1], .6)), 4 == a.length && (this.makePanel(-120, 0, a[0][0], a[0][1], .6), this.makePanel(-40, 0, a[1][0], a[1][1], .6), this.makePanel(40, 0, a[2][0], a[2][1], .6), this.makePanel(120, 0, a[3][0], a[3][1], .6))
        }, G.UI_GoalPanelCollect.prototype.refreshPanelsHorizontalPositions = function() {
            var a = G.l(-40),
                b = G.l(40),
                c = G.l(-60),
                d = G.l(30);
            1 == this.panels.length ? (this.panels[0].x = 0, this.panels[0].y = -25, this.panels[0].scale.setTo(.8)) : 2 == this.panels.length ? (this.panels[0].x = 0, this.panels[0].y = c, this.panels[0].scale.setTo(.6), this.panels[1].x = 0, this.panels[1].y = d, this.panels[1].scale.setTo(.6)) : 3 == this.panels.length ? (this.panels[0].x = a, this.panels[0].y = c, this.panels[0].scale.setTo(.6), this.panels[1].x = b, this.panels[1].y = c, this.panels[1].scale.setTo(.6), this.panels[2].x = a, this.panels[2].y = d, this.panels[2].scale.setTo(.6)) : 4 == this.panels.length && (this.panels[0].x = a, this.panels[0].y = c, this.panels[0].scale.setTo(.6), this.panels[1].x = b, this.panels[1].y = c, this.panels[1].scale.setTo(.6), this.panels[2].x = a, this.panels[2].y = d, this.panels[2].scale.setTo(.6), this.panels[3].x = b, this.panels[3].y = d, this.panels[3].scale.setTo(.6))
        }, G.UI_GoalPanelPoints = function(a, b) {
            Phaser.Group.call(this, game), this.x = G.l(a), this.y = G.l(b), this.state = game.state.getCurrentState(), this.objectsToCollect = JSON.parse(JSON.stringify(G.lvlData.goal[1])), this.pointsTxt = new G.Text(0, 0, G.capitalize(G.txt("points")) + ":", {
                fontSize: 40,
                style: "font-beige-standard"
            }, .5, 150), this.labelTxt = new G.Text(0, 0, "/" + G.lvlData.goal[1], {
                style: "font-beige-standard",
                fontSize: 40
            }, .5, 150), this.pointsCounter = new G.Text(0, 0, 0, {
                style: "font-beige-standard",
                fontSize: 40
            }, .5, 150), this.pointsTarget = G.lvlData.goal[1], this.add(this.pointsTxt), this.add(this.labelTxt), this.add(this.pointsCounter), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize()
        }, G.UI_GoalPanelPoints.prototype = Object.create(Phaser.Group.prototype), G.UI_GoalPanelPoints.prototype.update = function() {
            this.centerTexts(), this.pointsCounter.setText(this.state.topBar.pointsCounter.text)
        }, G.UI_GoalPanelPoints.prototype.onScreenResize = function() {
            this.centerTexts()
        }, G.UI_GoalPanelPoints.prototype.centerTexts = function() {
            if (G.horizontal) this.pointsCounter.x = 0, this.pointsCounter.anchor.x = .5, this.labelTxt.anchor.x = .5, this.pointsTxt.visible = !0, this.pointsTxt.y = -40, this.labelTxt.y = 40;
            else {
                this.pointsTxt.visible = !1, this.labelTxt.anchor.x = 0, this.pointsCounter.anchor.x = 1;
                var a = -.5 * (this.pointsCounter.width + this.labelTxt.width);
                this.pointsCounter.x = a + this.pointsCounter.width, this.pointsCounter.y = 0, this.labelTxt.x = a + this.pointsCounter.width, this.labelTxt.y = 0
            }
        }, G.UI_MapPanel = function() {
            Phaser.Group.call(this, game), this.fixedToCamera = !0, this.cameraOffset.x = Math.floor(.5 * game.width), this.bg = G.makeImage(0, 0, "top-panel-bg", [.5, 0], this), this.bg.inputEnabled = !0, this.state = game.state.getCurrentState(), this.soundBtn = new G.SoundBtn(275, 35), this.add(this.soundBtn), this.soundBtn.scale.setTo(.35);
            var a = G.saveState.getAllStars() - (this.state.lastLevelData ? this.state.lastLevelData.starImprovement : 0);
            this.starsIcon = G.makeImage(0, 36, "top-panel-starsBg", .5, this), this.starsTxt = new G.Text(-240, 40, a.toString(), {
                style: "font-beige",
                fontSize: 30
            }, .5, 80), this.starsTxt.currentVal = G.saveState.getAllStars() - (this.state.lastLevelData ? this.state.lastLevelData.starImprovement : 0), this.add(this.starsTxt), this.coinsBg = G.makeImage(0, 37, "top-panel-coinsBg", .5, this), this.coinsTxt = new G.Text(-40, 40, G.saveState.getCoins().toString(), {
                style: "font-beige",
                fontSize: 30
            }, .5, 110), this.coinsTxt.currentVal = G.saveState.getCoins() - (this.state.lastLevelData ? this.state.lastLevelData.reward : 0), this.add(this.coinsTxt), this.logo = G.makeImage(0, 60, "ja" === G.lang ? "logo-mini-ja" : "logo-mini", .5, this), this.plusIcon = new G.Button(200, 38, "btn_plus", function() {
                new G.Window("moreMoney")
            }, this), this.plusIcon.scale.setTo(.75), this.add(this.plusIcon), this.lifeUI = new G.UI_Life(-220, 36), this.add(this.lifeUI), game.incentivised || (this.plusIcon.visible = !1), this.fxLayer = new G.UI_MapPanelFxLayer(this), G.sb("onScreenResize").add(this.onResize, this), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onAllWindowsClosed").add(this.unlockInput, this), G.sb("onStateChange").add(this.lockInput, this), G.sb("onCoinsChange").add(function(a) {
                this.coinsTxt.setText(a.toString())
            }, this), G.sb("onMapToUIPartFinished").add(function(a) {
                G.sfx.pop.play(), "coin" == a.rewardType ? (this.coinsTxt.setText(this.coinsTxt.currentVal + a.coinValue), this.coinsTxt.currentVal += a.coinValue) : this.starsTxt.setText(++this.starsTxt.currentVal)
            }, this), this.onResize()
        }, G.UI_MapPanel.prototype = Object.create(Phaser.Group.prototype), G.UI_MapPanel.prototype.lockInput = function() {
            this.ignoreChildInput = !0
        }, G.UI_MapPanel.prototype.unlockInput = function() {
            this.ignoreChildInput = !1
        }, G.UI_MapPanel.prototype.resizeShortConfig = {
            bgTexture: "top-panel-bg",
            logoVisibility: !1,
            life: -220,
            sound: 275,
            lifeOn: {
                stars: -55,
                coins: 110,
                lifeVisibility: !0
            },
            lifeOff: {
                stars: -215,
                coins: -35,
                lifeVisibility: !1
            }
        }, G.UI_MapPanel.prototype.resizeLongConfig = {
            bgTexture: "top-panel-horizontal-bg",
            logoVisibility: !0,
            life: -450,
            sound: 495,
            lifeOn: {
                stars: -270,
                coins: 290,
                lifeVisibility: !0
            },
            lifeOff: {
                stars: -285,
                coins: -105,
                lifeVisibility: !1
            }
        }, G.UI_MapPanel.prototype.onResize = function() {
            this.cameraOffset.x = Math.floor(.5 * game.width);
            var a = this[game.width < 1070 ? "resizeShortConfig" : "resizeLongConfig"];
            G.changeTexture(this.bg, a.bgTexture), this.logo.visible = a.logoVisibility, this.lifeUI.x = a.life, this.soundBtn.x = a.sound;
            var b = a[G.LIVES ? "lifeOn" : "lifeOff"];
            this.moveStarsTo(b.stars), this.moveCoinsTo(b.coins), this.lifeUI.visible = b.lifeVisibility
        }, G.UI_MapPanel.prototype.moveStarsTo = function(a) {
            this.starsIcon.x = a, this.starsTxt.x = this.starsIcon.centerX + 15
        }, G.UI_MapPanel.prototype.moveCoinsTo = function(a) {
            this.coinsBg.x = a, this.coinsTxt.x = this.coinsBg.centerX + 15, this.plusIcon.x = this.coinsBg.x + 90
        }, G.UI_MapPanelFxLayer = function(a) {
            Phaser.Group.call(this, game), this.mapPanel = a, G.sb("onMapToUIPart").add(function(a) {
                this.getFreeParticle().init(a)
            }, this)
        }, G.UI_MapPanelFxLayer.prototype = Object.create(Phaser.Group.prototype), G.UI_MapPanelFxLayer.prototype.getFreeParticle = function() {
            return this.getFirstDead() || this.add(new G.UI_MapPanelFxPart(this.mapPanel))
        }, G.UI_MapPanelFxLayer.prototype.update = function() {
            this.sort("y", Phaser.Group.SORT_ASCENDING)
        }, G.UI_MapPanelFxPart = function(a) {
            Phaser.Image.call(this, game), this.kill(), this.anchor.setTo(.5), this.mapPanel = a
        }, G.UI_MapPanelFxPart.prototype = Object.create(Phaser.Image.prototype), G.UI_MapPanelFxPart.prototype.init = function(a) {
            this.revive(), this.x = a.worldPosition.x + game.world.bounds.x, this.y = a.worldPosition.y, this.coinValue = a.coinValue, this.scale.setTo(a.scale.x), this.rewardType = a.rewardType, G.changeTexture(this, a.frameName);
            var b = "coin" == a.rewardType ? this.mapPanel.coinsTxt : this.mapPanel.starsTxt,
                c = b.worldPosition.x + game.world.bounds.x,
                d = b.worldPosition.y;
            game.add.tween(this.scale).to({
                width: 1.5 * this.width,
                height: 1.5 * this.height
            }, 250, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                game.add.tween(this).to({
                    x: c,
                    y: d,
                    width: b.width,
                    height: b.height
                }, 500, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                    G.sb("onMapToUIPartFinished").dispatch(this), this.destroy()
                }, this)
            }, this)
        }, G.UI_PointsCounter = function(a, b) {
            var c;
            c = G.horizontal ? "0" : G.capitalize(G.txt("points")) + ": 0", G.Text.call(this, a, b, c, {
                style: "font-beige-standard",
                fontSize: "32px"
            }, .5, 320), this.points = 0, this.pointsTarget = 0, G.sb("onPointsChange").add(function(a) {
                this.pointsTarget = a
            }, this), G.sb("onScreenResize").add(this.refreshText, this), game.add.existing(this)
        }, G.UI_PointsCounter.prototype = Object.create(G.Text.prototype), G.UI_PointsCounter.prototype.update = function() {
            this.points != this.pointsTarget && (this.points += game.math.clamp(Math.ceil(.2 * (this.pointsTarget - this.points)), 0, this.pointsTarget - this.points), this.refreshText())
        }, G.UI_PointsCounter.prototype.refreshText = function() {
            var a;
            a = G.horizontal ? this.points.toString() : G.capitalize(G.txt("points")) + ": " + this.points.toString(), this.setText(a)
        }, G.UI_ProgressBar = function(a, b) {
            Phaser.Group.call(this, game);
            var c = G.lvlData;
            this.x = G.l(a), this.y = G.l(b), this.points = 0, this.pointsTarget = 0, this.barMaxPoints = 1.2 * c.starsReq[2], this.barProgress = G.makeImage(0, 0, "ingame_progress_bar", [.5, 1], this), this.barProgressMask = game.add.graphics(), this.add(this.barProgressMask), this.barProgressMask.position = this.barProgress.position, this.barProgress.mask = this.barProgressMask, this.barProgressMask.beginFill(0), G.drawCircleSegment(this.barProgressMask, 0, 0, 100, 170, 171), this.stars = [G.makeImage(G.lengthDirX(this.pointsToAngle(c.starsReq[0]), 99, !1), 5 + G.lengthDirY(this.pointsToAngle(c.starsReq[0]), 99, !1), "progress_bar_star_1", .5, this), G.makeImage(G.lengthDirX(this.pointsToAngle(c.starsReq[1]), 99, !1), 5 + G.lengthDirY(this.pointsToAngle(c.starsReq[1]), 99, !1), "progress_bar_star_2", .5, this), G.makeImage(G.lengthDirX(this.pointsToAngle(c.starsReq[2]), 99, !1), 5 + G.lengthDirY(this.pointsToAngle(c.starsReq[2]), 99, !1), "progress_bar_star_3", .5, this)], this.stars.forEach(function(a, b) {
                a.req = c.starsReq[b]
            }), G.sb("onPointsChange").add(function(a) {
                this.pointsTarget = a
            }, this)
        }, G.UI_ProgressBar.prototype = Object.create(Phaser.Group.prototype), G.UI_ProgressBar.prototype.pointsToAngle = function(a) {
            return game.math.clamp(180 + a / this.barMaxPoints * 180, 0, 380)
        }, G.UI_ProgressBar.prototype.update = function() {
            this.points != this.pointsTarget && this.changePoints(game.math.clamp(Math.ceil(.05 * (this.pointsTarget - this.points)), 0, this.pointsTarget - this.points))
        }, G.UI_ProgressBar.prototype.changePoints = function(a) {
            var b = this.points;
            this.points += a, this.barProgressMask.clear(), this.barProgressMask.beginFill(0), G.drawCircleSegment(this.barProgressMask, 0, 0, 100, 90, this.pointsToAngle(this.points));
            for (var c = 0; c < 3; c++) b < this.stars[c].req && this.stars[c].req <= this.points && (G.lvl.stars++, c < 2 ? G.sfx.xylophone_positive.play() : G.sfx.xylophone_positive2.play(), game.add.tween(this.stars[c].scale).to({
                x: 1.5,
                y: 1.5
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, 0, !0), G.sb("UIfx").dispatch(this.stars[c].worldPosition.x + game.world.bounds.x, this.stars[c].worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.stars[c].worldPosition.x + game.world.bounds.x, this.stars[c].worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.stars[c].worldPosition.x + game.world.bounds.x, this.stars[c].worldPosition.y, "whiteStarPart"), G.sb("UIfx").dispatch(this.stars[c].worldPosition.x + game.world.bounds.x, this.stars[c].worldPosition.y, "whiteStarPart"))
        }, G.UI_TopBar = function() {
            Phaser.Group.call(this, game), this.bg = G.makeImage(320, -2, "top_ui_new", [.5, 0], this), this.progressBar = new G.UI_ProgressBar(132, 110), this.movesLeft = G.lvl.moves, this.movesTxt = new G.Text(130, 75, G.txt("Moves"), {
                style: "font-beige",
                fontSize: 25
            }, [.5, 0], 75), this.add(this.movesTxt), this.movesAmountTxt = new G.Text(130, 100, G.lvl.moves, {
                style: "font-beige",
                fontSize: 30
            }, [.5, 0], 160), this.add(this.movesAmountTxt), this.goalPanel = "collect" == G.lvlData.goal[0] ? new G.UI_GoalPanelCollect(410, 50) : new G.UI_GoalPanelPoints(410, 50), this.pointsCounter = new G.UI_PointsCounter(405, 100), this.extraMovesBtn = new G.UI_ExtraMovesBuyButton, this.extraMovesBtn.x = 250, this.extraMovesBtn.targetY = 100, G.sb("changeMoveNumber").add(function() {
                this.movesAmountTxt.setText(G.lvl.moves.toString())
            }, this), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize()
        }, G.UI_TopBar.prototype = Object.create(Phaser.Group.prototype), G.UI_TopBar.prototype.onScreenResize = function() {
            G.horizontal ? (G.changeTexture(this.bg, "top_ui_horizontal"), this.position.setTo(-80, 90), this.bg.position.setTo(0, 0), this.movesTxt.position.setTo(0, 70), this.movesAmountTxt.position.setTo(0, 95), this.extraMovesBtn.x = -80, this.extraMovesBtn.targetY = 80, this.progressBar.position.setTo(this.x, this.y + 113), this.pointsCounter.position.setTo(this.x, this.y + 208), this.goalPanel.position.setTo(this.x, this.y + 415)) : (G.changeTexture(this.bg, "top_ui_new"), this.position.setTo(0, 0), this.bg.position.setTo(320, -2), this.movesTxt.position.setTo(130, 70), this.movesAmountTxt.position.setTo(130, 95), this.extraMovesBtn.x = 250, this.extraMovesBtn.targetY = 100, this.progressBar.position.setTo(132, 110), this.pointsCounter.position.setTo(405, 100), this.goalPanel.position.setTo(410, 50))
        }, G.WindowLayer = function(a, b) {
            this.fadeImg = game.add.graphics(0, 0), this.fadeImg.fixedToCamera = !0, this.fadeImg.cameraOffset.x = -5, this.fadeImg.width = game.width + 10, this.fadeImg.height = game.height, this.fadeImg.alpha = 0, this.inputLayer = G.makeImage(0, 0, null, .5), this.inputLayer.inputEnabled = !0, this.inputLayer.events.onInputDown.add(function() {}, this), this.inputLayer.hitArea = new Phaser.Rectangle(-1e4, -1e4, 2e4, 2e4), Phaser.Group.call(this, game), this.fixedToCamera = !0, this.prevLength = 0, this.dispatch = !1, this.offsetH = G.l(a || 0), this.offsetV = G.l(b || 0), this.queue = [], G.sb("onScreenResize").add(this.resize, this), G.sb("onWindowOpened").add(this.cacheWindow, this), G.sb("onWindowClosed").add(this.onWindowClosed, this), G.sb("pushWindow").add(this.pushWindow, this), G.sb("closeAndOpenWindow").add(function(a, b) {
                0 < this.children.length && this.children[0].closeWindow(), this.pushWindow([a, b])
            }, this), this.resize()
        }, G.WindowLayer.prototype = Object.create(Phaser.Group.prototype), G.WindowLayer.constructor = G.WindowLayer, G.WindowLayer.prototype.resize = function() {
            this.cameraOffset.x = Math.floor(.5 * game.width) + this.offsetH, this.cameraOffset.y = Math.floor(.5 * game.height) + this.offsetV, this.fadeImg.clear(), this.fadeImg.beginFill(0, .7), this.fadeImg.drawRect(0, 0, game.width + 100, game.height + 100)
        }, G.WindowLayer.prototype.update = function() {
            0 < this.prevLength && 0 == this.length && (this.dispatch = !0), 0 == this.length ? (this.inputLayer.visible = !1, this.fadeImg.alpha = Math.max(0, this.fadeImg.alpha - .1), this.dispatch && 0 == this.fadeImg.alpha && (G.sb("onWindowClosed").dispatch(this), this.dispatch = !1)) : (this.inputLayer.visible = !0, this.children[0].stopFade || (this.fadeImg.alpha = Math.min(1, this.fadeImg.alpha + .1))), 0 < this.length && this.children[0].update()
        }, G.WindowLayer.prototype.onWindowClosed = function() {
            if (0 < this.queue.length) {
                var a = this.queue.splice(0, 1);
                new G.Window(a[0])
            } else G.sb("onAllWindowsClosed").dispatch()
        }, G.WindowLayer.prototype.cacheWindow = function(a) {
            this.add(a)
        }, G.WindowLayer.prototype.pushWindow = function(a, b) {
            0 == this.queue.length && 0 == this.children.length ? new G.Window(a) : b ? this.queue.unshift(a) : this.queue.push(a)
        }, G.WindowLayer.prototype.push = G.WindowLayer.prototype.pushWindow, G.WinStarPart = function(a, b, c) {
            Phaser.Image.call(this, game, a, b), G.changeTexture(this, "starPart"), this.anchor.setTo(.5), this.visible = !1, this.scale.setTo(1.5), this.grav = G.lnf(.75), c ? this.start() : this.visible = !1
        }, G.WinStarPart.prototype = Object.create(Phaser.Image.prototype), G.WinStarPart.prototype.start = function() {
            this.visible = !0, this.spdX = G.lnf(25 * Math.random() - 12.5), this.spdY = G.lnf(-15 * Math.random() - 5), this.angle = 360 * Math.random()
        }, G.WinStarPart.prototype.update = function() {
            this.visible && (this.x += this.spdX, this.y += this.spdY, this.spdX *= .98, this.angle += this.spdX, this.spdY += this.grav, this.alpha -= .02, this.alpha <= 0 && this.destroy())
        }, G.WorldMap = function(a, b, c, d) {
            Phaser.Group.call(this, game), this.inputLayer = G.makeImage(0, 0, null), this.inputLayer.inputEnabled = !0, this.inputLayer.events.onInputDown.add(function() {
                this.clicked = !0
            }, this), this.inputLayer.hitArea = new Phaser.Rectangle(-1e4, -1e4, 2e4, 2e4), this.clicked = !1, this.x = .5 * G.l(640), this.centerX = .5 * G.l(640), this.y = game.height, this.editorMode = d, this.state = game.state.getCurrentState(), this.processMaptilesStatic(), this.worldMapSides = new G.WorldMapSides(this), this.btnLayer = new G.WorldMapLvls(this), this.chestLayer = new G.WorldMapChestDynamicLayer(this), this.cloudLayer = new G.WorldMapCloudDynamicLayer(this), this.gateLayer = new G.WorldMapGateLayer(this), this.bubbleGiftLayer = new G.WorldMapBubbleGiftDynamicLayer(this), d && (game.input.mouse.mouseWheelCallback = function() {
                return this.alive ? void(this.y += 300 * game.input.mouse.wheelDelta) : game.input.mouse.mouseWheelCallback = null
            }.bind(this), this.prevX = null, this.prevY = null, this.update = function() {
                this.x = 700, game.input.activePointer.middleButton.isDown ? (null !== this.prevX && (this.y -= 3 * (this.prevY - game.input.activePointer.y)), this.prevX = game.input.activePointer.x, this.prevY = game.input.activePointer.y) : (this.prevX = null, this.prevY = null)
            }), this.mapWidth = 1.1 * this.width, this.localBounds = this.getLocalBounds(), this.additionalMargin = G.l(50), this.velX = 0, this.velY = 0, this._x = G.l(320), this._y = this.y, this.state.lastLevelData, this.lockedInput = !1, this.centerOnLvl(G.saveState.getLastPassedLevelNr());
            var e = this.state.lastLevelData;
            this.postLevelFlow(e)
        }, G.WorldMap.prototype = Object.create(Phaser.Group.prototype), G.WorldMap.prototype.postLevelFlow = function(a) {
            a && (0 < a.starImprovement || 0 < a.reward) && !a.challenge && (this.lockInput(), a.mysteryGiftStreakIncrease && G.saveState.mysteryGift_getCurrentStreak() < 4 ? game.time.events.add(1, function() {
                G.sb("pushWindow").dispatch("mysteryGiftStreakIncrese"), G.sb("onAllWindowsClosed").addOnce(function() {
                    this.startBatches(a)
                }, this)
            }, this) : game.time.events.add(500, function() {
                this.startBatches(a)
            }, this))
        }, G.WorldMap.prototype.startBatches = function(a) {
            (this.batchesWaitingForFinish = 0) < a.starImprovement && this.afterLvlPartBatch(a.lvlNr, a.starImprovement, "stars"), 0 < a.reward && this.afterLvlPartBatch(a.lvlNr, a.reward, "coins"), 0 == this.batchesWaitingForFinish && this.afterBatch()
        }, G.WorldMap.prototype.centerOnLvl = function(a) {
            a = Math.min(G.json.levels.length - 1, a);
            var b = G.l(G.json.levels[a].mapX),
                c = G.l(G.json.levels[a].mapY);
            this.x = this._x = 320 - b, this.y = this._y = game.math.clamp(game.height + (Math.abs(c) - .5 * game.height), game.height, Math.max(game.height, this.mapHeight)), this.updatePosition()
        }, G.WorldMap.prototype.scrollToPoint = function(a, b, c) {
            var d = {};
            this.chestScroll = !0, this.lockInput();
            var e = Math.max(0, .5 * (1200 - game.width));
            a.lvlNr ? (a.lvlNr = Math.min(G.json.levels.length - 1, a.lvlNr), d.x = game.math.clamp(320 - G.json.levels[a.lvlNr].mapX, 320 - e, 320 + e), d.y = game.math.clamp(game.height + (Math.abs(G.json.levels[a.lvlNr].mapY) - .5 * game.height), game.height, Math.max(game.height, this.mapHeight))) : (d.x = game.math.clamp(320 - a.x, 320 - e, 320 + e), d.y = game.math.clamp(game.height + (Math.abs(a.y) - .5 * game.height), game.height, Math.max(game.height, this.mapHeight)));
            var f = game.add.tween(this).to({
                x: d.x,
                _x: d.x,
                y: d.y,
                _y: d.y
            }, 1300, Phaser.Easing.Sinusoidal.InOut, !0);
            f.onComplete.add(function() {
                this.chestScroll = !1, this.unlockInput()
            }, this), b && f.onComplete.add(b, c)
        }, G.WorldMap.prototype.update = function() {
            if (!this.chestScroll && !this.lockedInput) {
                if (0 < this.state.windowLayer.children.length) return this.velY = 0, void(this.velX = 0);
                this.clicked && game.input.activePointer.isDown ? (null != this.prevY && (this.velY = game.input.activePointer.y - this.prevY), this.prevY = game.input.activePointer.y, null != this.prevX && (this.velX = game.input.activePointer.x - this.prevX), this.prevX = game.input.activePointer.x) : (this.clicked = !1, this.prevY = null, this.prevX = null), this._x += this.velX, this._y += this.velY, this.velX *= .95, this.velY *= .95, this.updatePosition()
            }
        }, G.WorldMap.prototype.updatePosition = function() {
            var a = Math.min(this.mapHeight, this.gateLayer.getMinY() + 500);
            this.state.EDITOR && (a = this.mapHeight), this._y = game.math.clamp(this._y, game.height, Math.max(game.height, a)), this.y = game.math.clamp(Math.round(this._y), game.height, Math.max(game.height, a));
            var b = Math.max(0, .5 * (1200 - game.width));
            this._x = game.math.clamp(this._x, 320 - b, 320 + b), this.x = Math.ceil(this._x)
        }, G.WorldMap.prototype.processMaptiles = function(a) {
            this.mapHeight = a.totalHeight, this.editorMode && (this.mapHeight *= 2);
            for (var b = 0; b < a.tiles.length; b++) {
                var c = a.tiles[b],
                    d = game.cache.getRenderTexture(c.rt);
                img = game.make.image(0, c.y, d.texture), img.anchor.setTo(.5, 1), img.autoCull = !0, this.add(img)
            }
        }, G.WorldMap.prototype.processMaptilesStatic = function() {
            this.mapHeight = G.json.settings.mapHeight, this.editorMode && (this.mapHeight *= 2);
            for (var a = G.json.settings.mapHeight, b = 0, c = 0; 0 < a;) {
                var d = "Map_background_tileable_" + b % 4;
                G.makeImage(0, c, d, [.5, 1], this).autoCull = !0;
                var e = game.cache.getFrame(d).height;
                c -= e, a -= e, b++
            }
        }, G.WorldMap.prototype.refreshButtons = function() {
            this.btnLayer.refreshData()
        }, G.WorldMap.prototype.processAnimElements = function(a) {
            a.forEach(function(a) {
                var b = G.makeImage(a[0], a[1], a[2], .5, this);
                b.tweenY = game.add.tween(b).to({
                    y: b.y - G.l(20)
                }, 5e3, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), b.angle = -15, b.tweenAngle = game.add.tween(b).to({
                    angle: 15
                }, 1e4, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), b.tweenY.timeline[0].dt = Math.random() * b.tweenY.timeline[0].duration, b.tweenAngle.timeline[0].dt = Math.random() * b.tweenAngle.timeline[0].duration
            }, this)
        }, G.WorldMap.prototype.lockInput = function() {
            this.lockedInput = !0, this.btnLayer.ignoreChildInput = !0, this.chestLayer.lockInput(), this.gateLayer.lockInput()
        }, G.WorldMap.prototype.unlockInput = function() {
            this.lockedInput = !1, this.btnLayer.ignoreChildInput = !1, this.chestLayer.unlockInput(), this.gateLayer.unlockInput()
        }, G.WorldMap.prototype.afterLvlPartBatch = function(a, b, c) {
            console.log("after lvl batch");
            var d = "coins" == c,
                e = this.btnLayer.getButtonObj(a);
            if (e) {
                var f = this.state.uiTargetParticlesBW.createDividedBatch(game.world.bounds.x + e.worldPosition.x, e.worldPosition.y, d ? "coin_1" : "map_star_1", d ? this.state.panel.coinsTxt : this.state.panel.starsTxt, b, d ? 5 : 1);
                f.addOnPartStart(function() {
                    d && this.scale.setTo(.75), this.speedDelta = 1.5, this.speedMax = 35;
                    var a = 0,
                        b = G.lnf(-2 * Math.random() - 5),
                        c = game.rnd.realInRange(-2.5, 2.5),
                        e = this.y,
                        f = game.rnd.realInRange(-2.5, 2.5);
                    this.update = function() {
                        this.grounded || (this.x += c, e += f, 0 < (a += b) ? 4 < Math.abs(b) ? b *= -.7 : (verVelX = 0, !(f = c = 0), game.time.events.add(game.rnd.between(200, 600), function() {
                            this.update = G.UITargetParticle.prototype.update
                        }, this)) : b += .5, a = Math.min(0, a), this.y = e + a)
                    }
                }), f.addOnPartFinish(function() {
                    if (d) G.saveState.changeCoins(this.carriedValue, !0);
                    else {
                        var a = this.state.panel.starsTxt;
                        a.setText(parseInt(a.text) + 1)
                    }
                }), this.batchesWaitingForFinish++, f.onFinish.add(function() {
                    this.batchesWaitingForFinish--, 0 == this.batchesWaitingForFinish && (this.afterBatch(), G.saveState.save())
                }, this), f.start()
            }
        }, G.WorldMap.prototype.afterBatch = function() {
            var a = G.saveState.getAllStars(),
                b = G.json.settings.mapChests.filter(function(b) {
                    return b.req <= a && !G.saveState.data.mapChests[b.id]
                })[0];
            if (b) this.scrollToPoint({
                x: b.mapX,
                y: b.mapY
            }), G.sb("mapChestWindowClosed").addOnce(function() {
                this.scrollToPoint({
                    lvlNr: G.saveState.getLastPassedLevelNr()
                })
            }, this);
            else {
                if (this.unlockInput(), G.saveState.getLastPassedLevelNr() == G.json.levels.length) return;
                if (G.saveState.getLastPassedLevelNr() === G.saveState.getFirstClosedGateLvLIndex()) return;
                G.json.settings.bubbleGifts.find(function(a) {
                    return a.levelNumber - 1 == G.saveState.getLastPassedLevelNr() && !G.saveState.isBubbleGiftUsed(a.levelNumber)
                }) || (game.math.clamp(G.saveState.getLastPassedLevelNr(), 0, G.json.levels.length - 1), G.lvlNr = G.saveState.getLastPassedLevelNr(), G.lvlData = G.json.levels[G.saveState.getLastPassedLevelNr()], G.sb("pushWindow").dispatch("level"))
            }
        }, G.WorldMapCoinLayer = function(a) {
            Phaser.Group.call(this, game), this.position = a.position, this.inputEnabledChildren = !1
        }, G.WorldMapCoinLayer.prototype = Object.create(Phaser.Group.prototype), G.WorldMapCoinLayer.prototype.update = function() {
            this.sort("y", Phaser.Group.SORT_ASCENDING);
            for (var a = this.children.length; a--;) this.children[a].update()
        }, G.WorldMapCoinLayer.prototype.rewardOnLvl = function(a, b, c) {
            for (var d = G.l(G.json.levels[a].mapX), e = G.l(G.json.levels[a].mapY), f = b; 0 < f;) this.add(new G.WorldMapRewardPart(d, e, "coin", Math.min(f, 15))), f -= 15;
            for (var g = 0; g < c; g++) this.add(new G.WorldMapRewardPart(d, e, "star"))
        }, G.WorldMapRewardPart = function(a, b, c, d) {
            Phaser.Image.call(this, game, a, b), G.changeTexture(this, "coin" == c ? "coin_1" : "star"), this.rewardType = c, this.coinValue = d || 0, this.anchor.setTo(.5), this.scale.setTo("coin" == c ? .5 : .3), this.verOffsetY = 0, this.verVelY = G.lnf(-2 * Math.random() - 3), this.velX = G.lnf(3 * Math.random() - 1.5), this.yy = b, this.velYY = G.lnf(3 * Math.random() - 1.5), this.grounded = !1
        }, G.WorldMapRewardPart.prototype = Object.create(Phaser.Image.prototype), G.WorldMapRewardPart.prototype.update = function() {
            this.grounded || (this.x += this.velX, this.yy += this.velYY, this.verOffsetY += this.verVelY, this.verVelY += .2, 0 < this.verOffsetY && (2 < Math.abs(this.verVelY) ? this.verVelY *= -.6 : (this.verVelX = 0, this.velX = 0, this.velYY = 0, this.grounded = !0, game.time.events.add(Math.floor(500 * Math.random() + 200), function() {
                G.sb("onMapToUIPart").dispatch(this), this.destroy()
            }, this))), this.verOffsetY = Math.min(0, this.verOffsetY), this.y = this.yy + this.verOffsetY)
        }, G.WorldMapLvlButton = function() {
            G.Button.call(this, 0, 0, null, this.handleClick, this), this.state = game.state.getCurrentState(), this.starsImg = G.makeImage(0, 30, null, .5, this), this.lvlNrTxt = this.addChild(new G.Text(0, -16, " ", {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "white",
                stroke: "#1f6185",
                strokeThickness: 5
            }, .5, 60)), this.state = game.state.getCurrentState(), this.addTerm(function() {
                return !G.saveState.isLevelBehindGate(this.lvlIndex)
            }, this), this.kill(), this.state.EDITOR && G.sb("editorLevelSelected").add(this.editorCheckTint, this)
        }, G.WorldMapLvlButton.prototype = Object.create(G.Button.prototype), G.WorldMapLvlButton.prototype.handleClick = function() {
            console.log("HANDLING CLICK"), (this.state.EDITOR || this.lvlAvailable) && (this.state.EDITOR ? (this.state.selectLevel(this.lvlIndex), this.IMMEDIATE = !0) : 0 == G.saveState.getCurrentLivesNr() ? G.sb("pushWindow").dispatch("buyLives") : ((0 != this.lvlIndex || G.saveState.data.firstTimeBtn[this.lvlIndex]) && (1 != this.lvlIndex || G.saveState.data.firstTimeBtn[this.lvlIndex]) || (G.saveState.data.firstTimeBtn[this.lvlIndex] = !0, G.saveState.save()), G.lvlNr = this.lvlIndex, G.lvlData = G.json.levels[this.lvlIndex], G.sb("pushWindow").dispatch("level")))
        }, G.WorldMapLvlButton.prototype.revealChange = function() {
            game.add.tween(this.starsImg.scale).to({
                x: 1,
                y: 1
            }, 500, Phaser.Easing.Elastic.Out, !0, 1500).onComplete.add(function() {
                this.inputEnabled = !0, this.input.useHandCursor = !0
            }, this), this.state.lastLevelData.lvlNr = -999
        }, G.WorldMapLvlButton.prototype.init = function(a, b) {
            this.alpha = 1, this.stopPulse(), this.revive(), G.stopTweens(this), G.stopTweens(this.starsImg), this.starsImg.scale.setTo(1), this.x = G.l(b.mapX), this.y = G.l(b.mapY), this.lvlIndex = a, this.lvlAvailable = G.saveState.isLevelAvailable(this.lvlIndex), this.lvlStarsNr = G.saveState.getStars(this.lvlIndex), this.lvlAvailable ? (this.lvlNrTxt.visible = !0, this.lvlNrTxt.setText((this.lvlIndex + 1).toString()), 0 == this.lvlStarsNr ? (G.changeTexture(this, "map_point_2"), G.changeTexture(this.starsImg, null), this.lvlNrTxt.stroke = "#997b11", this.pulse()) : (G.changeTexture(this, "map_point_1"), this.lvlNrTxt.stroke = "#1f6185", G.changeTexture(this.starsImg, "map_star_" + this.lvlStarsNr)), this.inputEnabled = !0, this.input.useHandCursor = !0) : (G.changeTexture(this, "map_point_3"), G.changeTexture(this.starsImg, null), this.lvlNrTxt.visible = !1, this.alpha = .5, this.inputEnabled = !1, this.input.useHandCursor = !1);
            var c = G.json.settings.gates.find(function(b) {
                return b.lvlNr === a + 1
            });
            c && (c.lvlNr - 1 <= G.saveState.getLastPassedLevelNr() || (this.alpha = 0)), this.state.EDITOR && this.editorCheckTint()
        }, G.WorldMapLvlButton.prototype.editorCheckTint = function() {
            this.state.EDITOR && (this.tint = this.state.selectedLevels.includes(this.lvlIndex) ? 65280 : 16777215)
        }, G.WorldMapLvls = function(a) {
            G.PoolGroup.call(this, G.WorldMapLvlButton), this.position = a.position, this.lvlBtnCoords = G.json.levels.map(function(a, b) {
                return {
                    mapY: G.l(a.mapY),
                    lvlIndex: b,
                    btnObj: null,
                    lvlData: a
                }
            }).sort(function(a, b) {
                return a.mapY - b.mapY
            }), G.sb("onWindowOpened").add(this.lockInput, this), G.sb("onWindowClosed").add(this.unlockInput, this)
        }, G.WorldMapLvls.prototype = Object.create(G.PoolGroup.prototype), G.WorldMapLvls.prototype.refreshData = function() {
            this.lvlBtnCoords.forEach(function(a, b) {
                a.btnObj && this.detachButton(b)
            }, this), this.lvlBtnCoords = G.json.levels.map(function(a, b) {
                return {
                    mapY: G.l(a.mapY),
                    lvlIndex: b,
                    btnObj: null,
                    lvlData: a
                }
            })
        }, G.WorldMapLvls.prototype.getButtonObj = function(a) {
            for (var b = 0; b < this.children.length; b++) {
                var c = this.children[b];
                if (c.lvlIndex == a) return c
            }
        }, G.WorldMapLvls.prototype.update = function() {
            for (var a = this.y - game.height, b = !1, c = 0; c < this.lvlBtnCoords.length; c++) a - G.l(40) + this.lvlBtnCoords[c].mapY < 0 && 0 < a + game.height + G.l(40) + this.lvlBtnCoords[c].mapY ? (null === this.lvlBtnCoords[c].btnObj && this.attachButton(c), b = !0) : null !== this.lvlBtnCoords[c].btnObj ? this.detachButton(c) : b
        }, G.WorldMapLvls.prototype.attachButton = function(a) {
            this.lvlBtnCoords[a].btnObj = this.getFreeElement(), this.lvlBtnCoords[a].btnObj.init(this.lvlBtnCoords[a].lvlIndex, this.lvlBtnCoords[a].lvlData)
        }, G.WorldMapLvls.prototype.detachButton = function(a) {
            this.lvlBtnCoords[a].btnObj.kill(), this.lvlBtnCoords[a].btnObj = null
        }, G.WorldMapLvls.prototype.unlockInput = function() {
            this.ignoreChildInput = !1
        }, G.WorldMapLvls.prototype.lockInput = function() {
            this.ignoreChildInput = !0
        }, G.Booster = function(a, b, c) {
            this.board = G.lvl.state.board, this.am = this.board.actionManager, this.cellX = a, this.cellY = b, Phaser.Image.call(this, game, this.board.cellXToPxIn(a), this.board.cellYToPxIn(b - 2)), this.anchor.setTo(.5), this.boosterNr = c, this.orgY = this.y, this.targetY = this.board.cellYToPxIn(b), G.changeTexture(this, "ui_booster_" + c), this.alpha = 0, this.scale.setTo(2), game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 700, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this).to({
                alpha: 1
            }, 700, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                game.add.tween(this).to({
                    y: this.targetY
                }, 300, Phaser.Easing.Cubic.In, !0).onComplete.add(function() {
                    var a = this.getMatchCandy(this.boosterNr);
                    3 == this.boosterNr && (G.sb("fx").dispatch("strokeH", a), G.sb("fx").dispatch("lightCircle", a), G.sb("fx").dispatch("explosion", a)), 4 == this.boosterNr && (G.sb("fx").dispatch("strokeV", a), G.sb("fx").dispatch("lightCircle", a), G.sb("fx").dispatch("explosion", a)), this.board.checkSpecialMatchList.push(a), this.am.newAction("processMatch"), this.am.removeAction(), game.add.tween(this).to({
                        y: this.orgY,
                        alpha: 0
                    }, 600, Phaser.Easing.Cubic.Out, !0), game.time.events.add(600, this.destroy, this)
                }, this)
            }, this)
        }, G.Booster.prototype = Object.create(Phaser.Image.prototype), G.Booster.prototype.getMatchCandy = function(a) {
            return 2 == a ? {
                cellX: this.cellX,
                cellY: this.cellY,
                exe: [
                    ["specific", [0, 0]]
                ]
            } : 3 == a ? {
                cellX: this.cellX,
                cellY: this.cellY,
                exe: [
                    ["loop", {
                        x: -1,
                        y: 0
                    }],
                    ["loop", {
                        x: 1,
                        y: 0
                    }]
                ]
            } : 4 == a ? {
                cellX: this.cellX,
                cellY: this.cellY,
                exe: [
                    ["loop", {
                        x: 0,
                        y: -1
                    }],
                    ["loop", {
                        x: 0,
                        y: 1
                    }]
                ]
            } : void 0
        }, G.BoosterHorizontal = function(a, b, c) {
            this.board = G.lvl.state.board, this.am = this.board.actionManager, this.cellX = a, this.cellY = b, Phaser.Image.call(this, game, this.board.cellXToPxIn(-.5), this.board.cellYToPxIn(b)), this.anchor.setTo(.5), this.oldCellX = -1, this.boosterNr = c, this.active = !1, this.orgY = this.y, this.targetX = this.board.cellYToPxIn(this.board.boardData.width) + G.l(30), G.changeTexture(this, "ui_booster_" + c), this.alpha = 0, this.scale.setTo(2), game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 1e3, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this).to({
                alpha: 1
            }, 1e3, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.active = !0
            }, this)
        }, G.BoosterHorizontal.prototype = Object.create(Phaser.Image.prototype), G.BoosterHorizontal.prototype.update = function() {
            if (this.active) {
                this.x += G.l(10);
                var a, b = this.board.pxInToCellX(this.x);
                b != this.oldCellX && (this.oldCellX = b, (a = this.board.getCandy(b - 1, this.cellY)) && (this.board.hitCell(b - 1, this.cellY), this.board.isCellMatchable(b - 1, this.cellY) && (this.board.boardDirt.isToken(b - 1, this.cellY) && this.board.boardDirt.onMatch(b - 1, this.cellY), this.board.boardCage.isToken(b - 1, this.cellY) ? this.board.boardCage.onMatch(b - 1, this.cellY) : a.special ? this.board.checkSpecialMatchList.push(a) : (a.match(), G.sfx.boom.play(), G.lvl.processMatch(1, a.cellX, a.cellY))))), this.x >= this.targetX && 0 == this.board.duringAnimation && (this.active = !1, this.am.newAction(0 == this.board.checkSpecialMatchList.length ? "processFall" : "processMatch"), G.sb("onBoosterActionFinished").dispatch(), this.am.removeAction(), this.destroy())
            }
        }, G.BoosterSelection = function(a, b, c) {
            this.board = G.lvl.state.board, this.am = this.board.actionManager, this.cellX = a, this.cellY = b, Phaser.Image.call(this, game, this.board.cellXToPxIn(a), this.board.cellYToPxIn(b)), this.alpha = 0, this.follow = c, this.anchor.setTo(0), G.changeTexture(this, "tut_hand"), this.offsetTween = 0, game.add.tween(this).to({
                offsetTween: G.l(20)
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 0, -1, !0), this.alphaTween = game.add.tween(this).to({
                alpha: .8
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.BoosterSelection.prototype = Object.create(Phaser.Image.prototype), G.BoosterSelection.prototype.update = function() {
            this.x = this.follow.x + this.offsetTween, this.y = this.follow.y + this.offsetTween
        }, G.BoosterSelection.prototype.hide = function() {
            this.alphaTween.stop(), game.add.tween(this).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0, 200).onComplete.add(function() {
                this.destroy()
            }, this)
        }, G.BoosterVertical = function(a, b, c) {
            this.board = G.lvl.state.board, this.am = this.board.actionManager, this.cellX = a, this.cellY = b, Phaser.Image.call(this, game, this.board.cellXToPxIn(a), this.board.cellYToPxIn(-.5)), this.anchor.setTo(.5), this.boosterNr = c, this.oldCellY = -1, this.orgY = this.y, this.targetY = this.board.cellYToPxIn(this.board.boardData.height) + G.l(30), G.changeTexture(this, "ui_booster_" + c), this.alpha = 0, this.scale.setTo(2), game.add.tween(this.scale).to({
                x: 1,
                y: 1
            }, 1e3, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this).to({
                alpha: 1
            }, 1e3, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.active = !0
            }, this)
        }, G.BoosterVertical.prototype = Object.create(Phaser.Image.prototype), G.BoosterVertical.prototype.getMatchCandy = function(a) {
            return 2 == a ? {
                cellX: this.cellX,
                cellY: this.cellY,
                exe: [
                    ["specific", [0, 0]]
                ]
            } : 3 == a ? {
                cellX: this.board.boardData.width - 1,
                cellY: this.cellY,
                exe: [
                    ["loop", {
                        x: -1,
                        y: 0
                    }],
                    ["loop", {
                        x: 1,
                        y: 0
                    }]
                ]
            } : 4 == a ? {
                cellX: this.cellX,
                cellY: this.board.boardData.height - 1,
                exe: [
                    ["loop", {
                        x: 0,
                        y: -1
                    }],
                    ["loop", {
                        x: 0,
                        y: 1
                    }]
                ]
            } : void 0
        }, G.BoosterVertical.prototype.update = function() {
            if (this.active) {
                this.y += G.l(10);
                var a, b = this.board.pxInToCellY(this.y);
                b != this.oldCellY && (this.oldCellY = b, (a = this.board.getCandy(this.cellX, b - 1)) && (this.board.hitCell(this.cellX, b - 1), this.board.isCellMatchable(this.cellX, b - 1) && (this.board.boardDirt.isToken(this.cellX, b - 1) && this.board.boardDirt.onMatch(this.cellX, b - 1), this.board.boardCage.isToken(this.cellX, b - 1) ? this.board.boardCage.onMatch(this.cellX, b - 1) : a.special ? this.board.checkSpecialMatchList.push(a) : (a.match(), G.sfx.boom.play(), G.lvl.processMatch(1, a.cellX, a.cellY))))), this.y >= this.targetY && 0 == this.board.duringAnimation && (this.active = !1, this.am.newAction(0 == this.board.checkSpecialMatchList.length ? "processFall" : "processMatch"), G.sb("onBoosterActionFinished").dispatch(), this.am.removeAction(), this.destroy())
            }
        }, G.GingerMapButton = function() {
            Phaser.Group.call(this, game), G.GINGEREVENT && (this.timer = new G.TextTimer(-13, 113, Date.now() + 36e6, {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#ec308f",
                strokeThickness: 6
            }, [.5, 0], 300), this.timer.setShadow(0, 4, "rgba(0,0,0,0.5)", 0, !0, !1), this.add(this.timer), this.mainButton = new G.Button(0, 0, "Button_Map", function() {
                G.sb("pushWindow").dispatch("gingerJoin")
            }, this), this.mainButton.label = new G.Text(-9, 84, "Cookie Quest", {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#ec308f"
            }, .5, 170), this.mainButton.addChild(this.mainButton.label), this.add(this.mainButton)), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.GingerMapButton.prototype = Object.create(Phaser.Group.prototype), G.GingerMapButton.prototype.onResize = function() {
            var a = game.world.bounds.x + Math.floor(.5 * game.width);
            this.x = a - 200, this.y = game.height - 365
        }, G.GingerRanking = function() {
            Phaser.Group.call(this, game), this.bg = G.makeImage(-204, 0, "Ranking_Board_Long", 0, this), this.bg.inputEnabled = !0, this.bg.events.onInputDown.add(function() {
                this.clicked = !0
            }, this), this.clicked = !1, this.rankingGroup = this.add(game.make.group()), this.rankingGroup.x = -204, this.rankingGroup.y = 55, this.maskGfx = this.add(game.add.graphics()), this.maskGfx.y = 55, this.maskGfx.x = -204, this.maskGfx.beginFill(16711680, 1), this.maskGfx.drawRect(0, 0, 408, 326), this.rankingUsers = [], this.rankingGroup.mask = this.maskGfx, this.initRanking(), this.inputPrevY = 0, this.inputVelY = 0, this.rankingTitle = new G.Text(0, 25, "Your team", {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "40px"
            }, .5, 400), this.add(this.rankingTitle)
        }, G.GingerRanking.prototype = Object.create(Phaser.Group.prototype), G.GingerRanking.prototype.update = function() {
            this.updateInput()
        }, G.GingerRanking.prototype.updateInput = function() {
            if (this.clicked && game.input.activePointer.isDown) {
                if (null !== this.inputPrevY) {
                    var a = .5 * (game.input.activePointer.y - this.inputPrevY);
                    this.inputVelY = a
                }
                this.inputPrevY = game.input.activePointer.y
            } else this.clicked = !1, this.inputPrevY = null;
            this.rankingGroup.y += this.inputVelY, this.boundRistrict(), this.inputVelY *= .95, Math.abs(this.inputVelY) < 1 && (this.inputVelY = 0)
        }, G.GingerRanking.prototype.boundRistrict = function() {
            var a = Math.min(55, 55 - (this.rankingGroup.height - 326));
            55 < this.rankingGroup.y && (this.rankingGroup.y = G.lerp(this.rankingGroup.y, 55, .5), this.rankingGroup.y < 56 && (this.rankingGroup.y = 55)), this.rankingGroup.y < a && (this.rankingGroup.y = G.lerp(this.rankingGroup.y, a, .5), this.rankingGroup.y > a + 1 && (this.rankingGroup.y = a))
        }, G.GingerRanking.prototype.initRanking = function(a) {
            a = [{
                rank: 1,
                name: "sodomo",
                gingerAmount: 15,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 2,
                name: "Annie",
                gingerAmount: 13,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 3,
                name: "John",
                gingerAmount: 12,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 4,
                name: "Hell",
                gingerAmount: 10,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 5,
                name: "Dubious",
                gingerAmount: 8,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 6,
                name: "Krrr",
                gingerAmount: 3,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 7,
                name: "Goldie",
                gingerAmount: 0,
                avatar: sgSettings.config.user.avatar
            }];
            for (var b = 0; b < a.length; b++) this.initUser(30 + 60 * b, a[b])
        }, G.GingerRanking.prototype.initUser = function(a, b) {
            var c = new G.Text(30, a, b.rank.toString(), {
                fill: "#007D5D",
                font: "ComicSansBold",
                fontSize: "30px"
            }, .5, 50);
            this.rankingGroup.add(c), G.makeExtImage(80, a, b.avatar, "avatar_m", .5, this.rankingGroup, !1, function() {
                this.width = this.height = 50
            });
            var d = new G.Text(120, a, b.name, {
                fill: "#007D5D",
                font: "ComicSansBold",
                fontSize: "30px"
            }, [0, .5], 160);
            this.rankingGroup.add(d);
            var e = G.makeImage(340, a - 4, "Ranking_Small_Counter", .5, this.rankingGroup),
                f = new G.Text(355, a, b.gingerAmount.toString(), {
                    fill: "white",
                    font: "ComicSansBold",
                    fontSize: "30px"
                }, .5, 40);
            this.rankingGroup.add(f), this.rankingUsers.push({
                userData: b,
                rankTxt: c,
                nameTxt: d,
                gingerBg: e,
                gingerTxt: f
            })
        }, G.dailyCheck = function() {
            function a() {
                new G.Window("daily2"), G.saveState.data.lastDaily = [b.getYear(), b.getMonth(), b.getDate()], G.saveState.save()
            }
            var b = new Date,
                c = G.saveState.data.lastDaily;
            c ? c[2] == b.getDate() && c[1] == b.getMonth() && c[0] == b.getYear() || a() : (G.saveState.data.spins++, G.saveState.save(), a())
        }, G.DailyCoin = function(a, b, c) {
            Phaser.Image.call(this, game, G.l(a), G.l(b)), this.state = game.state.getCurrentState(), this.anchor.setTo(.5), G.changeTexture(this, "coin_1"), this.rewardType = "coin", this.coinValue = c, this.scale.setTo(.75), this.target = this.state.panel.coinIco, game.add.existing(this);
            var d = this.target;
            game.add.tween(this).to({
                x: game.world.bounds.x + d.worldPosition.x,
                y: this.target.worldPosition.y,
                width: d.width,
                height: d.height
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0).onComplete.add(function() {
                G.saveState.changeCoins(this.coinValue), G.sb("onMapToUIPartFinished").dispatch(this), this.destroy()
            }, this)
        }, G.DailyCoin.prototype = Object.create(Phaser.Image.prototype), G.DailyCoin.prototype.update = function() {
            this.target
        }, G.DailyWheel = function(a, b) {
            Phaser.Group.call(this, game), (D = this).state = game.state.getCurrentState(), this.x = G.l(a), this.y = G.l(b), this.prizeTable = G.json.settings.wheelPrizes, this.prizeTableGold = G.json.settings.wheelPrizesGold, this.prizeTable.forEach(function(a) {
                G.gift.processRandomBoosters(a.prize)
            }), this.prizeTableGold.forEach(function(a) {
                G.gift.processRandomBoosters(a.prize)
            }), this.angleBetweenFields = 360 / this.prizeTable.length, this.anglePrizeStartOffset = this.angleBetweenFields / 2, this.angleDiffSinceLastPin = 0, this.angleBetweenPins = 15, this.angleSpeedMulti = .985, this.wheelGfx = this.add(this.makeWheelGfx(0, 0, "prize_wheel_2", this.prizeTable)), this.wheelGfxGold = this.add(this.makeWheelGfx(0, 0, "gold_wheel", this.prizeTableGold)), this.wheelPointer = this.add(this.makeWheelPointer(0, -180, "prize_wheel_arrow")), WH = this.wheelGfx, this.wheelGfx.wheelDistancePassed = 0, this.wheelGfx.prevDistancePassed = 0, this.wheelGfx.inputEnabled = !0, this.pointer = null, this.pointerStartX = 0, this.pointerClickedDate = 0, this.launched = !1, this.finished = !1, this.wheelGfx.events.onInputDown.add(function() {
                var a = game.input.activePointer;
                this.pointerStartX.worldX, this.pointerClickedDate = Date.now(), this.pointer = a
            }, this), this.onFinish = new Phaser.Signal, this.gold = !1
        }, G.DailyWheel.prototype = Object.create(Phaser.Group.prototype), G.DailyWheel.prototype.changeToRegular = function() {
            this.gold = !1
        }, G.DailyWheel.prototype.changeToGold = function() {
            this.gold = !0
        }, G.DailyWheel.prototype.update = function() {
            if (this.wheelGfxGold.angle = this.wheelGfx.angle, this.gold ? (this.wheelGfx.alpha = G.lerp(this.wheelGfx.alpha, 0, .1, .02), this.wheelGfxGold.alpha = G.lerp(this.wheelGfxGold.alpha, 1, .1, .02)) : (this.wheelGfx.alpha = G.lerp(this.wheelGfx.alpha, 1, .1, .02), this.wheelGfxGold.alpha = G.lerp(this.wheelGfxGold.alpha, 0, .1, .02)), this.wheelPointer.update(), !this.finished) {
                if (this.launched) {
                    var a = this.updateLaunched();
                    a && (this.onFinish.dispatch(a.prize), this.finished = !0)
                } else null !== this.pointer && this.pointer.isDown;
                for (var b = this.children.length; b--;) this.children[b].update()
            }
        }, G.DailyWheel.prototype.restart = function() {
            this.finished && (this.launched = !1, this.pointer = null, this.finished = !1, this.giftGfx && game.add.tween(this.giftGfx.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Cubic.In, !0).onComplete.add(function() {
                this.destroy()
            }, this.giftGfx), this.wheelGfx.inputEnabled = !0)
        }, G.DailyWheel.prototype.launch = function(a) {
            for (this.wheelGfx.inputEnabled = !1;;) {
                var b = this.testSpin(a, this.wheelGfx.prevDistancePassed, this.wheelGfx.wheelDistancePassed);
                if (!b.keep) break;
                if (!(Math.random() > b.keep)) break;
                a += 80
            }
            this.wheelGfx.angleSpeed = .025 * a, this.launched = !0
        }, G.DailyWheel.prototype.updateLaunched = function() {
            return this.updateWheel(this.wheelGfx, !0)
        }, G.DailyWheel.prototype.applyPrize = function() {}, G.DailyWheel.prototype.testSpin = function(a, b, c) {
            var d = {
                angle: 0
            };
            for (d.angleSpeed = .025 * a, d.prevDistancePassed = b || 0, d.wheelDistancePassed = c || 0;;) {
                var e = this.updateWheel(d);
                if (e) return e
            }
        }, G.DailyWheel.prototype.updateWheel = function(a, b) {
            a.angle += a.angleSpeed;
            var c = a.wheelDistancePassed;
            return a.wheelDistancePassed += a.angleSpeed, Math.floor(c / this.angleBetweenPins) !== Math.floor(a.wheelDistancePassed / this.angleBetweenPins) && (b && this.wheelPointer.bounce(-1 * Math.sign(a.angleSpeed)), a.angleSpeed = .95 * a.angleSpeed, a.angleSpeed < .25 && (a.wheelDistancePassed = c, a.angle = game.math.wrapAngle(c), a.angleSpeed *= -.5)), a.angleSpeed *= this.angleSpeedMulti, this.wheelGfxGold.angle = a.angle, Math.abs(a.angleSpeed) < .05 && this.getPrizeFromAngle(a.angle)
        }, G.DailyWheel.prototype.getPrizeFromAngle = function(a) {
            var b = a + 180;
            return a < 0 && (b = 180 + a), (this.gold ? this.prizeTableGold : this.prizeTable)[Math.floor(b / this.angleBetweenFields)]
        }, G.DailyWheel.prototype.makeWheelGfx = function(a, b, c, d) {
            wheel = G.makeImage(0, 0, c, .5), wheel.labels = wheel.addChild(game.make.group());
            for (var e = d.length - 1, f = this.anglePrizeStartOffset; f < 360; f += this.angleBetweenFields) {
                var g = d[e],
                    h = new G.LabelGroupT(G.gift.getLabelString(g.prize, 1.4), G.lengthDirX(90 + f, 160, !1), G.lengthDirY(90 + f, 160, !1), {
                        font: "ComicSansBold",
                        fontSize: "25px",
                        fill: "#ece9e5",
                        stroke: "#817F81",
                        strokeThickness: 7
                    }, [1, .5], 200);
                h.angle = 90 + f, wheel.labels.add(h), e--
            }
            return wheel.labels.cacheAsBitmap = !0, wheel
        }, G.DailyWheel.prototype.makeWheelPointer = function(a, b, c) {
            var d = G.makeImage(a, b, c, .5, null);
            return d.soundTimer = 2, d.bounce = function(a) {
                this.soundTimer < 0 && (G.sfx.pop.play(), this.soundTimer = 2), this.angle = 10 * a
            }, d.update = function() {
                this.soundTimer--, this.angle = G.lerp(this.angle, 0, .2)
            }, d
        }, G.GiftUnwrapAnim = function(a, b, c) {
            Phaser.Group.call(this, game), this.giftData = c, this.x = G.l(a), this.y = G.l(b), this.light = G.makeImage(0, 0, "popup_lighht", .5, this), this.light.update = function() {
                this.angle++
            }, this.light.alpha = 0, this.light.blendMode = 1, game.add.tween(this.light).to({
                alpha: .2
            }, 1e3, Phaser.Easing.Cubic.Out, !0), game.add.tween(this.light).to({
                angle: 360
            }, 3e3, Phaser.Easing.Linear.None, !0, 0, -1, !1), this.inside = new G.LabelGroupT(G.gift.getLabelString(this.giftData), 0, 0, {
                font: "ComicSansBold",
                fontSize: "90px",
                fill: "white"
            }, .5, 180), this.add(this.inside), this.inside.scale.setTo(.5, 0), game.add.tween(this.inside.scale).to({
                x: 1,
                y: 1
            }, 800, Phaser.Easing.Elastic.Out, !0), G.sfx.xylophone_positive_12.play()
        }, G.GiftUnwrapAnim.prototype = Object.create(Phaser.Group.prototype), G.GiftUnwrapAnim.prototype.hide = function() {
            game.add.tween(this).to({
                alpha: 0
            }, 500, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.destroy()
            }, this)
        }, G.DailyRewardBoxIcon = function(a, b, c) {
            Phaser.Group.call(this, game), this.position.setTo(a, b), G.json.settings.dailyReward.days[c - 1].boxIcon.forEach(function(a) {
                var b = a.sprite || "medium_green_present",
                    c = a.pos || [0, 0],
                    d = a.scale || [1, 1];
                G.makeImage(c[0], c[1], b, .5, this).scale.setTo(d[0], d[1])
            }, this)
        }, G.DailyRewardBoxIcon.prototype = Object.create(Phaser.Group.prototype), G.DailyRewardCurrentGift = function(a, b, c) {
            Phaser.Group.call(this, game), this.position.setTo(a, b), this.dayConfig = G.json.settings.dailyReward.days[c], this.giftPanel = this.add(new G.DailyRewardCurrentGiftPrizePanel(0, -30, this.dayConfig)), this.giftPanel.visible = !1, this.boxIcon = G.makeImage(0, 0, "big_pink_present", .5, this), this.boxJump(), this.add(this.boxIcon)
        }, G.DailyRewardCurrentGift.prototype = Object.create(Phaser.Group.prototype), G.DailyRewardCurrentGift.prototype.showReward = function() {
            game.add.tween(this.boxIcon).to({
                alpha: 0,
                width: 1.2 * this.boxIcon.width,
                height: 1.2 * this.boxIcon.height
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.giftPanel.show()
        }, G.DailyRewardCurrentGift.prototype.claimReward = function() {
            this.giftPanel.claimPrize()
        }, G.DailyRewardCurrentGift.prototype.boxJump = function() {
            if (1 == this.boxIcon.alpha && this.boxIcon.visible) {
                var a = game.add.tween(this.boxIcon).to({
                        y: -G.l(15)
                    }, 150, Phaser.Easing.Cubic.Out),
                    b = game.add.tween(this.boxIcon).to({
                        y: 0
                    }, 150, Phaser.Easing.Circular.In);
                a.chain(b), a.start();
                var c = game.add.tween(this.boxIcon).to({
                        angle: -3
                    }, 100, Phaser.Easing.Cubic.InOut),
                    d = game.add.tween(this.boxIcon).to({
                        angle: 3
                    }, 170, Phaser.Easing.Sinusoidal.In),
                    e = game.add.tween(this.boxIcon).to({
                        angle: 0
                    }, 30, Phaser.Easing.Cubic.InOut);
                c.chain(d, e), c.start(), game.time.events.add(1e3, this.boxJump, this)
            }
        }, G.DailyRewardCurrentGiftPrizePanel = function(a, b, c) {
            Phaser.Group.call(this, game), this.position.setTo(a, b), this.dayConfig = c, this.prize = JSON.parse(JSON.stringify(this.dayConfig.gifts)), this.bg = G.makeImage(0, 0, "daily_prize_panel_bg", .5, this), this.icon = "coin" === this.prize[0][0] ? G.makeImage(0, 0, "coin_3", .5, this) : this.add(new G.DailyRewardGiftIcon(0, 0, this.prize)), this.descText = this.addDescText(0, 130, this.prize), game.incentivised || (this.icon.x = -80, this.dblBtn = new G.Button(80, 0, "btn_x2", function() {
                G.gameTracking.design("NewDailyDoubleReward"), this.dblBtn.inputEnabled = !1, this.dblBtn.alpha = .5, sdkHandler.trigger("rewardedAd", {
                    callback: function(a) {
                        game.paused = !1, a ? this.dblSuccess() : this.dblFail()
                    }
                }, this)
            }, this), this.add(this.dblBtn)), this.visible = !1
        }, G.DailyRewardCurrentGiftPrizePanel.prototype = Object.create(Phaser.Group.prototype), G.DailyRewardCurrentGiftPrizePanel.prototype.show = function() {
            this.visible = !0, this.alpha = 0, game.add.tween(this).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.icon.scale.setTo(0), game.add.tween(this.icon.scale).to({
                x: 1.2,
                y: 1.2
            }, 300, Phaser.Easing.Elastic.Out, !0), this.dblBtn && (this.dblBtn.scale.setTo(0), game.add.tween(this.dblBtn.scale).to({
                x: 1,
                y: 1
            }, 300, Phaser.Easing.Elastic.Out, !0, 150)), this.descText.scale.setTo(0), game.add.tween(this.descText.scale).to({
                x: 1,
                y: 1
            }, 300, Phaser.Easing.Elastic.Out, !0, 300)
        }, G.DailyRewardCurrentGiftPrizePanel.prototype.claimPrize = function() {
            this.dblBtn && (this.dblBtn.inputEnabled = !1), this.processClaim(this.icon, this.prize), this.dblIcon && this.processClaim(this.dblIcon, this.prize)
        }, G.DailyRewardCurrentGiftPrizePanel.prototype.addDescText = function(a, b, c) {
            var d;
            return d = "coin" === c[0][0] ? G.txt("%NR% Coins").replace("%NR%", c[0][1]) : G.txt("Get more boosters!"), this.add(new G.Text(a, b, d, {
                style: "font-beige",
                fontSize: "40px",
                lineSpacing: -20
            }, .5, 400, 200, !0, "center"))
        }, G.DailyRewardCurrentGiftPrizePanel.prototype.dblSuccess = function() {
            this.dblBtn.inputEnabled = !1, game.add.tween(this.dblBtn).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.dblIcon = "coin" === this.prize[0][0] ? G.makeImage(-80, 0, "coin_3", .5, this) : this.add(new G.DailyRewardGiftIcon(-80, 0, this.prize)), this.dblIcon.scale.setTo(1.2), game.add.tween(this.dblIcon.scale).to({
                x: 1.3,
                y: 1.3
            }, 300, Phaser.Easing.Elastic.Out, !0, 0, 0, !0, 500), game.add.tween(this.dblIcon).to({
                x: 80,
                y: 0
            }, 500, Phaser.Easing.Sinusoidal.InOut, !0), this.descText.setText("coin" === this.prize[0][0] ? G.txt("%NR% Coins").replace("%NR%", 2 * this.prize[0][1]) : G.txt("Use these to boost your game!"))
        }, G.DailyRewardCurrentGiftPrizePanel.prototype.dblFail = function() {
            new G.NoMoreAds
        }, G.DailyRewardCurrentGiftPrizePanel.prototype.processClaim = function(a, b) {
            var c = game.state.getCurrentState();
            b.forEach(function(b) {
                "coin" === b[0] ? G.gameTracking.source("Coins", "Reward", "NewDailyReward", b[1]) : G.gameTracking.source(G.saveState.nrToBoosterName(b[0][8]), "Reward", "NewDailyReward", b[1]), "coin" === b[0] ? c.uiTargetParticles.createCoinBatch(game.world.bounds.x + a.worldPosition.x, a.worldPosition.y, c.panel.coinsTxt, b[1]) : G.gift.applyGift(b, !0)
            })
        }, G.DailyRewardDay = function(a, b, c) {
            Phaser.Group.call(this, game), this.position.setTo(a, b), this.bg = G.makeImage(0, 0, c.bgSprite, .5, this), this.addRibbon(0, -.5 * this.bg.height + 10, c), this.icon = this.add(c.giftsVisible ? new G.DailyRewardGiftIcon(0, 10, c.gifts) : new G.DailyRewardBoxIcon(0, 10, c.dayNr)), this.icon.height = Math.min(this.icon.height, .9 * this.bg.height), this.icon.scale.setTo(this.icon.scale.y), c.past && (this.checkedIconPast = G.makeImage(50, 0, "task_complete", .5, this)), c.today && (this.checkedIcon = G.makeImage(50, 0, "task_complete", .5, this), this.checkedIcon.alpha = 0, this.checkedIcon.scale.setTo(2))
        }, G.DailyRewardDay.prototype = Object.create(Phaser.Group.prototype), G.DailyRewardDay.prototype.checkedIconAnimation = function() {
            this.checkedIcon && (game.add.tween(this.checkedIcon).to({
                alpha: 1
            }, 400, Phaser.Easing.Cubic.In, !0), game.add.tween(this.checkedIcon.scale).to({
                x: 1,
                y: 1
            }, 400, Phaser.Easing.Cubic.In, !0))
        }, G.DailyRewardDay.prototype.addRibbon = function(a, b, c) {
            this.dayRibbon = G.makeImage(a, b, c.today ? "selected_day" : "unselected_day", .5, this), this.dayText = new G.Text(a, b, c.today ? G.txt("Today") : G.txt("Day %NR%").replace("%NR%", c.dayNr), {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "30px"
            }, .5, 76), this.add(this.dayText)
        }, G.DailyRewardDay.prototype.addBoxesIcons = function() {
            this.iconGroup = this.add(this.iconGroup)
        }, G.DailyRewardGiftIcon = function(a, b, c) {
            Phaser.Group.call(this, game), this.position.setTo(a, b), 1 == c.length ? this.addIcon(0, 0, c[0]) : (this.addIcon(20, 20, c[0]), this.addIcon(-20, -20, c[1]))
        }, G.DailyRewardGiftIcon.prototype = Object.create(Phaser.Group.prototype), G.DailyRewardGiftIcon.prototype.addIcon = function(a, b, c) {
            var d = G.makeImage(a, b, G.gift.getIcon(c), .5, this);
            1 < c[1] && (d.amountTxt = new G.Text(0, 30, "x" + c[1], {
                style: "font-beige-header",
                fontSize: "35px"
            }, .5), d.addChild(d.amountTxt)), "coin" === c[0] && (d.y -= 10, d.amountTxt.y += 10)
        }, G.DailyRewardWeek = function(a, b, c, d) {
            Phaser.Group.call(this, game), this.position.setTo(a, b), this.days = [], this.init(c, d)
        }, G.DailyRewardWeek.prototype = Object.create(Phaser.Group.prototype), G.DailyRewardWeek.prototype.init = function(a) {
            for (var c = G.json.settings.dailyReward.days, d = 0; d < 7; d++) {
                var e;
                e = d === a ? "current_day_box" : d < a ? "passed_day_box" : "future_day_box", e += 6 === d ? "_big" : "";
                var f = new G.DailyRewardDay(d % 3 * 140 - 140, 135 * Math.floor(d / 3) - 135, {
                    gifts: c[d].gifts,
                    dayNr: d + 1,
                    past: d < a,
                    today: d === a,
                    bgSprite: e,
                    giftsVisible: d <= a
                });
                f.scale.setTo(0), game.add.tween(f.scale).to({
                    x: 1,
                    y: 1
                }, 200, Phaser.Easing.Sinusoidal.Out, !0, 50 + 50 * d), 6 == d && (f.x += 140), this.add(f), this.days.push(f)
            }
            game.time.events.add(50 + 50 * d, function() {
                this.days.forEach(function(a) {
                    a.checkedIconAnimation()
                })
            }, this)
        }, G.GingerMapButton = function() {
            Phaser.Group.call(this, game), G.GINGEREVENT && (this.timer = new G.TextTimer(-13, 113, Date.now() + 36e6, {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#ec308f",
                strokeThickness: 6
            }, [.5, 0], 300), this.timer.setShadow(0, 4, "rgba(0,0,0,0.5)", 0, !0, !1), this.add(this.timer), this.mainButton = new G.Button(0, 0, "Button_Map", function() {
                G.sb("pushWindow").dispatch("gingerJoin")
            }, this), this.mainButton.label = new G.Text(-9, 84, "Cookie Quest", {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "30px",
                stroke: "#ec308f"
            }, .5, 170), this.mainButton.addChild(this.mainButton.label), this.add(this.mainButton)), G.sb("onScreenResize").add(this.onResize, this), this.onResize()
        }, G.GingerMapButton.prototype = Object.create(Phaser.Group.prototype), G.GingerMapButton.prototype.onResize = function() {
            var a = game.world.bounds.x + Math.floor(.5 * game.width);
            this.x = a - 200, this.y = game.height - 365
        }, G.GingerRanking = function() {
            Phaser.Group.call(this, game), this.bg = G.makeImage(-204, 0, "Ranking_Board_Long", 0, this), this.bg.inputEnabled = !0, this.bg.events.onInputDown.add(function() {
                this.clicked = !0
            }, this), this.clicked = !1, this.rankingGroup = this.add(game.make.group()), this.rankingGroup.x = -204, this.rankingGroup.y = 55, this.maskGfx = this.add(game.add.graphics()), this.maskGfx.y = 55, this.maskGfx.x = -204, this.maskGfx.beginFill(16711680, 1), this.maskGfx.drawRect(0, 0, 408, 326), this.rankingUsers = [], this.rankingGroup.mask = this.maskGfx, this.initRanking(), this.inputPrevY = 0, this.inputVelY = 0, this.rankingTitle = new G.Text(0, 25, "Your team", {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "40px"
            }, .5, 400), this.add(this.rankingTitle)
        }, G.GingerRanking.prototype = Object.create(Phaser.Group.prototype), G.GingerRanking.prototype.update = function() {
            this.updateInput()
        }, G.GingerRanking.prototype.updateInput = function() {
            if (this.clicked && game.input.activePointer.isDown) {
                if (null !== this.inputPrevY) {
                    var a = .5 * (game.input.activePointer.y - this.inputPrevY);
                    this.inputVelY = a
                }
                this.inputPrevY = game.input.activePointer.y
            } else this.clicked = !1, this.inputPrevY = null;
            this.rankingGroup.y += this.inputVelY, this.boundRistrict(), this.inputVelY *= .95, Math.abs(this.inputVelY) < 1 && (this.inputVelY = 0)
        }, G.GingerRanking.prototype.boundRistrict = function() {
            var a = Math.min(55, 55 - (this.rankingGroup.height - 326));
            55 < this.rankingGroup.y && (this.rankingGroup.y = G.lerp(this.rankingGroup.y, 55, .5), this.rankingGroup.y < 56 && (this.rankingGroup.y = 55)), this.rankingGroup.y < a && (this.rankingGroup.y = G.lerp(this.rankingGroup.y, a, .5), this.rankingGroup.y > a + 1 && (this.rankingGroup.y = a))
        }, G.GingerRanking.prototype.initRanking = function(a) {
            a = [{
                rank: 1,
                name: "sodomo",
                gingerAmount: 15,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 2,
                name: "Annie",
                gingerAmount: 13,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 3,
                name: "John",
                gingerAmount: 12,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 4,
                name: "Hell",
                gingerAmount: 10,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 5,
                name: "Dubious",
                gingerAmount: 8,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 6,
                name: "Krrr",
                gingerAmount: 3,
                avatar: sgSettings.config.user.avatar
            }, {
                rank: 7,
                name: "Goldie",
                gingerAmount: 0,
                avatar: sgSettings.config.user.avatar
            }];
            for (var b = 0; b < a.length; b++) this.initUser(30 + 60 * b, a[b])
        }, G.GingerRanking.prototype.initUser = function(a, b) {
            var c = new G.Text(30, a, b.rank.toString(), {
                fill: "#007D5D",
                font: "ComicSansBold",
                fontSize: "30px"
            }, .5, 50);
            this.rankingGroup.add(c), G.makeExtImage(80, a, b.avatar, "avatar_m", .5, this.rankingGroup, !1, function() {
                this.width = this.height = 50
            });
            var d = new G.Text(120, a, b.name, {
                fill: "#007D5D",
                font: "ComicSansBold",
                fontSize: "30px"
            }, [0, .5], 160);
            this.rankingGroup.add(d);
            var e = G.makeImage(340, a - 4, "Ranking_Small_Counter", .5, this.rankingGroup),
                f = new G.Text(355, a, b.gingerAmount.toString(), {
                    fill: "white",
                    font: "ComicSansBold",
                    fontSize: "30px"
                }, .5, 40);
            this.rankingGroup.add(f), this.rankingUsers.push({
                userData: b,
                rankTxt: c,
                nameTxt: d,
                gingerBg: e,
                gingerTxt: f
            })
        }, G.HighscorePanel = function() {
            Phaser.Group.call(this, game), this.hidingOffset = 500, this.hidingOffsetTarget = 0, this.x = .5 * game.width + game.world.bounds.x + this.hidingOffset, this.y = game.height, this.scrolled = !1, this.opened = !1, this.contentBg = G.makeImage(0, 0, "highscore-panel-content-bg", [.5, 0], this), this.contentBg.inputEnabled = !0, this.contentBg.events.onInputDown.add(function() {
                this.clicked = !0
            }, this), this.clicked = !1, this.tabsGroup = this.add(game.add.group()), this.tabsGroup.x = -320, this.tabs = {}, this.contentGroup = this.add(game.add.group()), this.contentGroup.x = -302, this.contentGroup.y = 68, this.borderImg = G.makeImage(0, 0, "highscore-panel-border", [.5, 0], this), this.initCheck = !1, this.responseData = !1, this.prevY = this.y, this.inputPrevY = null, this.inputVelY = 0, this.inputPrevX = null, this.inputVelX = 0, this.maskGfx = this.add(game.add.graphics()), this.maskGfx.y = 68, this.maskGfx.alpha = .5, this.maskWidth = 604, this.borderWidth = 5, this.maskHeight = 80, this.visiblePx = 195, this.updateMaskSize(), this.chinGroup = this.add(game.add.group()), this.inviteBtn = new G.Button(0, 0, "btn_invite", G.platform.invite), this.inviteBtn.addTextLabel("font-white", G.txt("Invite!"), 50), this.chinGroup.add(this.inviteBtn), this.toggleBtn = new G.Button(260, 0, "btn_up", function() {
                this.opened ? this.close() : (G.gameTracking.design("LeaderBoardExpandBtnClicked"), this.open())
            }, this), this.chinGroup.add(this.toggleBtn), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize(), this.leaderboards = {}, this.leaderboardsV = {}, this.fetchedData = {}, this.currentLeaderboard = null
        }, G.HighscorePanel.prototype = Object.create(Phaser.Group.prototype), G.HighscorePanel.prototype.init = function() {
            var a = {
                    GLOBAL: G.LeaderboardData.getLeaderboardData("GLOBAL"),
                    FRIENDS: G.LeaderboardData.getLeaderboardData("FRIENDS")
                },
                b = {
                    vertical: !0,
                    allEntries: !0,
                    entriesNr: 5
                },
                c = {
                    vertical: !1,
                    allEntries: !0,
                    entriesNr: 5
                };
            Object.keys(a).forEach(function(d) {
                "GLOBAL" === d ? (c.displayFullPos = !0, c.displayPos = !1) : (c.displayFullPos = !1, c.displayPos = !0), this.leaderboardsV[d] = this.add(new G.HighscorePanelLeaderboard(a[d], b)), this.leaderboardsV[d].visible = !1, this.leaderboards[d] = this.add(new G.HighscorePanelLeaderboard(a[d], c)), this.leaderboards[d].visible = !1, this.tabs[d] = this.tabsGroup.add(new G.HighscorePanelTabBtn(0, 0, d)), this.tabs[d].onTabClick.add(this.showLeaderboard, this)
            }, this), this.showLeaderboard(-1 !== Object.keys(a).indexOf("FRIENDS") ? "FRIENDS" : Object.keys(a)[0])
        }, G.HighscorePanel.prototype.fetchData = function(a) {
            this.fetchedData[a] || (this.fetchedData[a] = !0, G.LeaderboardData.fetchLeaderboard(a, function(b) {
                this.fetchedData[a] = b, this.leaderboards[a].init(b), this.leaderboardsV[a].init(b), this.leaderboardsV[a].centerOnCurrent(this.maskWidth, 712), this.leaderboards[a].centerOnCurrent(this.maskWidth, 712)
            }, this))
        }, G.HighscorePanel.prototype.onScreenResize = function() {
            this.x = .5 * game.width + game.world.bounds.x
        }, G.HighscorePanel.prototype.showLeaderboard = function(a) {
            for (name in this.contentGroup.removeAll(), this.leaderboards) this.leaderboards[name].visible = !1, this.leaderboards[name].mask = !1, this.tabs[name].setAsInactive();
            for (name in this.leaderboardsV) this.leaderboardsV[name].visible = !1, this.leaderboardsV[name].mask = !1, this.tabs[name].setAsInactive();
            var b = this.opened ? this.leaderboardsV : this.leaderboards;
            b[a] && (this.currentLeaderboard = b[a], this.maskGfx.visible = !0, this.currentLeaderboard.visible = !0, this.currentLeaderboard.mask = this.maskGfx, this.tabs[a].setAsActive(), this.tabsGroup.bringToTop(this.tabs[a]), this.contentGroup.add(this.currentLeaderboard), this.currentLeaderboardName = a, this.fetchData(a)), this.inputVelY = 0, this.inputVelX = 0
        }, G.HighscorePanel.prototype.update = function() {
            this.y = game.height + this.hidingOffset - this.visiblePx, this.chinGroup.y = this.visiblePx - 30, this.currentLeaderboard && this.currentLeaderboard.update(), this.updateMaskSize(), this.updateInput(), this.hidingOffset = G.lerp(this.hidingOffset, this.hidingOffsetTarget, .1)
        }, G.HighscorePanel.prototype.updateMaskSize = function() {
            this.maskGfx.clear(), this.maskGfx.beginFill(16711680, 1), this.maskGfx.drawRect(-.5 * this.maskWidth, 0, this.maskWidth, this.maskHeight)
        }, G.HighscorePanel.prototype.updateInput = function() {
            if (this.clicked && this.currentLeaderboard && game.input.activePointer.isDown) {
                if (null !== this.inputPrevX) {
                    var a = .5 * (game.input.activePointer.x - this.inputPrevX);
                    this.inputVelX = a
                }
                if (null !== this.inputPrevY) {
                    var b = .5 * (game.input.activePointer.y - this.inputPrevY);
                    this.inputVelY = b
                }
                this.scrolled || (G.gameTracking.design("LeaderboardMapScrolled"), this.scrolled = !0), this.inputPrevX = game.input.activePointer.x, this.inputPrevY = game.input.activePointer.y
            } else this.clicked = !1, this.inputPrevY = null, this.inputPrevX = null;
            this.currentLeaderboard && (this.currentLeaderboard.HORIZONTAL && (this.currentLeaderboard.x += this.inputVelX), this.currentLeaderboard.VERTICAL && (this.currentLeaderboard.y += this.inputVelY), this.boundRistrict(this.currentLeaderboard)), this.inputVelX *= .95, this.inputVelY *= .95, Math.abs(this.inputVelX) < 1 && (this.inputVelX = 0), Math.abs(this.inputVelY) < 1 && (this.inputVelY = 0)
        }, G.HighscorePanel.prototype.boundRistrict = function(a) {
            if (a.VERTICAL) {
                var b = Math.min(0, -(a.height - this.maskHeight));
                0 < a.y && (a.y = G.lerp(a.y, 0, .5), a.y < 1 && (a.y = 0)), a.y < b && (a.y = G.lerp(a.y, b, .5), a.y > b + 1 && (a.y = b))
            }
            if (a.HORIZONTAL) {
                var c = Math.min(0, -(a.width - this.maskWidth));
                0 < a.x && (a.x = G.lerp(a.x, 0, .5), a.x < 1 && (a.x = 0)), a.x < c && (a.x = G.lerp(a.x, c, .5), a.x > c + 1 && (a.x = c))
            }
        }, G.HighscorePanel.prototype.open = function() {
            this.opened = !0, G.stopTweens(this), this.visiblePx = 850, this.toggleBtn.angle = 180, this.maskHeight = this.visiblePx - 70 - 68, this.showLeaderboard(this.currentLeaderboardName)
        }, G.HighscorePanel.prototype.close = function() {
            this.opened = !1, G.stopTweens(this), this.visiblePx = 195, this.toggleBtn.angle = 0, this.maskHeight = this.visiblePx - 70, this.showLeaderboard(this.currentLeaderboardName)
        }, G.HighscorePanelIngame = function() {
            Phaser.Group.call(this, game), this.fixedToCamera = !0, this.contentBg = G.makeImage(0, 0, "leaderboard_ingame_panel", [.5, 1], this), this.contentBg.inputEnabled = !0, this.contentBg.events.onInputDown.add(function() {
                this.clicked = !0
            }, this), this.clicked = !1, this.contentGroup = this.add(game.add.group()), this.contentGroup.x = -302, this.contentGroup.y = -85, this.currentLeaderboard = new G.HighscorePanelLeaderboard([], {
                vertical: !1,
                entriesNr: 5,
                allEntries: !0,
                displayPos: !0
            }), this.contentGroup.add(this.currentLeaderboard), this.add(this.contentGroup), this.maskGfx = this.add(game.add.graphics()), this.maskGfx.y = -85, this.maskGfx.alpha = .5, this.maskWidth = 604, this.maskHeight = 80, this.maskGfx.beginFill(16711680, 1), this.maskGfx.drawRect(-.5 * this.maskWidth, 0, this.maskWidth - 140, this.maskHeight), this.inputPrevY = null, this.inputVelY = 0, this.inputPrevX = null, this.inputVelX = 0, this.currentLeaderboard.mask = this.maskGfx, G.LeaderboardData.fetchLevelLeaderboard(G.lvl.lvlNr + 1, function(a, b) {
                this.currentLeaderboard.init(a), this.currentLeaderboard.centerOnCurrent(this.maskWidth, this.maskHeight), b && G.sb("pushWindow").dispatch(["friendBeaten", b[0], b[1]])
            }, this), this.inviteBtn = new G.Button(235, -45, "btn_invite_ingame", G.platform.invite, this), this.inviteBtn.addTextLabel("font-white", G.txt("Invite!"), 50), this.add(this.inviteBtn), this.additionalCameraOffset = 200, game.add.tween(this).to({
                additionalCameraOffset: 0
            }, 1e3, Phaser.Easing.Sinusoidal.InOut, !0), this.update()
        }, G.HighscorePanelIngame.prototype = Object.create(Phaser.Group.prototype), G.HighscorePanelIngame.prototype.update = function() {
            this.cameraOffset.x = .5 * game.width, this.cameraOffset.y = game.height + this.additionalCameraOffset, this.currentLeaderboard.update(), this.updateInput()
        }, G.HighscorePanelIngame.prototype.updateInput = function() {
            if (this.clicked && this.currentLeaderboard && game.input.activePointer.isDown) {
                if (null !== this.inputPrevX) {
                    var a = .5 * (game.input.activePointer.x - this.inputPrevX);
                    this.inputVelX = a
                }
                if (null !== this.inputPrevY) {
                    var b = .5 * (game.input.activePointer.y - this.inputPrevY);
                    this.inputVelY = b
                }
                this.scrolled || (G.gameTracking.design("LeaderboardMapScrolled"), this.scrolled = !0), this.inputPrevX = game.input.activePointer.x, this.inputPrevY = game.input.activePointer.y
            } else this.clicked = !1, this.inputPrevY = null, this.inputPrevX = null;
            this.currentLeaderboard && (this.currentLeaderboard.HORIZONTAL && (this.currentLeaderboard.x += this.inputVelX), this.currentLeaderboard.VERTICAL && (this.currentLeaderboard.y += this.inputVelY), this.boundRistrict(this.currentLeaderboard)), this.inputVelX *= .95, this.inputVelY *= .95, Math.abs(this.inputVelX) < 1 && (this.inputVelX = 0), Math.abs(this.inputVelY) < 1 && (this.inputVelY = 0)
        }, G.HighscorePanelIngame.prototype.boundRistrict = function(a) {
            if (a.HORIZONTAL) {
                var b = Math.min(0, -(a.width - this.maskWidth)) - 140;
                0 < a.x && (a.x = G.lerp(a.x, 0, .5), a.x < 1 && (a.x = 0)), a.x < b && (a.x = G.lerp(a.x, b, .5), a.x > 1 + b && (a.x = b))
            }
        }, G.HighscorePanelLeaderboard = function(a, b) {
            Phaser.Group.call(this, game), this.config = b || {}, this.config = JSON.parse(JSON.stringify(b)), this.brush = game.make.image(0, 0), this.avatarAlphaMask = game.make.image(0, 0, "leaderboard", "highscore-avatar-alphaMask"), this.txt = new G.Text(0, 0, " ", {}), this.rt = game.make.renderTexture(602, 70), this.rtPadding = b.rtPadding || 10, this.image = this.add(game.make.image(0, 0, this.rt)), this.waitingIcon = new G.WaitingIcon(301, 45), this.add(this.waitingIcon), b.vertical ? (this.VERTICAL = !0, this.rt.resize(602, 300), this.waitingIcon.y = 150) : (this.HORIZONTAL = !0, this.waitingIcon.y = 35, this.waitingIcon.scale.setTo(.75)), this.currentUser = null, this.currentUserX = null, this.currentUserY = null
        }, G.HighscorePanelLeaderboard.prototype = Object.create(Phaser.Group.prototype), G.HighscorePanelLeaderboard.prototype.init = function(a) {
            var b;
            if (this.waitingIcon.destroy(), b = this.config.allEntries ? Math.max(a.length, this.config.entriesNr) : this.config.entriesNr, this.config.entriesMax && (b = Math.min(b, this.config.entriesMax)), this.config.vertical) {
                var c = 70 * b;
                this.rt.resize(602, c)
            } else {
                var d = 145 * b;
                this.rt.resize(d + 2 * this.rtPadding, 70)
            }
            this.rt.x = game.world.bounds.x;
            for (var e = 0; e < b; e++) this.config.vertical ? a[e] ? this.createEntryVer(0, 70 * e, a[e].rank || e + 1, a[e]) : this.createEntryVer(0, 70 * e, e + 1) : a[e] ? this.createEntryHor(this.rtPadding + 145 * e, 10, a[e].rank || e + 1, a[e]) : this.createEntryHor(this.rtPadding + 145 * e, 10, e + 1)
        }, G.HighscorePanelLeaderboard.prototype.centerOnCurrent = function(a, b) {
            this.currentUser && (this.VERTICAL ? (this.y = -this.currentUserY + .5 * b, this.y = Math.min(0, this.y)) : (this.x = -this.currentUserX + .5 * a, this.x = Math.min(0, this.x)))
        }, G.HighscorePanelLeaderboard.prototype.createEntryVer = function(a, b, c, d) {
            d && d.isCurrentUser ? (G.changeTexture(this.brush, "highscore-v-hl-current"), this.rt.renderXY(this.brush, a, b)) : c % 2 == 1 && (G.changeTexture(this.brush, "highscore-v-hl"), this.rt.renderXY(this.brush, a, b)), this.txt.fill = "#008bf9", this.txt.fontSize = "25px", this.txt.anchor.x = .5, this.txt.updateTransform(), this.txt.userMaxWidth = 40, this.txt.setText(c.toString() + "."), this.txt.width = Math.min(40, this.txt.width), this.rt.renderXY(this.txt, a + 45, b + 17);
            var e = this;
            d ? G.makeExtImage(a + 80, b + 10, d.image, "avatar_m", 0, this, !1, function() {
                avatar = e.alphaMaskAvatar(a + 80, b + 10, this, d && d.isCurrentUser, c), this.destroy()
            }) : (G.changeTexture(this.brush, "avatar_m"), avatar = this.alphaMaskAvatar(a + 80, b + 10, this.brush, d && d.isCurrentUser, c));
            var f = d ? d.name : "---";
            this.txt.anchor.x = 0, this.txt.updateTransform(), this.txt.fill = "#008bf9", this.txt.fontSize = "25px", this.txt.userMaxWidth = 250, this.txt.setText(f), this.rt.renderXY(this.txt, a + 145, b + 17), d && d.score && (this.txt.fill = "#008bf9", this.txt.fontSize = "25px", this.txt.userMaxWidth = 250, this.txt.anchor.x = 1, this.txt.updateTransform(), this.txt.setText(d.score.toString()), this.rt.renderXY(this.txt, a + 570, b + 17)), d && d.isCurrentUser && (this.currentUser = !0, this.currentUserY = b + 35)
        }, G.HighscorePanelLeaderboard.prototype.createEntryHor = function(a, b, c, d) {
            G.changeTexture(this.brush, "highscore-h-playerBg_small"), this.rt.renderXY(this.brush, a + 10, b);
            var e = this;
            d ? G.makeExtImage(a + 0, b - 0, d.image, "avatar_m", 0, this, !1, function() {
                e.alphaMaskAvatar(a, b + 0, this, d && d.isCurrentUser, c), this.destroy()
            }) : (G.changeTexture(this.brush, "avatar_m"), this.alphaMaskAvatar(a, b + 0, this.brush, d && d.isCurrentUser, c));
            var f = d ? d.name : "---";
            this.txt.anchor.x = 0, this.txt.updateTransform(), this.txt.fill = "#008bf9", this.txt.fontSize = "20px", this.txt.userMaxWidth = 60, this.txt.setText(f), this.rt.renderXY(this.txt, a + 55, b + 3), d && d.score && (this.txt.fill = "#008bf9", this.txt.fontSize = "20px", this.txt.userMaxWidth = 60, this.txt.setText(d.score.toString()), this.rt.renderXY(this.txt, a + 55, b + 25)), d && d.isCurrentUser && (this.currentUser = !0, this.currentUserX = a + 100)
        }, G.HighscorePanelLeaderboard.prototype.alphaMaskAvatar = function(a, b, c, d, e) {
            var f, g = game.make.bitmapData(50, 50),
                h = new Phaser.Rectangle(0, 0, 50, 50);
            g.alphaMask(c, this.avatarAlphaMask, h, h), f = this.config.displayPos ? "highscore-avatar-border_num" : this.config.displayFullPos ? "highscore-avatar-border_num_full" : "highscore-avatar-border", G.changeTexture(this.brush, f), g.draw(this.brush, 0, 0, 50, 50);
            var i = g.addToWorld();
            if (this.rt.renderXY(i, a, b), g.destroy(), i.destroy(), d && (G.changeTexture(this.brush, "highscore-avatar-userBorder"), this.rt.renderXY(this.brush, a - 5, b - 5)), this.config.displayPos || this.config.displayFullPos) {
                this.txt.fontSize = "12px", this.txt.fill = "white", this.txt.anchor.x = .5, this.txt.userMaxWidth = this.config.displayPos ? 17 : 48, this.txt.setText(e.toString());
                var j = this.config.displayPos ? a + 10 : a + 25;
                this.rt.renderXY(this.txt, j, b + 32)
            }
        }, G.HighscorePanelTabBtn = function(a, b, c) {
            this.onTabClick = new Phaser.Signal, this.tabKeyLower = c.toLowerCase(), G.Button.call(this, a, b, "highscore-panel-tab-" + this.tabKeyLower + "-inactive", function() {
                this.onTabClick.dispatch(this.tabKey)
            }, this), this.anchor.setTo(0, 0), this.hitArea = new Phaser.Rectangle("GLOBAL" == c ? 0 : 320, 0, 320, 68), this.tabKey = c, this.keyTxt = new G.Text("GLOBAL" == c ? 160 : 480, 30, G.txt(c), {
                fill: "white",
                font: "ComicSansBold",
                fontSize: "40px",
                stroke: "#0a7fd5",
                strokeThickness: 1
            }, .5, 300), this.keyTxt.setShadow(0, 2, "#0a7fd5", 2, !0, !0), this.addChild(this.keyTxt), this.IMMEDIATE = !0, this.setAsInactive()
        }, G.HighscorePanelTabBtn.prototype = Object.create(G.Button.prototype), G.HighscorePanelTabBtn.prototype.setAsActive = function() {
            G.changeTexture(this, "highscore-panel-tab-" + this.tabKeyLower + "-active"), this.keyTxt.alpha = 1, this.keyTxt.y = 25
        }, G.HighscorePanelTabBtn.prototype.setAsInactive = function() {
            G.changeTexture(this, "highscore-panel-tab-" + this.tabKeyLower + "-inactive"), this.keyTxt.alpha = .5, this.keyTxt.y = 30
        }, G.LeaderboardData = {
            currentPlayer: null,
            lastGroupPosition: null,
            ready: !1,
            onReady: new Phaser.Signal,
            onFetch: {},
            onStateBinding: !1,
            leaderboards: {},
            onPerLevelFetch: new Phaser.Signal,
            perLevelPrev: [],
            fetchLeaderboard: function(a, b, c) {
                b && (this.onFetch[a] || (this.onFetch[a] = new Phaser.Signal), this.onFetch[a].addOnce(b, c)), this.onStateBinding || (this.onStateBinding = game.state.onStateChange.add(this.clearFetch, this)), sdkHandler.trigger("getLeaderboard", {
                    scope: [{
                        name: a,
                        topPlayersCount: "GLOBAL" === a ? 10 : 20,
                        beforePlayerCount: 2,
                        afterPlayerCount: 3
                    }],
                    callback: function(b, c) {
                        b || c && (this.processLeaderboard(c, a), this.ready = !0, this.onReady.dispatch(), this.onFetch[a].dispatch(this.getLeaderboardData(a)))
                    }
                }, this)
            },
            fetchLevelLeaderboard: function(a, b, c) {
                b && this.onPerLevelFetch.addOnce(b, c), this.onStateBinding || (this.onStateBinding = game.state.onStateChange.add(this.clearFetch, this)), sdkHandler.trigger("getLeaderboard", {
                    scope: [{
                        name: "FRIENDS",
                        topPlayersCount: 20,
                        beforePlayerCount: 2,
                        afterPlayerCount: 3
                    }],
                    perLevel: a,
                    callback: function(b, c) {
                        if (!b && c) {
                            var d = null;
                            this.perLevelPrev[a] && (d = this.getBeatenFriend(this.perLevelPrev[a], c.FRIENDS)), this.perLevelPrev[a] = c.FRIENDS, this.onPerLevelFetch.dispatch(c.FRIENDS, d)
                        }
                    }
                }, this)
            },
            getBeatenFriend: function(a, b) {
                try {
                    var c = a.find(function(a) {
                            return a.isCurrentUser
                        }),
                        d = a.indexOf(c),
                        e = c ? c.score : 0,
                        f = b.find(function(a) {
                            return a.isCurrentUser
                        }),
                        g = b.indexOf(f),
                        h = f ? f.score : 0;
                    if (!f) return null;
                    if (h <= e) return null;
                    var i = b[g + 1];
                    if (!i) return null;
                    if (0 === e) return i ? [f, i] : null;
                    for (var j = i.userId, k = 0; k < d; k++)
                        if (a[k].userId === j) return [f, i];
                    return null
                } catch (a) {
                    console.log(a)
                }
            },
            clearFetch: function() {
                console.log("clear Fetch"), Object.keys(this.onFetch).forEach(function(a) {
                    this.onFetch[a].removeAll()
                }, this), this.onReady.removeAll(), this.onPerLevelFetch.removeAll()
            },
            getLeaderboardData: function(a) {
                return this.leaderboards && this.leaderboards[a] ? this.leaderboards[a] : []
            },
            processLeaderboard: function(a, b) {
                console.log("processLeaderboard"), this.leaderboards[b] = a[b], this.leaderboards.FRIENDS && (this.currentPlayer = this.leaderboards.FRIENDS.find(function(a) {
                    return a.isCurrentUser
                }))
            },
            checkIfNewHighscoreTier: function() {
                if (G.saveState.data && this.currentPlayer && 15e3 < this.currentPlayer.score) {
                    var a = Math.floor(this.currentPlayer.score / 15e3);
                    G.saveState.data.highscoreTierMsgs || (G.saveState.data.highscoreTierMsgs = []), -1 == G.saveState.data.highscoreTierMsgs.indexOf(a) && (G.saveState.data.highscoreTierMsgs.push(a), G.saveState.save(), G.platform.sendMsg("New highscore!", G.MsgWOW, {
                        name: this.currentPlayer.name,
                        avatar: this.currentPlayer.image,
                        score: this.currentPlayer.score
                    }))
                }
            },
            checkIfBeat: function() {
                try {
                    if (this.leaderboardsPrev && this.leaderboards && this.leaderboardsPrev.GROUP && this.leaderboards.GROUP) {
                        var a = this.leaderboardsPrev.GROUP.find(function(a) {
                            return a.isCurrentUser
                        });
                        console.log("lastCurrent", a);
                        var b = this.leaderboards.GROUP.find(function(a) {
                            return a.isCurrentUser
                        });
                        if (console.log("current", b), a && b && b.rank > a.rank) {
                            var c = this.leaderboardsPrev.GROUP.indexOf(b),
                                d = this.leaderboardsPrev.GROUP[c + 1];
                            console.log("other", d), d && G.platform.beatMsg({
                                name: this.currentPlayer.name,
                                avatar: this.currentPlayer.image,
                                score: this.currentPlayer.score
                            }, {
                                name: d.name,
                                avatar: d.image,
                                score: d.score
                            })
                        }
                    }
                } catch (a) {}
            }
        }, G.platform = {
            invite: function() {},
            firstLevelMsg: function() {},
            beatMsg: function() {},
            shareBeatMsg: function() {},
            sendMsg: function() {}
        }, G.msgToDataURL = function(a) {
            return G._msgBmp || (G._msgBmp = game.make.bitmapData(672, 354)), a.x = game.world.bounds.x, a.y = game.world.bounds.y, a.updateTransform(), G._msgBmp.clear(), G._msgBmp.drawGroup(a), a.destroy(), G._msgBmp.canvas.toDataURL()
        }, G.MsgBeaten = function(a, b) {
            Phaser.Group.call(this, game), console.log("G.MsgBeaten"), console.log(a, b), a.avatar || (a.avatar = a.image), b.avatar || (b.avatar = b.image), this.imagesToLoad = 2, this.imagesLoaded = 0, this.onReady = new Phaser.Signal, this.ready = !1, this.y = -9999, this.bg = G.makeImage(0, 0, "bg_beat", 0, this), this.friendsBeaten = this.add(new G.Text(336, 40, "Friend beaten!", {
                font: "ComicSansBold",
                fontSize: "35px",
                fill: "white"
            }, .5, 420));
            var c = this;
            this.avatar1 = G.makeExtImage(230, 129, a.avatar, null, 0, this, !1, function() {
                this.width = this.height = 94, c.imagesLoaded++, c.imagesLoaded == c.imagesToLoad && (c.ready = !0, game.time.events.add(100, c.onReady.dispatch, c.onReady))
            }), this.name1 = this.add(new G.Text(212, 156, a.name, {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "#0088d1"
            }, [1, .5], 420)), this.score1 = this.add(new G.Text(212, 196, a.score, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 4
            }, [1, .5], 420)), this.avatar2 = G.makeExtImage(354, 148, b.avatar, null, 0, this, !1, function() {
                this.width = this.height = 94, c.imagesLoaded++, c.imagesLoaded == c.imagesToLoad && (c.ready = !0, game.time.events.add(100, c.onReady.dispatch, c.onReady))
            }), this.name2 = this.add(new G.Text(470, 186, b.name, {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "#0088d1"
            }, [0, .5], 420)), this.avatar2.width = this.avatar2.height = 94, this.score2 = this.add(new G.Text(470, 226, b.score, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 4
            }, [0, .5], 420));
            var d = " scored higher than ";
            this.desc = this.add(new G.Text(336, 311, a.name + d + b.name + "!", {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "#ffe715"
            }, .5, 420)), this.desc.addColor("#ffffff", a.name.length), this.desc.addColor("#ffe715", d.length + a.name.length), this.desc.addColor("#ffffff", d.length + a.name.length + b.name.length)
        }, G.MsgBeaten.prototype = Object.create(Phaser.Group.prototype), G.MsgBeatMe = function(a) {
            Phaser.Group.call(this, game), this.imagesToLoad = 1, this.imagesLoaded = 0, this.onReady = new Phaser.Signal, this.ready = !1, this.y = -9999, this.bg = G.makeImage(0, 0, "bg_beat_me", 0, this), this.friendsBeaten = this.add(new G.Text(336, 39, "Challenge Friend", {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "white"
            }, .5, 420));
            var b = this;
            this.avatar1 = G.makeExtImage(380, 111, a.avatar, null, 0, this, !1, function() {
                this.width = this.height = 96, b.imagesLoaded++, b.imagesLoaded == b.imagesToLoad && (b.ready = !0, game.time.events.add(100, b.onReady.dispatch, b.onReady))
            }), this.name1 = this.add(new G.Text(424, 325, a.name, {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "#0088d1"
            }, .5, 420)), this.score1 = this.add(new G.Text(424, 266, a.score, {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 4
            }, .5, 420)), this.name2 = this.add(new G.Text(241, 325, "YOU", {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "#0088d1"
            }, .5, 420)), this.score2 = this.add(new G.Text(241, 266, "???", {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 4
            }, .5, 420)), this.desc = this.add(new G.Text(336, 311, "Can you beat me?", {
                font: "ComicSansBold",
                fontSize: "25px",
                fill: "white"
            }, .5, 420))
        }, G.MsgBeatMe.prototype = Object.create(Phaser.Group.prototype), G.MsgFirst = function(a) {
            Phaser.Group.call(this, game), this.imagesToLoad = 1, this.imagesLoaded = 0, this.onReady = new Phaser.Signal, this.ready = !1, this.y = -9999, this.bg = G.makeImage(0, 0, "bg_first_highscore", 0, this), this.friendsBeaten = this.add(new G.Text(336, 39, "First highscore ever!", {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "white"
            }, .5, 420));
            var b = this;
            this.avatar1 = G.makeExtImage(266, 103, a.avatar, null, 0, this, !1, function() {
                this.width = this.height = 139, b.imagesLoaded++, b.imagesLoaded == b.imagesToLoad && (b.ready = !0, game.time.events.add(100, b.onReady.dispatch, b.onReady))
            }), this.score1 = this.add(new G.Text(336, 295, a.score, {
                font: "ComicSansBold",
                fontSize: "65px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 8
            }, .5, 420))
        }, G.MsgFirst.prototype = Object.create(Phaser.Group.prototype), G.MsgFirst.prototype.extToInt = function(a) {
            return G.extLoader.loadedUrls[a]
        }, G.MsgInvite = function(a) {
            Phaser.Group.call(this, game), this.imagesToLoad = 1, this.imagesLoaded = 0, this.onReady = new Phaser.Signal, this.ready = !1, this.y = -9999, this.bg = G.makeImage(0, 0, "bg_woow", 0, this), this.friendsBeaten = this.add(new G.Text(336, 39, "Play with me!", {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "white"
            }, .5, 420)), this.score1 = this.add(new G.Text(336, 295, a.name, {
                font: "ComicSansBold",
                fontSize: "65px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 8
            }, .5, 420));
            var b = this;
            this.avatar1 = G.makeExtImage(266, 103, a.avatar, null, 0, this, !1, function() {
                this.width = this.height = 139, b.imagesLoaded++, b.imagesLoaded == b.imagesToLoad && (b.ready = !0, game.time.events.add(100, b.onReady.dispatch, b.onReady))
            })
        }, G.MsgInvite.prototype = Object.create(Phaser.Group.prototype), G.MsgWOW = function(a) {
            Phaser.Group.call(this, game), this.imagesToLoad = 1, this.imagesLoaded = 0, this.onReady = new Phaser.Signal, this.ready = !1, this.y = -9999, this.bg = G.makeImage(0, 0, "bg_woow", 0, this), this.friendsBeaten = this.add(new G.Text(336, 39, "Wow! See what I achieved!", {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "white"
            }, .5, 420));
            var b = this;
            this.avatar1 = G.makeExtImage(266, 103, a.avatar, null, 0, this, !1, function() {
                this.width = this.height = 139, b.imagesLoaded++, b.imagesLoaded == b.imagesToLoad && (b.ready = !0, game.time.events.add(100, b.onReady.dispatch, b.onReady))
            }), this.score1 = this.add(new G.Text(336, 295, a.score, {
                font: "ComicSansBold",
                fontSize: "65px",
                fill: "#ffe715",
                stroke: "#0088d1",
                strokeThickness: 8
            }, .5, 420))
        }, G.MsgWOW.prototype = Object.create(Phaser.Group.prototype), G.MsgWOW.prototype.extToInt = function(a) {
            return G.extLoader.loadedUrls[a]
        }, G.Window = function(a) {
            Phaser.Group.call(this, game), this.buttonsList = [], this.state = game.state.getCurrentState(), a.constructor === Array ? this[a[0]].apply(this, a.slice(1)) : this[a].apply(this, Array.prototype.slice.call(arguments, 1)), "taskSlider" != a && (game.add.tween(this.scale).from({
                x: 0
            }, 300, Phaser.Easing.Elastic.Out, !0), game.add.tween(this).from({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.In, !0)), G.sb("onWindowOpened").dispatch(this), G.sb("onStateChange").add(this.lockInput, this)
        }, G.Window.prototype = Object.create(Phaser.Group.prototype), G.Window.constructor = G.Window, G.Window.prototype.closeWindow = function(a, b) {
            this.closing || (this.lockInput(), this.closing = !0, this.boosterHighlight && (this.boosterHighlight.inputEnabled = !1, game.add.tween(this.boosterHighlight.shine).to({
                alpha: 0
            }, 800, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                this.boosterHighlight.destroy()
            }, this)), game.add.tween(this.scale).to({
                x: 1.5
            }, 200, Phaser.Easing.Sinusoidal.In, !0), game.add.tween(this).to({
                alpha: 0
            }, 200, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                G.sb("onWindowClosed").dispatch(), this.destroy(), a && a.call(b || !1)
            }, this))
        }, G.Window.prototype.addBackground = function(a) {
            a = a || "popup", this.bg = G.makeImage(0, 0, a, .5, this)
        }, G.Window.prototype.addCloseButton = function(a, b, c, d) {
            c = c || !1, d = d || this, this.closeButton = new G.Button(a || 250, b || -270, "btn_x", function() {
                this.closeWindow(c, d)
            }, this), this.registerButtons(this.closeButton)
        }, G.Window.prototype.registerButtons = function() {
            for (var b = 0; b < arguments.length; b++) this.buttonsList.push(arguments[b]), this.add(arguments[b]), arguments[b].addTerm(function() {
                return 1 == this.scale.x
            }, this)
        }, G.Window.prototype.lockInput = function() {
            this.buttonsList.forEach(function(a) {
                a.input.enabled = !1
            })
        }, G.Window.prototype.unlockInput = function() {
            this.buttonsList.forEach(function(a) {
                a.input.enabled = !0, a.input.useHandCursor = !0
            })
        }, G.Window.prototype.makeCoinBar = function(a, b, c) {
            this.coinArea = G.makeImage(0, b, "popup_text_backgr", .5, this), this.coinIco = G.makeImage(a - 130, b, "coin_1", .5, this), this.coinsTxt = new G.Text(0, b, G.saveState.getCoins().toString(), {
                style: "font-brown",
                fontSize: 45
            }, .5, 190), this.add(this.coinsTxt), game.incentivised && (this.plusBtn = new G.Button(a + 130, b, "btn_plus", function() {
                this.state.windowLayer.pushWindow(["moreMoney", c]), this.closeWindow()
            }, this), this.registerButtons(this.plusBtn))
        }, G.Window.prototype.buyLives = function() {
            game.incentivised ? this.buyLivesIncentivised() : this.buyLivesNotIncentivised()
        }, G.Window.prototype.buyLivesIncentivised = function() {
            this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -275, "popup_top", .5, this), this.titleTxt = new G.Text(0, -300, G.txt("Not enough Hearts"), {
                style: "font-beige",
                fontSize: "50px"
            }, .5, 300), this.add(this.titleTxt), this.closeButton = new G.Button(250, -255, "btn_x", function() {
                this.closeWindow()
            }, this), this.registerButtons(this.closeButton), this.preGroup = this.add(game.make.group()), this.heartImg = G.makeImage(0, -85, "icon_video_hearts", [.5, .5], this), this.preGroup.add(this.heartImg), this.watchVideoToGetTxt = new G.Text(0, 45, G.txt("Watch a video to get"), {
                style: "font-brown",
                fontSize: "40px"
            }, .5, 500), this.preGroup.add(this.watchVideoToGetTxt), this.moneyTxt = new G.LabelGroupT("+" + G.json.settings.livesForAd + " @heart@", 0, 110, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ece9e5",
                stroke: "#A0692E",
                strokeThickness: 5
            }, .5, 500), this.preGroup.add(this.moneyTxt), this.watchBtn = new G.Button(0, 220, "btn_green", function() {
                var a = game.sound.mute;
                game.sound.mute = !0, "games.ollgames.ru" == document.domain ? (G.sfx.music.volume = 0, AnbycookGP(), game.sound.mute = a, this.watchBtn.inputEnabled = !1, "World" == game.state.current ? this.buyLivesIncentivised_thanks() : G.saveState.addLife(G.json.settings.livesForAd)) : (new G.NoMoreAds, this.watchBtn.inputEnabled = !1, this.watchBtn.alpha = .5, G.sfx.music.volume = 1)
            }, this), this.watchBtn.addTextLabel("font-blue-out", G.txt("Watch"), 50), this.registerButtons(this.watchBtn)
        }, G.Window.prototype.buyLivesIncentivised_thanks = function() {
            game.add.tween(this.preGroup).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.watchBtn.inputEnabled = !1, game.add.tween(this.watchBtn).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.postGroup = this.add(game.make.group()), this.thanksForWatching = new G.Text(0, -100, G.txt("Thanks for watching!"), {
                style: "font-blue",
                fontSize: "50px"
            }, .5, 500), this.postGroup.add(this.thanksForWatching), this.moneyBg = G.makeImage(0, 25, "popup_bigtext_backgr", [.5, .5], this.postGroup), this.moneyTxt = new G.LabelGroupT("+" + G.json.settings.livesForAd + " @heart@", 0, 25, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ece9e5",
                stroke: "#A0692E",
                strokeThickness: 5
            }, .5, 500), this.postGroup.add(this.moneyTxt), this.postGroup.alpha = 0, game.add.tween(this.postGroup).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.claimBtn = new G.Button(0, 230, "button_green", function() {
                if ("World" == game.state.current) {
                    var a = this.state.uiTargetParticles.createDividedBatch(game.world.bounds.x + this.worldPosition.x, this.worldPosition.y, "heart", this.state.panel.lifeUI.lifeIcon, G.json.settings.livesForAd, 1);
                    a.addOnPartFinish(function() {
                        G.saveState.addLife(1)
                    }), a.start()
                } else G.saveState.addLife(G.json.settings.livesForAd);
                this.closeWindow()
            }, this), this.claimBtn.addTextLabel("font-white", G.txt("Claim"), 50), this.registerButtons(this.claimBtn), game.add.tween(this.claimBtn).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.Window.prototype.buyLivesNotIncentivised = function() {
            this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -275, "popup_top", .5, this), this.titleTxt = new G.Text(0, -300, G.txt("Not enough Hearts"), {
                style: "font-beige",
                fontSize: "50px"
            }, .5, 300), this.add(this.titleTxt), this.closeButton = new G.Button(250, -255, "btn_x", function() {
                this.closeWindow()
            }, this), this.registerButtons(this.closeButton), this.heartImg = G.makeImage(0, -70, "broken_heart", [.5, .5], this), this.heartImg.scale.setTo(2), this.moneyTxt = new G.LabelGroupT("+1 @heart@ = " + G.json.settings.lifePrice + "@coin_1@", 0, 60, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ece9e5",
                stroke: "#A0692E",
                strokeThickness: 5
            }, .5, 500), this.add(this.moneyTxt), this.buyBtn = new G.Button(0, 220, "btn_orange", function() {
                if (G.gameTracking.sink("Coins", "Life", "Map", G.json.settings.lifePrice), G.saveState.changeCoins(-G.json.settings.lifePrice, !0), "World" == game.state.current) {
                    var a = this.state.uiTargetParticles.createDividedBatch(game.world.bounds.x + this.worldPosition.x, this.worldPosition.y, "heart", this.state.panel.lifeUI.lifeIcon, 1, 1);
                    a.addOnPartFinish(function() {
                        G.saveState.addLife(1)
                    }), a.start()
                } else G.saveState.addLife(1);
                this.closeWindow()
            }, this), this.buyBtn.addTextLabel("font-green", G.txt("Buy"), 50), this.registerButtons(this.buyBtn), G.saveState.getCoins() < G.json.settings.lifePrice && (this.buyBtn.alpha = .5, this.buyBtn.inputEnabled = !1)
        }, G.Window.prototype.daily2 = function() {
            G.saveState.ftueDailyRewardVisible || (G.saveState.ftueDailyRewardVisible = !0), this.incentivised = game.incentivised, this.played = 0, this.addBackground("popup_background_2"), this.bg.y = G.l(40), this.ribbon = G.makeImage(0, -270, "popup_top", .5, this), this.titleTxt = new G.Text(0, -295, G.txt("Prize wheel"), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 300), this.add(this.titleTxt), this.ribbonImg = G.makeImage(0, -215, "gold_wheel_ribbon", .5, this), this.ribbonTxt = new G.Text(0, 0, G.txt("3x higher winnings!"), {
                style: "font-blue-out-small",
                fontSize: 30
            }, .5, 350), this.ribbonImg.scale.setTo(0), this.ribbonImg.addChild(this.ribbonTxt), this.closeButton = new G.Button(260, -222, "btn_x", function() {
                G.saveState.ftueDailyRewardClose || (G.saveState.ftueDailyRewardClose = !0), this.wonPrize && (G.gift.applyGift(this.wonPrize), "coin" === this.wonPrize[0] ? G.gameTracking.source("Coins", "Reward", "DailyReward", this.wonPrize[1]) : G.gameTracking.source(G.saveState.nrToBoosterName(this.wonPrize[0][8]), "Reward", "DailyReward", this.wonPrize[1]), this.wonPrize = !1), this.closeWindow()
            }, this), this.registerButtons(this.closeButton), this.dailyGame = this.add(new G.DailyWheel(0, 70)), this.giftGroup = this.add(game.make.group()), this.giftGroup.y = 50, this.freeSpinBtn = new G.Button(0, 335, "button_green", function() {
                this.dailyGame.restart(), this.dailyGame.launch(game.rnd.between(600, 1400)), G.gameTracking.design("DailySpinClicked"), this.closeButton.visible = !1, G.saveState.data.freeSpin = !1, G.saveState.save(), this.freeSpinBtn.visible = !1, this.premiumSpinBtn.visible = !1
            }, this), this.freeSpinBtn.addTextLabel("font-green", G.txt("Spin"), 50), this.add(this.freeSpinBtn), this.premiumSpinBtn = new G.Button(0, 280, "button_play", function() {
                var a = game.sound.mute;
                game.sound.mute = !0, "games.ollgames.ru" == document.domain ? (G.sfx.music.volume = 0, AnbycookGP(), game.sound.mute = a, this.dailyGame.restart(), this.dailyGame.launch(game.rnd.between(600, 1400)), this.closeButton.visible = !1, this.freeSpinBtn.visible = !1, this.premiumSpinBtn.visible = !1) : (new G.NoMoreAds, this.premiumSpinBtn.inputEnabled = !1, this.premiumSpinBtn.alpha = .5, G.sfx.music.volume = 1)
            }, this), this.premiumSpinBtn.label = new G.Text(42, 0, G.txt("Watch a video to try again"), {
                font: "ComicSansBold",
                fontSize: "30px",
                fill: "#f7ffdb",
                stroke: "#005700",
                lineSpacing: -25,
                strokeThickness: 5
            }, .5, 230, 70, !0, "center"), this.premiumSpinBtn.addChild(this.premiumSpinBtn.label), this.add(this.premiumSpinBtn), G.saveState.data.freeSpin ? this.changeToRegular() : this.changeToGold(), this.dailyGame.onFinish.add(function(a) {
                game.add.tween(this.dailyGame).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.daily2showPrize(a)
            }, this), this.plusCoin = new G.LabelGroupT("+@coin_1@", 100, 30, {
                font: "ComicSansBold",
                fontSize: "100px",
                fill: "#FDFBE4"
            }, .5, 200), this.plusCoin.visible = !1, this.add(this.plusCoin), this.youWinTxt = new G.Text(0, -40, G.txt("You win!"), {
                style: "font-beige-standard",
                fontSize: 60
            }, .5, 500), this.add(this.youWinTxt), this.youWinTxt.visible = !1, this.claimButton = new G.Button(0, 260, "button_green", function() {
                this.shareCheckbox && this.shareCheckbox.selected || this.daily2ClaimBtnAction()
            }, this), this.claimButton.addTextLabel("font-green", G.txt("Claim"), 50), this.registerButtons(this.claimButton), this.claimButton.inputEnabled = !1, this.claimButton.visible = !1
        }, G.Window.prototype.daily2ClaimBtnAction = function() {
            this.daily2applyPrize(this.wonPrize, !1), this.wonPrize = !1, this.claimButton.inputEnabled = !1
        }, G.Window.prototype.daily2showPrize = function(a) {
            this.youWinTxt.scale.setTo(0), this.youWinTxt.visible = !0, game.add.tween(this.youWinTxt.scale).to({
                x: 1,
                y: 1
            }, 600, Phaser.Easing.Elastic.Out, !0), this.giftGfx = new G.LabelGroupT(G.gift.getLabelString(a), 0, 30, {
                font: "ComicSansBold",
                fontSize: "80px",
                fill: "#FDFBE4"
            }, .5, 300), this.giftGfx.scale.setTo(0), game.add.tween(this.giftGfx.scale).to({
                x: 1,
                y: 1
            }, 600, Phaser.Easing.Elastic.Out, !0), this.giftGroup.add(this.giftGfx), this.wonPrize = a, game.time.events.add(1e3, function() {
                this.plusCoin.width, this.giftGfx.width, G.l(10), this.claimButton.alpha = 1, this.claimButton.scale.setTo(0), game.add.tween(this.claimButton.scale).to({
                    x: 1,
                    y: 1
                }, 600, Phaser.Easing.Elastic.Out, !0).onComplete.add(function() {
                    this.claimButton.inputEnabled = !0, this.claimButton.input.useHandCursor = !0
                }, this), this.claimButton.visible = !0, this.shareCheckbox && (this.shareCheckbox.visible = !0, this.shareCheckbox.alpha = 0, game.add.tween(this.shareCheckbox).to({
                    alpha: 1
                }, 600, Phaser.Easing.Elastic.Out, !0).onComplete.add(function() {
                    this.shareCheckbox.ignoreChildInput = !1
                }, this)), this.closeButton.visible = !0
            }, this)
        }, G.Window.prototype.daily2applyPrize = function(a) {
            this.wonPrize = !1, "coin" === a[0] ? (this.state.uiTargetParticles.createCoinBatch(game.world.bounds.x + this.giftGfx.worldPosition.x, this.giftGfx.worldPosition.y, this.state.panel.coinsTxt, a[1]), G.gameTracking.source("Coins", "Reward", "DailyReward", a[1])) : (G.gift.applyGift(a), G.gameTracking.source(G.saveState.nrToBoosterName(a[0][8]), "Reward", "DailyReward")), game.time.events.add(1e3, this.daily2restart, this)
        }, G.Window.prototype.changeToRegular = function() {
            this.freeSpinBtn.visible = !0, this.premiumSpinBtn.visible = !1, 0 < this.ribbonImg.scale.x && (G.stopTweens(this.ribbonImg), game.add.tween(this.ribbonImg.scale).to({
                x: 0,
                y: 0
            }, 200, Phaser.Easing.Cubic.In, !0)), this.dailyGame.changeToRegular()
        }, G.Window.prototype.changeToGold = function() {
            this.freeSpinBtn.visible = !1, this.premiumSpinBtn.visible = !0, this.ribbonImg.scale.x < 1 && (G.stopTweens(this.ribbonImg), game.add.tween(this.ribbonImg.scale).to({
                x: 1,
                y: 1
            }, 500, Phaser.Easing.Elastic.Out, !0)), this.dailyGame.changeToGold()
        }, G.Window.prototype.daily2restart = function() {
            return game.incentivised ? (this.shareCheckbox && (this.shareCheckbox.ignoreChildInput = !0, game.add.tween(this.shareCheckbox).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0)), this.claimButton.inputEnabled = !1, game.add.tween(this.claimButton).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0), game.add.tween(this.plusCoin).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0), game.add.tween(this.dailyGame).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0, 400).onComplete.add(function() {
                G.saveState.data.freeSpin ? this.changeToRegular() : this.changeToGold()
            }, this), game.add.tween(this.youWinTxt.scale).to({
                x: 0,
                y: 0
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this.giftGroup).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.In, !0).onComplete.add(function() {
                this.giftGroup.destroy(), this.giftGroup = this.add(game.make.group()), this.giftGroup.y = 40
            }, this), void 0) : this.closeWindow()
        }, G.Window.prototype.daily2makeFirework = function(a, b) {
            var c = game.add.group();
            this.add(c), c.x = G.l(a), c.y = G.l(b);
            for (var d = 0; d < 10; d++) {
                var e = G.makeImage(0, 0, "firework", .5, c),
                    f = 36 * (d + .5 * Math.random());
                e.fadeRate = .02 + .02 * Math.random(), e.grav = 4, e.scale.setTo(1.5), e.velX = G.lengthDirX(f, G.l(12), !1), e.velY = G.lengthDirY(f, G.l(12), !1), e.update = function() {
                    this.x += this.velX, this.y += this.velY, this.y += this.grav, this.velX *= .97, this.velY *= .97, this.alpha -= this.fadeRate, this.alpha <= 0 && this.destroy()
                }
            }
            return c.update = function() {
                for (var a = this.children.length; a--;) this.children[a].update();
                0 == this.length && this.destroy()
            }, c
        }, G.Window.prototype.dailyChallenge = function(a) {
            this.addBackground("popup_background_2"), this.levelBg = G.makeImage(0, -290, "popup_top", .5, this), this.levelTxt = new G.Text(0, -315, G.txt("Daily Challenge"), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 330), this.add(this.levelTxt), this.closeButton = new G.Button(235, -257, "btn_x", function() {
                this.boosters.forEach(function(a) {
                    a.signalBinding && a.signalBinding.detach()
                }), this.closeWindow()
            }, this), this.registerButtons(this.closeButton), this.addChild(this.closeButton), this.stars = [G.makeImage(-100, -150, "star_blank", .5, this), G.makeImage(0, -175, "star_blank", .5, this), G.makeImage(100, -150, "star_blank", .5, this)], this.stars[0].scale.setTo(.8), this.stars[2].scale.setTo(.8), this.taskBg = G.makeImage(0, 5, "popup_bigtext_backgr", .5, this), this.taskTxt = new G.Text(0, -70, G.txt("Task") + ":", {
                style: "font-beige-standard",
                fontSize: "45px"
            }, .5, 380), this.add(this.taskTxt), "collect" == a.goal[0] ? this.makeTaskCollectPanels(5, a) : this.add(new G.Text(0, 5, G.txt("points").toUpperCase() + ": " + a.goal[1], {
                style: "font-beige-header",
                fontSize: "50px"
            }, .5, 380)), this.buyTxt = new G.Text(0, 75, G.txt("Buy some boosters") + ":", {
                style: "font-beige-standard",
                fontSize: 35
            }, .5, 680), this.add(this.buyTxt), this.boosterBg = G.makeImage(0, 170, "popup_bigtext_backgr", .5, this), this.boosters = [new G.UI_StartBoosterButton(-195, 170, 5, 999), new G.UI_StartBoosterButton(0, 170, 7, 999), new G.UI_StartBoosterButton(195, 170, 8, 999)], this.addMultiple(this.boosters), this.continueBtn = new G.Button(0, 300, "btn_orange", function() {
                G.saveState.startChallenge(), G.sb("onStateChange").dispatch("Game", 999, !1, this.state.startBoosterConfig.getConfigForLevel(999), a)
            }, this), this.continueBtn.pulse(), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.continueBtn)
        }, G.Window.prototype.dailyReward = function(a) {
            this.dayNr = game.math.clamp(a, 0, 6), this.y = 0, this.bg = G.makeImage(0, -330, "big_popup", [.5, 0], this), this.bg.scale.y = .9, this.ribbon = G.makeImage(0, -285, "daily_rewards_ribbon", .5, this), this.title = new G.Text(0, -300, G.txt("Daily Reward") + "!", {
                style: "font-beige-header",
                fontSize: "55px"
            }, .5, 400), this.title.padding.x = 10, this.add(this.title), G.sb("hideMainHighscorePanel").dispatch(), this.dailyReward_showCurrentGift(this.dayNr)
        }, G.Window.prototype.dailyReward_showCurrentGift = function(a) {
            this.currentDay = this.add(new G.DailyRewardCurrentGift(0, -30, a)), this.openBtn = new G.Button(0, 200, "btn_orange", this.dailyReward_openGift, this), this.openBtn.addTextLabel("font-green", G.txt("Open"), 40), this.add(this.openBtn)
        }, G.Window.prototype.dailyReward_openGift = function() {
            this.currentDay.showReward(), this.openBtn.visible = !1, this.openBtn.inputEnabled = !1, this.claimBtn = new G.Button(0, 200, "btn_orange", function() {
                this.currentDay.claimReward(), this.claimBtn.inputEnabled = !1, game.add.tween(this.claimBtn).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.currentDay).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(this.dailyReward_showGiftWeek, this)
            }, this), this.claimBtn.addTextLabel("font-green", G.txt("Claim"), 40), this.add(this.claimBtn)
        }, G.Window.prototype.dailyReward_showGiftWeek = function() {
            game.add.tween(this).to({
                y: -70
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), game.add.tween(this.bg.scale).to({
                y: 1.1
            }, 300, Phaser.Easing.Sinusoidal.InOut, !0), this.week = this.add(new G.DailyRewardWeek(0, 20, this.dayNr)), this.comeBackTxt = this.add(new G.Text(0, 270, G.txt("Come back tomorrow for more rewards!"), {
                style: "font-beige",
                fontSize: "30px",
                lineSpacing: -20
            }, .5, 400, null, !0, "center")), this.comeBackTxt.scale.setTo(0), game.add.tween(this.comeBackTxt.scale).to({
                x: 1,
                y: 1
            }, 600, Phaser.Easing.Elastic.Out, !0, 200), this.timerBg = G.makeImage(0, 345, "future_day_box_big", .5, this), this.timerBg.height = 40, this.timerBg.alpha = 0, game.add.tween(this.timerBg).to({
                alpha: 1
            }, 600, Phaser.Easing.Sinusoidal.Out, !0, 600), this.timer = new G.TextTimer(0, 347, 864e5 * G.saveState.data.dailyReward.nextDaily, {
                style: "font-beige",
                fontSize: "35px"
            }, .5), this.add(this.timer), this.timer.alpha = 0, game.add.tween(this.timer).to({
                alpha: 1
            }, 600, Phaser.Easing.Sinusoidal.Out, !0, 600), this.coolBtn = new G.Button(0, 435, "btn_orange", function() {
                this.coolBtn.inputEnabled = !1, game.add.tween(this.coolBtn.scale).to({
                    x: 0,
                    y: 0
                }, 300, Phaser.Easing.Cubic.In, !0), this.closeWindow(), G.sb("showMainHighscorePanel").dispatch()
            }, this), this.coolBtn.addTextLabel("font-green", G.txt("Cool"), 40), this.coolBtn.scale.setTo(0), game.add.tween(this.coolBtn.scale).to({
                x: 1,
                y: 1
            }, 300, Phaser.Easing.Cubic.Out, !0, 400), this.add(this.coolBtn)
        }, G.Window.prototype.gate = function(a) {
            this.addBackground("popup_background_2"), this.gateData = a, this.closeButton = new G.Button(250, -270, "btn_x", function() {
                this.closeWindow()
            }, this), this.registerButtons(this.closeButton);
            var b = this.savedData = G.saveState.getGateData(a.id),
                c = G.saveState.getAllStars();
            !1 === b.timerStartedAt && (b.timerStartedAt = Date.now(), G.saveState.save()), this.timerNewLevelsInTxt = new G.Text(0, -290, G.txt("New levels in"), {
                style: "font-brown",
                fontSize: 40
            }, .5, 400), this.add(this.timerNewLevelsInTxt);
            var d = 60 * a.req.timeMinutes - (Date.now() - b.timerStartedAt) / 1e3;
            this.timer = new G.TextTimer(0, -245, 0, {
                style: "font-brown",
                fontSize: "40px"
            }, .5, 400), this.timer.setSecLeft(d), this.timer.start(), this.add(this.timer);
            var e = -130;
            this.starsTxt = new G.LabelGroupT("@*1.4*star@" + c + "/" + a.req.stars, -210, 60 + e, {
                font: "ComicSansBold",
                fill: "#ece9e5",
                fontSize: "40px",
                stroke: "#A0692E",
                strokeThickness: 7
            }, [0, .5], 250), this.add(this.starsTxt), this.collectMoreStarsTxt = new G.Text(130, 65 + e, G.txt("Collect more stars!"), {
                font: "ComicSansBold",
                fill: "#ece9e5",
                fontSize: "40px",
                stroke: "#A0692E",
                strokeThickness: 7,
                lineSpacing: -25
            }, .5, 250, !1, !0, "center"), this.add(this.collectMoreStarsTxt), this.or2 = new G.Text(0, 30, G.txt("or"), {
                style: "font-brown",
                fontSize: "50px"
            }, .5, 500), this.add(this.or2), e = -80, this.priceTxt = new G.LabelGroupT(a.req.coins + " @coin_1@", -120, 230 + e, {
                font: "ComicSansBold",
                fill: "#ece9e5",
                fontSize: "40px",
                stroke: "#A0692E",
                strokeThickness: 7
            }, .5, 250), this.add(this.priceTxt), this.priceBtn = new G.Button(130, 230 + e, "btn_orange", function() {
                G.saveState.isEnoughToBuy(this.gateData.req.coins) ? (G.gameTracking.design("GateUnlockCoins"), G.gameTracking.sink("Coins", this.gateData.id.toString, "Map", this.gateData.req.coins), G.saveState.changeCoins(-1 * this.gateData.req.coins), G.saveState.openGate(this.gateData.id)) : game.incentivised ? (G.sb("pushWindow").dispatch(["moreMoney", ["gate", this.gateData]]), this.closeWindow()) : (this.priceBtn.alpha = .5, this.priceBtn.inputEnabled = !1)
            }, this), this.priceBtn.label = new G.Text(0, 0, G.txt("Buy a key"), {
                font: "ComicSansBold",
                fontSize: "30px",
                fill: "#f7ffdb",
                stroke: "#005700",
                lineSpacing: -25,
                strokeThickness: 5
            }, .5, .9 * this.priceBtn.width, this.priceBtn.height, !0, "center"), this.priceBtn.addChild(this.priceBtn.label), this.add(this.priceBtn), !game.incentivised && G.saveState.getCoins() < this.gateData.req.coins && (this.priceBtn.alpha = .5, this.priceBtn.inputEnabled = !1), this.registerButtons(this.priceBtn), this.update = function() {
                this.savedData.open && this.closeWindow()
            }
        }, G.Window.prototype.gift = function(a, b) {
            "Game" === game.state.current && (0 === G.lvl.lvlNr || G.lvl.lvlNr), this.addBackground("popup_background_2"), this.giftMakeTitle(a), a && this.giftMakeExplanation(a), this.gift = this.add(new G.GiftBox(0, a ? 50 : 0, !1, b)), this.continueBtn = new G.Button(5, 250, "btn_orange", function() {
                "Game" === game.state.current && (0 === G.lvl.lvlNr || G.lvl.lvlNr), this.continueBtn.inputEnabled = !1, this.continueBtn.visible = !1, game.add.tween(this.continueBtn).to({
                    alpha: 0
                }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.gift.unpack(), this.getItBtn = new G.Button(5, 250, "btn_orange", function() {
                    "Game" === game.state.current && (0 === G.lvl.lvlNr || G.lvl.lvlNr), this.closeWindow()
                }, this), this.getItBtn.addTextLabel("font-green", G.txt("Get it"), 50), this.registerButtons(this.getItBtn)
            }, this), this.continueBtn.addTextLabel("font-green", G.txt("Unpack it"), 50), this.registerButtons(this.continueBtn)
        }, G.Window.prototype.giftMakeTitle = function(a) {
            if ("3stars" === a) {
                this.stars = [], this.starsGroup = game.add.group();
                for (var b = 0; b < 3; b++) this.stars[b] = G.makeImage(60 * b, b % 2 == 0 ? 0 : -20, "star", [0, .5], this.starsGroup), this.stars[b].scale.setTo(.7);
                this.starsGroup.y = G.l(-270), this.titleTxt = new G.Text(0, -270, G.txt("Gift"), {
                    style: "font-beige-standard",
                    fontSize: "60px"
                }, [0, .5], 300), this.starsGroup.x = -.5 * (this.starsGroup.width + this.titleTxt.width + G.l(10)), this.titleTxt.x = this.starsGroup.x + this.starsGroup.width + G.l(10), this.add(this.starsGroup), this.add(this.titleTxt)
            } else this.titleTxt = new G.Text(0, -270, G.txt("achievement" == a ? "Achievement gift" : "Gift"), {
                style: "font-beige-standard",
                fontSize: "60px"
            }, .5, 450), this.add(this.titleTxt)
        }, G.Window.prototype.giftMakeExplanation = function(a) {
            var b = G.txt("3stars" == a ? "Nice job! You earned 3 stars! Enjoy your gift!" : "Nice job! You won 3 times in a row! Enjoy your gift!");
            this.explanationTxt = new G.Text(0, -130, b, {
                font: "ComicSansBold",
                fill: "#FDFBE4",
                stroke: "#A0692E",
                strokeThickness: 7,
                fontSize: "35px",
                lineSpacing: -25
            }, .5, 450, 110, !0, "center"), this.add(this.explanationTxt)
        }, G.Window.prototype.giveUp = function(a, b) {
            this.state = game.state.getCurrentState(), a && this.state.windowLayer.pushWindow(a), this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -290, "popup_top", .5, this), this.titleTxt = new G.Text(0, -315, "NORMAL" == this.state.mode ? G.txt("Level") + " " + (G.lvlNr + 1) : G.txt("Daily Challenge"), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 330), this.add(this.titleTxt), this.loseProgressTxt = new G.Text(0, -70, G.txt("Your level progress will be lost!"), {
                font: "ComicSansBold",
                fontSize: "40px",
                fill: "#FDFBE4",
                stroke: "#A0692E",
                strokeThickness: 7,
                lineSpacing: -25
            }, .5, 500, 140, !0, "center"), this.add(this.loseProgressTxt), this.continueBtn = new G.Button(0, 120, "btn_orange", function() {
                this.closeWindow()
            }, this), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.continueBtn), this.continueBtn.pulse(), this.giveUpBtn = new G.Button(0, 250, "btn_red", function() {
                G.lvl.lvlNr, G.lvl.points, G.winsInRow = 0, "CHALLENGE" === this.state.mode ? G.gameTracking.fail("DailyChallenge", this.state.getLevelDimension(), void 0, G.lvl.points) : G.gameTracking.fail("Gate" + G.saveState.checkGateNr(G.lvlNr).toString(), this.state.getLevelDimension(), void 0, G.lvl.points), game.paused = !0, game.paused = !1, b && b()
            }, this), this.giveUpBtn.addTextLabel("font-red", G.txt("Give up"), 50), this.registerButtons(this.giveUpBtn), G.LIVES && (this.brokenHeart = G.makeImage(-120, 250, "broken_heart", .5, this), this.minusOneTxt = new G.Text(-125, 250, "-1", {
                style: "font-red",
                fontSize: "35px"
            }, .5, 50), this.add(this.minusOneTxt)), this.giveUpBtn.visible = !1, this.brokenHeart.visible = !1, this.minusOneTxt.visible = !1, this.giveUpBtn.visible = !0, this.brokenHeart.visible = !0, this.minusOneTxt.visible = !0
        }, G.Window.prototype.globalGoals = function() {
            G.gameTracking.design("MissionWindowVisibleOnMap"), this.addBackground("popup_background_2"), this.addCloseButton(), this.closeButton.terms = [], this.myMissionTxt = new G.Text(0, -280, G.txt("My Missions"), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 400), this.add(this.myMissionTxt), this.completeMissionsTxt = new G.Text(0, -235, G.txt("Complete missions to receive rewards!"), {
                style: "font-beige-standard",
                fontSize: "25px"
            }, .5, 400), this.add(this.completeMissionsTxt), this.add(new G.GlobalGoalPanelGroup(0, -140, 340))
        }, G.Window.prototype.level = function() {
            game.state.getCurrentState(), this.addBackground("popup_background_2"), 1 === G.lvlNr || 2 === G.lvlNr || G.lvlNr, this.levelBg = G.makeImage(0, -305, "popup_top", .5, this), this.levelTxt = new G.Text(0, -334, G.txt("Level") + " " + (G.lvlNr + 1), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 330), this.add(this.levelTxt), this.closeButton = new G.Button(235, -263, "btn_x", function() {
                1 === G.lvlNr || G.lvlNr, this.boosters.forEach(function(a) {
                    a.signalBinding && a.signalBinding.detach()
                }), this.closeWindow()
            }, this), this.registerButtons(this.closeButton), this.addChild(this.closeButton);
            var a = G.saveState.getStars(G.lvlNr);
            this.stars = [G.makeImage(-100, -180, 1 <= a ? "star" : "star_blank", .5, this), G.makeImage(0, -208, 2 <= a ? "star" : "star_blank", .5, this), G.makeImage(100, -180, 3 <= a ? "star" : "star_blank", .5, this)], this.stars[0].scale.setTo(.8), this.stars[2].scale.setTo(.8), this.taskBg = G.makeImage(0, -25, "popup_bigtext_backgr", .5, this), this.taskTxt = new G.Text(0, -90, G.txt("Task") + ":", {
                style: "font-beige-standard",
                fontSize: "45px"
            }, .5, 380), this.add(this.taskTxt), "collect" == G.lvlData.goal[0] ? this.makeTaskCollectPanels(-25, G.lvlData) : this.add(new G.Text(0, -25, G.txt("points").toUpperCase() + ": " + G.lvlData.goal[1], {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 380)), this.buyTxt = new G.Text(0, 65, G.txt("Buy some boosters") + ":", {
                style: "font-beige-standard",
                fontSize: "35px"
            }, .5, 680), this.add(this.buyTxt), this.boosterBg = G.makeImage(0, 150, "popup_bigtext_backgr", .5, this), this.boosters = [new G.UI_StartBoosterButton(-180, 150, 5, G.lvlNr), new G.UI_StartBoosterButton(0, 150, 7, G.lvlNr), new G.UI_StartBoosterButton(180, 150, 8, G.lvlNr)], this.addMultiple(this.boosters), this.continueBtn = new G.Button(0, 290, "btn_orange", function() {
                1 === G.lvlNr || G.lvlNr, G.sb("onStateChange").dispatch("Game", G.lvlNr, !1, this.state.startBoosterConfig.getConfigForLevel(G.lvlNr))
            }, this), this.continueBtn.pulse(), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.continueBtn)
        }, G.Window.prototype.makeTaskCollectPanels = function(a, b) {
            for (var c = [
                    [0],
                    [-85, 85],
                    [-170, 0, 170],
                    [-205, -65, 65, 205]
                ], d = 0, e = b.goal[1].length; d < e; d++) {
                var f = G.json.settings.goals[b.goal[1][d][0]].sprite;
                G.makeImage(c[e - 1][d] - 5, a, f, [1, .5], this).scale.setTo(.68);
                var g = new G.Text(c[e - 1][d] + 40, a, b.goal[1][d][1].toString(), {
                    style: "font-beige-header",
                    fontSize: "35px"
                }, [1, .5], 85);
                this.add(g)
            }
        }, G.Window.prototype.levelFailed = function() {
            "NORMAL" == this.state.mode && (G.lvl.lvlNr, G.lvl.points), G.sfx.music.pause(), G.sfx.lvlfailed.play(), "CHALLENGE" === this.state.mode ? G.gameTracking.fail("DailyChallenge", this.state.getLevelDimension(), void 0, G.lvl.points) : G.gameTracking.fail("Gate" + G.saveState.checkGateNr(G.lvlNr).toString(), this.state.getLevelDimension(), void 0, G.lvl.points);
            for (var a = JSON.parse(localStorage.getItem("glmdataCC")).points, b = 0, c = 0; c < 451; c++) void 0 !== a[c] && (b += a[c]);
            try {
                window.parent.postMessage("comandd|" + b, "*")
            } catch (a) {}
            this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -290, "popup_top", .5, this), this.titleTxt = new G.Text(0, -315, "NORMAL" == this.state.mode ? G.txt("Level") + " " + (G.lvlNr + 1) : G.txt("Daily Challenge"), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 330), this.add(this.titleTxt), this.closeButton = new G.Button(250, -270, "btn_x", function() {
                G.sb("onStateChange").dispatch("World")
            }, this), this.closeButton.visible = !1, this.registerButtons(this.closeButton), G.LIVES && (this.brokenHeart = G.makeImage(0, -75, "broken_heart", .5, this), this.minusOneTxt = new G.Text(-55, -75, "-1", {
                style: "font-red",
                fontSize: "35px"
            }, .5, 50), this.add(this.minusOneTxt)), G.lvl.goalMgr.isPointBased() ? (this.butgoal = new G.Text(0, 115, G.txt("points").toUpperCase() + ":\n" + G.lvl.points + "/" + G.lvl.goalMgr.getPointTarget(), {
                style: "font-beige-standard",
                fontSize: "40px"
            }, .5, 380), this.add(this.butgoal)) : this.makeLevelFailedTaskCollectPanels(95), "NORMAL" === this.state.mode ? (this.retryBtn = new G.Button(5, 250, "btn_orange", function() {
                game.paused = !0, game.paused = !1, G.winsInRow = 0, G.gameTracking.design("LevelRetryButtonClicked"), 0 < G.saveState.getCurrentLivesNr() ? G.sb("onStateChange").dispatch("Game", G.lvl.lvlNr, G.debugMode) : G.sb("onStateChange").dispatch("World")
            }, this), this.retryBtn.addTextLabel("font-green", G.txt("Retry"), 50), this.registerButtons(this.retryBtn)) : (this.continueBtn = new G.Button(0, 240, "btn_green", function() {
                sdkHandler.trigger("playButtonPressed", {
                    callback: function() {
                        G.sb("onStateChange").dispatch("World")
                    }
                }, this)
            }, this), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 70), this.registerButtons(this.continueBtn)), this.continueBtn && (this.continueBtn.visible = !1), this.retryBtn && (this.retryBtn.visible = !1), this.retryBtn && (this.retryBtn.visible = !0), this.continueBtn && (this.continueBtn.visible = !0), this.closeButton && (this.closeButton.visible = !0)
        }, G.Window.prototype.makeLevelFailedTaskCollectPanels = function(a) {
            var b = [
                [0],
                [-85, 85],
                [-170, 0, 170],
                [-205, -65, 65, 205]
            ];
            this.taskBg = G.makeImage(0, a, "popup_bigtext_backgr", .5, this), this.panels = [];
            for (var c = G.lvl.goal[1], d = 0, e = c.length; d < e; d++)
                if (0 < this.state.topBar.goalPanel.panels[d].amount) {
                    var f = G.json.settings.goals[c[d][0]].sprite,
                        g = G.makeImage(0, a, f, .5, this);
                    G.makeImage(70, 0, "task_fail", .5, g), this.panels.push(g)
                }
            var h = this.panels.length;
            this.panels.forEach(function(a, c) {
                a.x = G.l(b[h - 1][c] - 25)
            })
        }, G.Window.prototype.mapChest = function(a) {
            this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -290, "popup_top", .5, this), this.titleTxt = new G.Text(0, -315, G.txt("Chest Unlocked"), {
                style: "font-beige-header",
                fontSize: 50
            }, .5, 330), this.add(this.titleTxt), this.gifts = a, this.chest = G.makeImage(0, -25, "chest_open", .5, this), this.youReceiveTxt = new G.Text(0, -150, G.txt("You receive") + ":", {
                style: "font-beige",
                fontSize: "50px"
            }, .5, 550), this.add(this.youReceiveTxt), this.giftsLabelGroup = new G.LabelGroupT(G.gift.getLabelPackString(a), 0, 120, {
                font: "ComicSansBold",
                fontSize: "60px",
                fill: "#FDFBE4",
                stroke: "#A0692E",
                strokeThickness: 7
            }, [.5, .5], 500, 0), this.add(this.giftsLabelGroup), this.claimBtn = new G.Button(0, 245, "btn_orange", function() {
                this.gifts.forEach(function(a) {
                    "coin" == a[0] ? (G.gameTracking.source("Coins", "Reward", "MapChest", a[1]), this.state.uiTargetParticles.createCoinBatch(game.world.bounds.x + this.chest.worldPosition.x, this.chest.worldPosition.y, this.state.panel.coinsTxt, a[1])) : (G.gameTracking.source("life" === a[0] ? "Life" : G.saveState.nrToBoosterName(a[0][8]), "Reward", "MapChest", a[1]), G.gift.applyGift(a))
                }, this), this.closeWindow()
            }, this), this.claimBtn.addTextLabel("font-green", G.txt("Claim"), 45), this.registerButtons(this.claimBtn)
        }, G.Window.prototype.mapGift = function() {
            this.giftData = G.gift.getGift(), this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -275, "popup_top", .5, this), this.titleTxt = new G.Text(0, -300, G.txt("Gift"), {
                style: "font-beige-header",
                fontSize: "50px"
            }, .5, 300), this.add(this.titleTxt), this.addCloseButton(), this.mapGift_claim()
        }, G.Window.prototype.mapGift_watch = function() {
            this.preGroup = this.add(game.make.group()), this.preGroup.y = 40, this.watchGiftImg = G.makeImage(0, -100, "icon_video_gift", [.5, .5], this.preGroup), this.watchVideoToGetTxt = new G.Text(0, 46, G.txt("Watch a video to get"), {
                style: "font-blue",
                fontSize: "50px"
            }, .5, 500), this.preGroup.add(this.watchVideoToGetTxt), this.getGiftTxt = new G.Text(0, 46, G.txt("Watch a video to get"), {
                style: "font-blue",
                fontSize: "50px"
            }, .5, 500), this.preGroup.add(this.getGiftTxt), this.watchBtn = new G.Button(0, 230, "button_play", function() {
                var a = game.sound.mute;
                game.sound.mute = !0, "games.ollgames.ru" == document.domain ? (G.sfx.music.volume = 0, AnbycookGP(), game.sound.mute = a, this.mapGift_claimAfterWatch()) : (new G.NoMoreAds, this.watchBtn.inputEnabled = !1, this.watchBtn.alpha = .5, G.sfx.music.volume = 1)
            }, this), this.watchBtn.addTextLabel("font-white", G.txt("Watch"), 55, 30, -4, 260), this.registerButtons(this.watchBtn)
        }, G.Window.prototype.mapGift_claim = function() {
            this.gift = this.add(new G.GiftBox(0, 0, !1, this.giftData)), this.claimBtn = new G.Button(0, 230, "button_green", function() {
                this.claimBtn.visible = !1, G.saveState.data.lastMapGiftOpenTime = Date.now(), this.getItBtn = new G.Button(5, 230, "btn_orange", function() {
                    this.closeWindow()
                }, this), this.getItBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.getItBtn), this.gift.unpack(), "coin" === this.giftData[0] ? G.gameTracking.source("Coins", "Reward", "FreeGift", this.giftData[1]) : "life" === this.giftData[0] ? G.gameTracking.source("Life", "Reward", "FreeGift", this.giftData[1]) : -1 !== this.giftData[0].indexOf("booster") && G.gameTracking.source(G.saveState.nrToBoosterName(this.giftData[0][8]), "Reward", "FreeGift", this.giftData[1])
            }, this), this.claimBtn.addTextLabel("font-green", G.txt("Claim"), 50), this.registerButtons(this.claimBtn)
        }, G.Window.prototype.mapGift_claimAfterWatch = function() {
            this.watchBtn.inputEnabled = !1, game.add.tween(this.watchBtn).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.preGroup).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.mapGift_claim(), game.add.tween(this.claimBtn).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), game.add.tween(this.gift).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.gift.y = 30, this.thanksForWatching = new G.Text(0, -155, G.txt("Thanks for watching!"), {
                style: "font-blue",
                fontSize: 50
            }, .5, 500), this.add(this.thanksForWatching), game.add.tween(this.thanksForWatching).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.Window.prototype.moreMoney = function(a) {
            this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -275, "popup_top", .5, this), this.titleTxt = new G.Text(0, -300, G.txt("Get more coins"), {
                style: "font-beige-header",
                fontSize: 50
            }, .5, 300), this.add(this.titleTxt), this.addCloseButton(), a && this.state.windowLayer.pushWindow(a), this.preGroup = this.add(game.make.group()), this.coinImg = G.makeImage(0, -100, "icon_video_coins", [.5, .5], this.preGroup), this.watchVideoToGetTxt = new G.Text(0, 55, G.txt("Watch a video to get"), {
                style: "font-beige",
                fontSize: 40
            }, .5, 500), this.preGroup.add(this.watchVideoToGetTxt), this.moneyTxt = new G.LabelGroupT("@coin_1@ " + G.json.settings.coinsForAd, 0, 110, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#FDFBE4"
            }, .5, 500), this.preGroup.add(this.moneyTxt), this.watchBtn = new G.Button(0, 230, "button_play", function() {
                var a = game.sound.mute;
                game.sound.mute = !0, "games.ollgames.ru" == document.domain ? (G.sfx.music.volume = 0, AnbycookGP(), game.sound.mute = a, this.moreMoney_thanks()) : (new G.NoMoreAds, this.watchBtn.inputEnabled = !1, this.watchBtn.alpha = .5, G.sfx.music.volume = 1)
            }, this), this.watchBtn.addTextLabel("font-green", G.txt("Watch"), 50, 30, -4, 260), this.registerButtons(this.watchBtn)
        }, G.Window.prototype.moreMoney_thanks = function() {
            game.add.tween(this.preGroup).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.watchBtn.inputEnabled = !1, game.add.tween(this.watchBtn).to({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.postGroup = this.add(game.make.group()), this.thanksForWatching = new G.Text(0, -100, G.txt("Thanks for watching!"), {
                style: "font-beige",
                fontSize: 50
            }, .5, 500), this.postGroup.add(this.thanksForWatching), this.moneyBg = G.makeImage(0, 25, "popup_bigtext_backgr", [.5, .5], this.postGroup), this.moneyTxt = new G.LabelGroupT("@coin_1@ " + G.json.settings.coinsForAd, 0, 25, {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ece9e5",
                stroke: "#A0692E",
                strokeThickness: 5
            }, .5, 500), this.postGroup.add(this.moneyTxt), this.postGroup.alpha = 0, game.add.tween(this.postGroup).to({
                alpha: 1
            }, 300, Phaser.Easing.Sinusoidal.Out, !0), this.claimBtn = new G.Button(0, 230, "button_green", function() {
                "World" == game.state.current ? this.state.uiTargetParticles.createCoinBatch(game.world.bounds.x + this.moneyTxt.worldPosition.x, this.moneyTxt.worldPosition.y, this.state.panel.coinsTxt, G.json.settings.coinsForAd) : G.saveState.changeCoins(G.json.settings.coinsForAd), this.closeWindow()
            }, this), this.claimBtn.addTextLabel("font-green", G.txt("Claim"), 50), this.registerButtons(this.claimBtn), game.add.tween(this.claimBtn).from({
                alpha: 0
            }, 300, Phaser.Easing.Sinusoidal.Out, !0)
        }, G.Window.prototype.outOfMoves = function() {
            this.addBackground("popup_background_2"), this.makeCoinBar(0, -270, "outOfMoves"), G.sb("onGoalAchieved").add(this.closeWindow, this), this.outOfMovesTxt = new G.Text(0, -130, G.txt("Out of moves!"), {
                style: "font-brown",
                fontSize: 50
            }, .5, 500), this.add(this.outOfMovesTxt), this.endGameBtn = new G.Button(-120, 230, "end_game_btn", function() {
                G.sb("pushWindow").dispatch("levelFailed"), this.timerActivate = !1, this.closeWindow()
            }, this), this.endGameBtn.addTextLabel("font-gray", G.txt("End game"), 30), this.add(this.endGameBtn), G.LIVES && (this.brokenHeart = G.makeImage(-223, 226, "broken_heart", .5, this), this.minusOneTxt = new G.Text(-232, 226, "-1", {
                style: "font-red",
                fontSize: "35px"
            }, .5, 50), this.add(this.minusOneTxt)), this.promo = 0 == G.lvl.outOfMovesPopUp || Math.random() < .25, G.lvl.outOfMovesPopUp++, G.saveState.data.outOfMovesInterstitialTimer || (G.saveState.data.outOfMovesInterstitialTimer = 0), game.incentivised && Date.now() - G.saveState.data.outOfMovesInterstitialTimer > 60 * G.json.settings.interstitialSettings.outOfMovesTimerMin * 1e3 ? this.outOfMoves_addWatchButton() : this.outOfMoves_addBuyButton()
        }, G.Window.prototype.outOfMoves_addWatchButton = function() {
            this.watchBtn = new G.Button(140, 230, "moves-ad-btn", function() {
                this.watchBtn.inputEnabled = !1;
                var a = game.sound.mute;
                game.sound.mute = !0, "games.ollgames.ru" == document.domain ? (G.sfx.music.volume = 0, AnbycookGP(), game.sound.mute = a, G.lvl.changeMoveNumber(5), this.closeWindow(), G.saveState.data.outOfMovesInterstitialTimer = Date.now()) : (new G.NoMoreAds, this.watchBtn.visible = !1, this.outOfMoves_addBuyButton(), G.sfx.music.volume = 1)
            }, this), this.registerButtons(this.watchBtn), "ja" === G.lang && (G.changeTexture(this.watchBtn, "btn_orange"), this.watchBtn.label = new G.Text(-40, 0, G.txt("watch-outOfMovesPopUp"), {
                fill: "#f7ffdb",
                fontSize: "30px",
                font: "Lobster",
                stroke: "#005700",
                strokeThickness: 7
            }, .5, 83), this.watchBtn.addChild(this.watchBtn.label), this.watchBtn.boosterIcon = G.makeImage(48, 0, "ui_booster_5", .5, this.watchBtn))
        }, G.Window.prototype.outOfMoves_addBuyButton = function() {
            this.timerTxt = new G.Text(0, 0, 60 * G.json.settings.outOfMovesTimer, {
                style: "font-brown",
                fontSize: 50
            }, .5, 500), this.timerTxt.cacheAsBitmap = !1, this.timerTxt.timer = 60 * G.json.settings.outOfMovesTimer, this.timerActivate = !0, this.add(this.timerTxt), this.price = this.promo ? Math.floor(2 * G.lvl.getPriceOfExtraMoves() * .7) : 2 * G.lvl.getPriceOfExtraMoves(), this.continueBtn = new G.Button(120, 230, "btn_orange", function() {
                G.saveState.data.coins >= this.price ? (G.lvl.buyExtraMoves(!0, this.price), this.timerActivate = !1, this.closeWindow(), G.ga.event("Recurring:GetMoreMoves:LevelEnd")) : (G.sb("pushWindow").dispatch(["moreMoney", "outOfMoves"]), this.timerActivate = !1, this.closeWindow())
            }, this), this.continueBtn.pulse(), this.continueBtn.extraMoveIcon = G.makeImage(-105, 0, "ui_booster_5", [0, .5], this.continueBtn), this.continueBtn.extraMoveIcon.scale.setTo(.95);
            var a = this.price + "@currency@";
            this.continueBtn.label = new G.LabelGroupT(a, 25, 0, {
                font: "ComicSansBold",
                fontSize: "35px",
                fill: "#f7ffdb",
                stroke: "#005700",
                strokeThickness: 5
            }, .5, 95), this.continueBtn.addChild(this.continueBtn.label), this.update = function() {
                if (this.timerActivate) {
                    this.timerTxt.timer-- <= 0 && (this.timerActivate = !1, G.sb("pushWindow").dispatch("levelFailed"), this.closeWindow());
                    var a = Math.ceil(this.timerTxt.timer / 60).toString();
                    this.timerTxt.text != a && this.timerTxt.setText(a)
                }
            }, this.promo && (this.continueBtn.promoLabel = G.makeImage(115, -7, "off_lable", .5, this.continueBtn), this.continueBtn.promoTxt = this.continueBtn.addChild(new G.Text(117, -7, "-30%", {
                style: "font-red",
                fontSize: 25
            }, .5, 60)), this.continueBtn.promoTxt.angle = -10, this.continueBtn.label.y = G.l(10), this.continueBtn.label2 = new G.LabelGroupT(2 * G.lvl.getPriceOfExtraMoves() + "@currency@", 25, -30, {
                font: "ComicSansBold",
                fontSize: "20px",
                fill: "#ffe9d0",
                stroke: "#961400",
                strokeThickness: 5
            }, .5, 95), this.continueBtn.addChild(this.continueBtn.label2), this.continueBtn.crossOut = G.makeImage(25, -30, "coins_lable", .5, this.continueBtn), this.continueBtn.crossOut.cacheAsBitmap = !0, this.continueBtn.crossOut.width = 1.1 * this.continueBtn.label2.width, this.continueBtn.crossOut.height = 2, this.continueBtn.crossOut.angle = -10, this.continueBtn.bringToTop(this.continueBtn.label)), this.registerButtons(this.continueBtn)
        }, G.Window.prototype.pause = function() {
            this.addBackground("popup_background_2"), this.ribbon = G.makeImage(0, -275, "popup_top", .5, this), this.titleTxt = new G.Text(6, -300, G.txt("Pause"), {
                style: "font-beige-header",
                fontSize: 50
            }, .5, 300), this.add(this.titleTxt), this.addCloseButton(253, -260), this.homeBtn = new G.Button(-130, -54, "btn_home", function() {
                this.state.windowLayer.pushWindow(["giveUp", "pause", function() {
                    G.sb("onStateChange").dispatch(G.debugMode ? "EditorWorld" : "World")
                }]), this.closeWindow()
            }, this), this.playBtn = new G.Button(0, 150, "btn_play", function() {
                this.closeWindow()
            }, this), this.soundBtn = new G.SoundBtn(134, -50), this.registerButtons(this.soundBtn, this.homeBtn, this.playBtn)
        }, G.Window.prototype.taskSlider = function() {
            this.y = -1.5 * game.height, G.sfx.whoosh_short_1.play(), game.add.tween(this).to({
                y: G.l(-120)
            }, 400, Phaser.Easing.Sinusoidal.Out, !0).onComplete.add(function() {
                game.time.events.add(1e3, G.sfx.whoosh_short_2.play, G.sfx.whoosh_short_2), game.add.tween(this).to({
                    y: 1.5 * game.height
                }, 400, Phaser.Easing.Sinusoidal.Out, !0, 1e3).onComplete.add(function() {
                    G.sb("onWindowClosed").dispatch(), this.destroy()
                }, this)
            }, this), this.addBackground("task_slider"), this.bg.y = G.l(120), this.taskTxt = new G.Text(0, 50, G.txt("Task") + ":", {
                style: "font-beige-standard",
                fontSize: "40px"
            }, .5, 380), this.add(this.taskTxt), G.lvl.goalMgr.isPointBased() ? (this.goal = new G.Text(0, 115, G.txt("points").toUpperCase() + ": " + G.lvl.goalMgr.getPointTarget(), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 380), this.add(this.goal)) : this.makeTaskCollectPanels(115, G.lvlData)
        }, G.Window.prototype.thanksForWatching = function() {
            this.addBackground("popup_background_2"), this.thanksForWatching = new G.Text(0, 0, G.txt("Thanks for watching!"), {
                font: "ComicSansBold",
                fontSize: "50px",
                fill: "#ece9e5",
                stroke: "#A0692E",
                strokeThickness: 7,
                lineSpacing: -25
            }, .5, 530, 200, !0, "center"), this.add(this.thanksForWatching), this.continueBtn = new G.Button(5, 250, "btn_orange", function() {
                this.closeWindow()
            }, this), this.continueBtn.pulse(), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.continueBtn)
        }, G.Window.prototype.win = function() {
            if (this.state = game.state.getCurrentState(), "CHALLENGE" !== this.state.mode) {
                G.lvl.lvlNr, G.lvl.points;
                var b = G.saveState.getLastPassedLevelNr();
                G.saveState.addLife(), G.lvl.resultData || (G.lvl.oldStars = G.saveState.getStars(G.lvl.lvlNr), G.lvl.resultData = G.saveState.passLevel(G.lvl.lvlNr, Math.max(1, G.lvl.stars), G.lvl.points, !0));
                var c = G.lvl.resultData,
                    d = G.lvl.oldStars;
                d < 3 && 3 == c.stars && (G.winsInRow || (G.winsInRow = 0), G.winsInRow++), "CHALLENGE" === this.state.mode ? G.gameTracking.complete("DailyChallenge", this.state.getLevelDimension(), void 0, G.lvl.points) : G.gameTracking.complete("Gate" + G.saveState.checkGateNr(G.lvlNr).toString(), this.state.getLevelDimension(), void 0, G.lvl.points);
                for (var e = 0; e < G.lvl.items.length; e++) G.lvl.items[e] && G.saveState.changeItemAmount(e, G.lvl.items[e]);
                this.result = c, this.addBackground("popup_background_2");
                var f = c.stars;
                this.ribbon = G.makeImage(0, -305, "popup_top", .5, this), this.titleTxt = new G.Text(0, -334, G.txt("Level") + " " + (this.state.lvlNr + 1), {
                    style: "font-beige-standard",
                    fontSize: 50
                }, .5, 330), this.add(this.titleTxt), this.youWinTxt = new G.Text(0, -90, G.txt("You win!"), {
                    style: "font-beige-standard",
                    fontSize: 45
                }, .5, 530), this.add(this.youWinTxt), this.scoreBg = G.makeImage(20, -5, "popup_text_backgr", .5, this), this.scoreIcon = G.makeImage(-90, -5, "score_icon", .5, this), this.scoreIcon.scale.setTo(1.2), 0 < G.lvl.resultData.reward && (this.coinBg = G.makeImage(20, 95, "popup_text_backgr", .5, this), this.coinIco = G.makeImage(-90, 95, "coin_1", .5, this), this.amountTxt = new G.OneLineCounter(25, 95, "font-beige-header", 0, 45, 160, .5, .5), this.add(this.amountTxt)), this.scoreTxt = new G.Text(32, -5, G.lvl.points.toString(), {
                    style: "font-beige-header",
                    fontSize: 45
                }, .5, 190), this.add(this.scoreTxt), this.retryBtn = new G.Button(-120, 205, "btn_green", function() {
                    1 === G.lvl.lvlNr || G.lvl.lvlNr, G.sb("onAllWindowsClosed").add(function() {
                        G.sb("onStateChange").dispatch("Game", G.lvlNr)
                    }), this.closeWindow()
                }, this), this.retryBtn.addTextLabel("font-blue-out", G.txt("Retry"), 50), this.add(this.retryBtn), this.continueBtn = new G.Button(120, 205, "btn_orange", function() {
                    0 === G.lvl.lvlNr || 1 === G.lvl.lvlNr || G.lvl.lvlNr, 4 <= G.saveState.getLastPassedLevelNr() && this.result.passed && G.sb("pushWindow").dispatch(["passedFriend", this.result]);
                    for (var a = JSON.parse(localStorage.getItem("glmdataCC")).points, b = 0, e = 0; e < 451; e++) void 0 !== a[e] && (b += a[e]);
                    try {
                        window.parent.postMessage("comandd|" + b, "*")
                    } catch (a) {}
                    G.sb("onAllWindowsClosed").add(function() {
                        game.paused = !0, game.paused = !1, G.sb("onStateChange").dispatch(G.debugMode ? "EditorWorld" : "World", {
                            lvlNr: G.lvl.lvlNr,
                            reward: G.lvl.moneyGained,
                            starImprovement: G.lvl.resultData.starImprovement
                        })
                    }), 2 == G.lvl.lvlNr && 0 == d || 3 <= G.winsInRow && Math.random() < G.json.settings.chancesForAchievementGift ? (G.winsInRow = 0, G.sb("pushWindow").dispatch(["gift", "achievement"])) : (0 == G.lvl.lvlNr && 0 == d || d < 3 && 3 == c.stars && Math.random() < G.json.settings.chancesFor3StarsGift) && G.sb("pushWindow").dispatch(["gift", "3stars"]), this.closeWindow()
                }, this), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.continueBtn), this.blankStars = [G.makeImage(-100, -180, "star_blank", .5, this), G.makeImage(0, -208, "star_blank", .5, this), G.makeImage(100, -180, "star_blank", .5, this)], this.blankStars[0].scale.setTo(.8), this.blankStars[2].scale.setTo(.8), this.stars = [G.makeImage(-100, -180, 1 <= f ? "star" : "star_blank", .5, this), G.makeImage(0, -208, 2 <= f ? "star" : "star_blank", .5, this), G.makeImage(100, -180, 3 <= f ? "star" : "star_blank", .5, this)], this.stars[0].scale.setTo(.8), this.stars[2].scale.setTo(.8), this.stars.forEach(function(a, b) {
                    if (b + 1 <= f) {
                        var c = a.scale.x;
                        a.scale.setTo(0), game.add.tween(a.scale).to({
                            x: c,
                            y: c
                        }, 300, Phaser.Easing.Bounce.Out, !0, 800 + 200 * b).onStart.add(function() {
                            G.sfx.pop.play(), G.sfx.explosion_subtle.play(), this.add(new G.WinStarPart(a.x, a.y, !0)), this.add(new G.WinStarPart(a.x, a.y, !0)), this.add(new G.WinStarPart(a.x, a.y, !0)), this.add(new G.WinStarPart(a.x, a.y, !0)), this.add(new G.WinStarPart(a.x, a.y, !0))
                        }, this)
                    } else a.visible = !1
                }, this), game.time.events.add(1e3, function() {
                    0 < c.reward && (G.gameTracking.source("Coins", "Reward", "LevelCompleted", c.reward), G.gameTracking.source("Coins", "Reward", "InGameChest", G.lvl.moneyGainedChest), this.amountTxt.increaseAmount(c.reward))
                }, this), G.sb("onLevelMoneyGain").dispatch(c.reward), 0 == b && (this.retryBtn.visible = !1, this.continueBtn.x = 0, this.continueBtn.pulse()), 0 == G.lvl.lvlNr && 0 == d && 0 < f && G.platform.firstLevelMsg(G.lvl.points), this.retryBtn.visible = !1, this.continueBtn.visible = !1, 0 !== b && (this.retryBtn.visible = !0), this.continueBtn.visible = !0, 0 === G.lvl.lvlNr || 1 === G.lvl.lvlNr || G.lvl.lvlNr
            } else this.winChallenge()
        }, G.Window.prototype.winChallenge = function() {
            this.addBackground("popup_background_2");
            var a = G.lvl.stars;
            G.saveState.passExtraLevel(a), G.gameTracking.complete("DailyChallenge", G.lvlData.lvlNumber, void 0, G.lvl.points), this.ribbon = G.makeImage(0, -290, "popup_top", .5, this), this.titleTxt = new G.Text(0, -315, G.txt("Daily Challenge"), {
                style: "font-beige-standard",
                fontSize: "50px"
            }, .5, 330), this.add(this.titleTxt), this.youWinTxt = new G.Text(0, -70, G.txt("You win!"), {
                style: "font-brown",
                fontSize: 45
            }, .5, 530), this.add(this.youWinTxt), this.scoreBg = G.makeImage(20, 20, "popup_text_backgr", .5, this), this.scoreIcon = G.makeImage(-90, 20, "score_icon", .5, this), this.scoreIcon.scale.setTo(1.2);
            var b = G.json.settings.coinsForStar[a - 1];
            0 < b && (this.coinBg = G.makeImage(20, 120, "popup_text_backgr", .5, this), this.coinIco = G.makeImage(-90, 120, "coin_1", .5, this), this.amountTxt = new G.OneLineCounter(25, 120, "font-brown", 0, 45, 160, .5, .5), this.add(this.amountTxt)), this.scoreTxt = new G.Text(32, 20, G.lvl.points.toString(), {
                style: "font-brown",
                fontSize: 45
            }, .5, 190), this.add(this.scoreTxt), this.continueBtn = new G.Button(0, 240, "btn_orange", function() {
                G.sb("onAllWindowsClosed").add(function() {
                    G.sb("onStateChange").dispatch(G.debugMode ? "EditorWorld" : "World", {
                        lvlNr: G.lvl.lvlNr,
                        reward: G.lvl.moneyGained,
                        starImprovement: a,
                        challenge: !0
                    })
                }), this.closeWindow()
            }, this), this.continueBtn.addTextLabel("font-green", G.txt("Continue"), 50), this.registerButtons(this.continueBtn), this.blankStars = [G.makeImage(-100, -150, "star_blank", .5, this), G.makeImage(0, -175, "star_blank", .5, this), G.makeImage(100, -150, "star_blank", .5, this)], this.blankStars[0].scale.setTo(.8), this.blankStars[2].scale.setTo(.8), this.stars = [G.makeImage(-100, -150, 1 <= a ? "star" : "star_blank", .5, this), G.makeImage(0, -175, 2 <= a ? "star" : "star_blank", .5, this), G.makeImage(100, -150, 3 <= a ? "star" : "star_blank", .5, this)], this.stars[0].scale.setTo(.8), this.stars[2].scale.setTo(.8), this.stars.forEach(function(b, c) {
                if (c + 1 <= a) {
                    var d = b.scale.x;
                    b.scale.setTo(0), game.add.tween(b.scale).to({
                        x: d,
                        y: d
                    }, 300, Phaser.Easing.Bounce.Out, !0, 800 + 200 * c).onStart.add(function() {
                        G.sfx.pop.play(), G.sfx.explosion_subtle.play(), this.add(new G.WinStarPart(b.x, b.y, !0)), this.add(new G.WinStarPart(b.x, b.y, !0)), this.add(new G.WinStarPart(b.x, b.y, !0)), this.add(new G.WinStarPart(b.x, b.y, !0)), this.add(new G.WinStarPart(b.x, b.y, !0))
                    }, this)
                } else b.visible = !1
            }, this), game.time.events.add(1e3, function() {
                0 < b && (G.sb("onLevelMoneyGain").dispatch(b), this.amountTxt.increaseAmount(b))
            }, this)
        }, G.Assets = {
            order: ["TitleScreen", "World", "Game"],
            jsons: ["languages", "levels", "settings", "specialCandies", "tutorials"],
            TitleScreen: {
                spritesheets: ["titleScreen", "buttons"],
                sfx: ["music", "pop", "transition"]
            },
            World: {
                spritesheets: ["mapsheet", "ssheet"],
                fonts: ["font-white", "font-pink"],
                images: ["bg_road.png"]
            },
            Game: {
                spritesheets: ["board", "gems", "bursteffects"],
                images: ["bg_1.png", "bg_2.png", "bg_3.png", "bg_4.png"],
                sfx: ["boom", "sugarcrush", "sweet", "tasty", "delicious", "divine", "lvlcompleted", "lvlfailed", "exchange", "lightning", "line", "match_1", "match_2", "match_3", "match_4", "match_5", "xylophone_positive", "xylophone_positive2", "xylophone_positive6", "explosion_subtle"]
            }
        }, G.Boot = function() {}, G.Boot.prototype = {
            init: function() {
                game.state.onStateChange.add(function() {
                    game.input.interactiveItems.removeAll()
                }), G.sentWorldMapDesignEvent = !1, G.playFabLogger = new G.PlayFabLogger, G.LIVES = !0, G.sb = G.SignalBox, G.lang = "fr", G.ASSETS.images.splice(G.ASSETS.images.indexOf("ja" === G.lang ? "BOOT-logo.png" : "BOOT-logo-ja.png"), 1), G.ASSETS.images.splice(G.ASSETS.images.indexOf("ja" === G.lang ? "BOOT-logo-mini.png" : "BOOT-logo-mini-ja.png"), 1);
                var a, b, c = !!(b = (a = (a || navigator.userAgent).toLowerCase()).match(/android\s([0-9\.]*)/)) && b[1];
                game.device.desktop ? (G.Loader.currentConfig = "hd", G.Loader.currentConfigMulti = 1) : c && parseFloat(c) < 4.4 ? (G.Loader.currentConfig = "ssd", G.Loader.currentConfigMulti = .4) : (G.Loader.currentConfig = "sd", G.Loader.currentConfigMulti = .6), G.Loader.currentConfig = "hd", G.Loader.currentConfigMulti = 1, this.input.maxPointers = 1, this.stage.disableVisibilityChange = !0, this.stage.backgroundColor = 16777215, game.tweens.frameBased = !1, game.time.advancedTiming = !0, this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL, this.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL, this.scale.pageAlignHorizontally = !0, this.scale.pageAlignVertically = !0, this.scaleGameSizeUpdate = function() {
                    game.state.current;
                    var a = window.innerWidth / window.innerHeight,
                        b = game.state.getCurrentState(),
                        c = G.l(640),
                        d = G.l(960),
                        e = c / d;
                    b.NOTRESIZABLE || b.NOSCALABLE || (G.horizontal = 1.35 < a, G.horizontal && "Game" === game.state.current && (d = G.l(770)), e < a ? (game.scale.setGameSize(Math.ceil(d * a), d), c = G.l(640), game.world.setBounds(Math.ceil(-.5 * (game.width - c)), 0, game.width, game.height)) : (game.scale.setGameSize(c, Math.ceil(c * (window.innerHeight / window.innerWidth))), c = G.l(640), game.world.setBounds(Math.ceil(-.5 * (game.width - c)), 0, Math.ceil(-.5 * (game.height - d)), game.height)), G.sb("onScreenResize").dispatch(game.width, game.height))
                }, game.resizeGame = this.scaleGameSizeUpdate, this.scale.setResizeCallback(function() {
                    G.old_w == window.innerWidth && G.old_h == window.innerHeight || (G.old_w = window.innerWidth, G.old_h = window.innerHeight, game.resizeGame())
                }), game.incentivised = 1, game.resizeGame()
            },
            preload: function() {
                G.Loader.loadBootAssets()
            },
            create: function() {
                game.resizeGame(), G.overlayBitmap = game.make.bitmapData(256, 256), G.overlayBitmap.fill(255, 0, 0, 1), game.state.start("Preloader")
            },
            enterIncorrectOrientation: function() {
                G.orientated = !1, document.getElementById("orientation").style.display = "block"
            },
            leaveIncorrectOrientation: function() {
                G.orientated = !0, document.getElementById("orientation").style.display = "none"
            }
        }, G.pad = function(a, b, c) {
            return c = c || "0", (a += "").length >= b ? a : new Array(b - a.length + 1).join(c) + a
        }, Phaser.Stage.prototype.visibilityChange = function(a) {
            if ("pagehide" !== a.type && "blur" !== a.type && "pageshow" !== a.type && "focus" !== a.type && "click" !== a.type)(document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === a.type) && (game.sound.mute = !0);
            else if ("pagehide" === a.type || "blur" === a.type) this.game.focusLoss(a), game.sound.mute = !0;
            else if ("pageshow" === a.type || "focus" === a.type) {
                this.game.focusGain(a);
                try {
                    var b = G.saveState.data.mute;
                    game.paused || (game.sound.mute = b)
                } catch (a) {}
            }
        }, Phaser.Text.prototype.updateText = function() {
            this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
            var a = this.text; - 1 < this.characterLimitSize && this.characterLimitSize < a.length && (a = this.text.substring(0, this.characterLimitSize) + this.characterLimitSuffix), this.style.wordWrap && (a = this.runWordWrap(this.text));
            var b = a.split(this.splitRegExp),
                c = this.style.tabs,
                d = [],
                e = 0,
                f = this.determineFontProperties(this.style.font),
                g = b.length;
            0 < this.style.maxLines && this.style.maxLines < b.length && (g = this.style.maxLines);
            for (var h = this._charCount = 0; h < g; h++) {
                if (0 === c) {
                    var i = this.style.strokeThickness + this.padding.x;
                    i += 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(b[h]) : this.context.measureText(b[h]).width, this.style.wordWrap && (i -= this.context.measureText(" ").width)
                } else {
                    var j = b[h].split(/(?:\t)/);
                    if (i = this.padding.x + this.style.strokeThickness, Array.isArray(c))
                        for (var k = 0, l = 0; l < j.length; l++) {
                            var m = 0;
                            m = 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width), 0 < l && (k += c[l - 1]), i = k + m
                        } else
                            for (l = 0; l < j.length; l++) i += 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.measureLine(j[l]) : Math.ceil(this.context.measureText(j[l]).width), i += this.game.math.snapToCeil(i, c) - i
                }
                d[h] = Math.ceil(i), e = Math.max(e, d[h])
            }
            this.canvas.width = e * this._res, this.canvas.width % 2 == 1 && (this.canvas.width = this.canvas.width + 1);
            var n, o, p = f.fontSize + this.style.strokeThickness + this.padding.y,
                q = p * g,
                r = this._lineSpacing;
            for (r < 0 && Math.abs(r) > p && (r = -p), 0 !== r && (q += 0 < r ? r * b.length : r * (b.length - 1)), this.canvas.height = q * this._res, this.canvas.height % 2 == 1 && (this.canvas.height = this.canvas.height + 1), this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round", h = this._charCount = 0; h < g; h++) n = this.style.strokeThickness / 2, o = this.style.strokeThickness / 2 + h * p + f.ascent, 0 < h && (o += r * h), "right" === this.style.align ? n += e - d[h] : "center" === this.style.align && (n += (e - d[h]) / 2), this.autoRound && (n = Math.round(n), o = Math.round(o)), 0 < this.colors.length || 0 < this.strokeColors.length || 0 < this.fontWeights.length || 0 < this.fontStyles.length ? this.updateLine(b[h], n, o) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === c ? this.context.strokeText(b[h], n, o) : this.renderTabLine(b[h], n, o, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === c ? this.context.fillText(b[h], n, o) : this.renderTabLine(b[h], n, o, !0)));
            this.updateTexture(), this.dirty = !1
        };
        var saveAs = saveAs || function(a) {
            "use strict";
            if (!(void 0 === a || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
                var b = a.document,
                    c = function() {
                        return a.URL || a.webkitURL || a
                    },
                    d = b.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                    e = "download" in d,
                    f = /constructor/i.test(a.HTMLElement),
                    g = function(b) {
                        (a.setImmediate || a.setTimeout)(function() {
                            throw b
                        }, 0)
                    },
                    h = function(a) {
                        setTimeout(function() {
                            "string" == typeof a ? c().revokeObjectURL(a) : a.remove()
                        }, 4e4)
                    },
                    i = function(a) {
                        return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type) ? new Blob([String.fromCharCode(65279), a], {
                            type: a.type
                        }) : a
                    },
                    j = function(b, j, k) {
                        function l() {
                            ! function(a, b, c) {
                                for (var d = (b = [].concat(b)).length; d--;) {
                                    var e = a["on" + b[d]];
                                    if ("function" == typeof e) try {
                                        e.call(a, c || a)
                                    } catch (a) {
                                        g(a)
                                    }
                                }
                            }(n, "writestart progress write writeend".split(" "))
                        }
                        k || (b = i(b));
                        var m, n = this,
                            o = "application/octet-stream" === b.type;
                        return n.readyState = n.INIT, e ? (m = c().createObjectURL(b), void setTimeout(function() {
                            d.href = m, d.download = j,
                                function(a) {
                                    var b = new MouseEvent("click");
                                    a.dispatchEvent(b)
                                }(d), l(), h(m), n.readyState = n.DONE
                        })) : void! function() {
                            if (o && f && a.FileReader) {
                                var d = new FileReader;
                                return d.onloadend = function() {
                                    var b = d.result;
                                    a.location.href = "data:attachment/file" + b.slice(b.search(/[,;]/)), n.readyState = n.DONE, l()
                                }, d.readAsDataURL(b), n.readyState = n.INIT
                            }
                            m = m || c().createObjectURL(b), o ? a.location.href = m : a.open(m, "_blank") || (a.location.href = m), n.readyState = n.DONE, l(), h(m)
                        }()
                    },
                    k = j.prototype;
                return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(a, b, c) {
                    return b = b || a.name || "download", c || (a = i(a)), navigator.msSaveOrOpenBlob(a, b)
                } : (k.abort = function() {}, k.readyState = k.INIT = 0, k.WRITING = 1, k.DONE = 2, k.error = k.onwritestart = k.onprogress = k.onwrite = k.onabort = k.onerror = k.onwriteend = null, function(a, b, c) {
                    return new j(a, b || a.name || "download", c)
                })
            }
        }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
        "undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null !== define.amd && define([], function() {
            return saveAs
        }), G.Editor = function() {
            this.game, this.add, this.camera, this.cache, this.input, this.load, this.math, this.sound, this.stage, this.time, this.tweens, this.state, this.world, this.particles, this.physics, this.rnd
        }, G.Editor.prototype = {
            init: function(a) {
                s = game.state.getCurrentState(), this.EDITOR = !0, this.NOTRESIZABLE = !0, G.lvl = {}, G.lvlNr = a, G.lvl.data = G.json.levels[a], G.lvlData = G.json.levels[a], G.lvl = new G.LvlObject
            },
            create: function() {
                game.world.setBounds(0, 0, game.width, game.height), game.scale.setGameSize(2e3, 1500), this.txt = game.add.existing(new G.Text(0, 0, "LEVEL " + (G.lvlNr + 1), {
                    style: "font-white",
                    fontSize: "50px"
                }, 0, 300)), this.board = new G.Board(G.lvlData, G.l(72), !0), this.board.update = function() {}, this.board.actionManager.glowPossibleMoves = function() {}, this.board.position.setTo(50, 150), this.board.boardIce.alpha = .7, this.board.inputController.destroy(), game.input.mouse.mouseWheelCallback = function() {
                    this.board.y += -50 * game.input.mouse.wheelDelta
                }.bind(this), this.dropZones = new G.EditorDropZones(this.board, G.lvlData.predefinedDrops), this.sidePanel = new G.EditorSidePanel(900), this.keys = game.input.keyboard.addKeys({
                    one: Phaser.Keyboard.ONE,
                    two: Phaser.Keyboard.TWO,
                    three: Phaser.Keyboard.THREE,
                    four: Phaser.Keyboard.FOUR,
                    five: Phaser.Keyboard.FIVE,
                    six: Phaser.Keyboard.SIX,
                    seven: Phaser.Keyboard.SEVEN,
                    eight: Phaser.Keyboard.EIGHT,
                    nine: Phaser.Keyboard.NINE,
                    zero: Phaser.Keyboard.ZERO,
                    tilde: Phaser.Keyboard.B,
                    z: Phaser.Keyboard.Z,
                    x: Phaser.Keyboard.X,
                    c: Phaser.Keyboard.C,
                    v: Phaser.Keyboard.V,
                    b: Phaser.Keyboard.B,
                    n: Phaser.Keyboard.N,
                    m: Phaser.Keyboard.M,
                    l: Phaser.Keyboard.L,
                    Q: Phaser.Keyboard.Q,
                    W: Phaser.Keyboard.W,
                    E: Phaser.Keyboard.E,
                    R: Phaser.Keyboard.R,
                    T: Phaser.Keyboard.T,
                    Y: Phaser.Keyboard.Y,
                    U: Phaser.Keyboard.U,
                    P: Phaser.Keyboard.P,
                    A: Phaser.Keyboard.A,
                    S: Phaser.Keyboard.S,
                    D: Phaser.Keyboard.D,
                    F: Phaser.Keyboard.F,
                    G: Phaser.Keyboard.G,
                    SPACE: Phaser.Keyboard.SPACEBAR
                }), this.keys.one.onDown.add(function() {
                    this.dbgChangeCandy("1")
                }, this), this.keys.two.onDown.add(function() {
                    this.dbgChangeCandy("2")
                }, this), this.keys.three.onDown.add(function() {
                    this.dbgChangeCandy("3")
                }, this), this.keys.four.onDown.add(function() {
                    this.dbgChangeCandy("4")
                }, this), this.keys.five.onDown.add(function() {
                    this.dbgChangeCandy("5")
                }, this), this.keys.six.onDown.add(function() {
                    this.dbgChangeCandy("6")
                }, this), this.keys.seven.onDown.add(function() {
                    this.dbgChangeCandy("r")
                }, this), this.keys.eight.onDown.add(function() {
                    this.dbgChangeCandy("chest")
                }, this), this.keys.nine.onDown.add(function() {
                    this.dbgChangeCandy("goalCandy")
                }, this), this.keys.S.onDown.add(function() {
                    this.dbgChangeCandy("infection")
                }, this), this.keys.tilde.onDown.add(function() {
                    this.dbgChangeCandyIntoSpecial()
                }, this), this.keys.SPACE.onDown.add(function() {
                    for (var a = 0; a < 8; a++)
                        for (var b = 0; b < 8; b++)
                            if (this.board.isCellOnBoard(a, b)) {
                                var c = this.board.getCandy(a, b);
                                c && c.destroy(), this.board.boardCandies.newCandy(a, b, this.board.getRandomThatDoesntMatch(a, b))
                            }
                }, this), this.keys.zero.onDown.add(function() {
                    for (var a = 0; a < 10; a++)
                        for (var b = 0; b < 10; b++)
                            if (this.board.isCellOnBoard(a, b)) {
                                var c = this.board.getCandy(a, b);
                                c && c.destroy(), this.board.boardCandies.newCandy(a, b, "r")
                            }
                }, this), this.keys.P.onDown.add(function() {
                    var a = this.board.inputController.pointerToCell(game.input.activePointer);
                    if (a && this.board.isCellOnBoard(a)) {
                        var b = this.board.getCandy(a[0], a[1]);
                        b && "infection" !== b.candyType && (b.infected ? b.infect() : b.removeInfection())
                    }
                }, this), this.keys.A.onDown.add(function() {
                    var a = this.board.inputController.pointerToCell(game.input.activePointer);
                    if (a && this.board.isCellOnBoard(a)) {
                        var b = this.board.getCandy(a[0], a[1]);
                        b && "infection" !== b.candyType && (b.wrapped ? b.unwrap() : b.wrap())
                    }
                }, this), this.keys.D.onDown.add(function() {
                    var a = this.board.inputController.pointerToCell(game.input.activePointer);
                    if (a && this.board.isCellOnBoard(a)) {
                        var b = this.board.getCandy(a[0], a[1]);
                        b && "infection" !== b.candyType && (b.blocker ? 1 == b.blockerHp ? b.removeBlocker() : b.changeIntoBlocker(b.blockerHp - 1) : b.changeIntoBlocker(3))
                    }
                }, this), this.keys.W.onDown.add(function() {
                    this.changeHpToken(this.board.boardIce)
                }, this), this.keys.Y.onDown.add(function() {
                    var a = this.board.inputController.pointerToCell(game.input.activePointer);
                    if (a) {
                        if ("X" == this.board.boardData.get(a[0], a[1])) return this.board.boardData.set(a[0], a[1], null), void this.board.boardBackground.redraw();
                        this.board.boardData.set(a[0], a[1], "X"), this.board.boardBackground.redraw(), this.board.layers.forEach(function(b) {
                            b.grid.get(a[0], a[1]) && b.removeToken(a[0], a[1])
                        }, this)
                    }
                }, this), this.keys.U.onDown.add(function() {
                    this.changeHpToken(this.board.boardIce)
                }, this), this.keys.E.onDown.add(function() {
                    this.changeHpToken(this.board.boardCage)
                }, this), this.keys.R.onDown.add(function() {
                    this.changeHpToken(this.board.boardDirt)
                }, this), this.keys.F.onDown.add(function() {
                    this.changeHpToken(this.board.boardDirtS)
                }, this), this.keys.G.onDown.add(function() {
                    this.changeHpToken(this.board.boardJam)
                }, this), this.keys.T.onDown.add(function() {
                    var a = this.board.inputController.pointerToCell(game.input.activePointer);
                    a && this.board.getCandy(a[0], a[1]) && this.board.removeCandy(a[0], a[1])
                }, this), this.keys.z.onDown.add(function() {
                    this.sidePanel.exportLevel();
                    for (var a = G.lvlData.levelData.length, b = G.lvlData.levelData, c = JSON.parse(JSON.stringify(b)), d = a % 2 == 0 ? .5 * a : Math.floor(.5 * a), e = 0; e < d; e++) c[e] = JSON.parse(JSON.stringify(b[e])), c[a - (e + 1)] = JSON.parse(JSON.stringify(b[e]));
                    G.lvlData.levelData = c, game.state.start("Editor", !0, !1, G.lvlNr)
                }, this), this.keys.x.onDown.add(function() {
                    this.sidePanel.exportLevel();
                    for (var a = G.lvlData.levelData[0].length, b = G.lvlData.levelData, c = JSON.parse(JSON.stringify(b)), d = a % 2 == 0 ? .5 * a : Math.floor(.5 * a), e = 0; e < b.length; e++)
                        for (var f = 0; f < d; f++) c[e][a - (f + 1)] = JSON.parse(JSON.stringify(c[e][f]));
                    G.lvlData.levelData = c, game.state.start("Editor", !0, !1, G.lvlNr)
                }, this), this.keys.c.onDown.add(function() {
                    var a = this.board.inputController.pointerToCell(game.input.activePointer);
                    a && this.board.boardCollectCells.editorChangeCC(a[0], a[1])
                }, this)
            },
            update: function() {},
            changeHpToken: function(a) {
                var b = this.board.inputController.pointerToCell(game.input.activePointer);
                if (b) {
                    var c = b[0],
                        d = b[1];
                    if (this.board.isCellOnBoard(c, d)) {
                        var e = a.getToken(c, d);
                        if (e) {
                            var f = e.hp;
                            console.log("changeHpToken", f), a.destroyCell(c, d), f < a.config.maxHp && a.createToken(c, d, f + 1)
                        } else console.log("create token"), a.createToken(c, d, 1)
                    }
                }
            },
            changeBoardSize: function(a, b) {
                a = game.math.clamp(a, 4, 10), b = game.math.clamp(b, 4, 10);
                var c = this.board.boardData;
                this.board.boardData = new G.GridArray(a, b, null), c.loop(function(a, b, c) {
                    this.board.boardData.isInGrid(b, c) && "X" == a && this.board.boardData.set(b, c, "X")
                }, this), this.board.boardBackground.redraw(), this.board.layers.forEach(function(c) {
                    var d = c.grid;
                    c.grid = new G.GridArray(a, b, !1), d.loop(function(a, b, d) {
                        c.grid.isInGrid(b, d) ? c.grid.set(b, d, a) : a && a.destroy && a.destroy()
                    })
                }), G.sb("editorChangedBoardSize").dispatch()
            },
            dbgChangeCandy: function(a) {
                var b = this.board.inputController.pointerToCell(game.input.activePointer);
                if (b && this.board.isCellOnBoard(b)) {
                    var c = this.board.getCandy(b[0], b[1]);
                    c && c.destroy(), this.board.boardCandies.newCandy(b[0], b[1], a)
                }
            },
            dbgChangeCandyIntoSpecial: function() {
                var b = this.board.inputController.pointerToCell(game.input.activePointer);
                if (b && this.board.isCellOnBoard(b)) {
                    var c = this.board.getCandy(b[0], b[1]);
                    if (!c) return;
                    var d = c.candyType;
                    console.log("candyType", d), !1 === c.specialType ? c.changeInto("horizontal", !0) : "horizontal" === c.specialType ? (c.destroy(), this.board.boardCandies.newCandy(b[0], b[1], d).changeInto("vertical", !0)) : "vertical" === c.specialType ? (c.destroy(), this.board.boardCandies.newCandy(b[0], b[1], d).changeInto("cross", !0)) : "cross" === c.specialType ? (c.destroy(), this.board.boardCandies.newCandy(b[0], b[1], d).changeInto("spiral", !0)) : "spiral" === c.specialType && (c.destroy(), this.board.boardCandies.newCandy(b[0], b[1], "1"))
                }
            },
            render: function() {
                game.debug.text(game.time.fps, 300, 10, "#ff0000");
                var a = this.board.inputController.pointerToCell(game.input.activePointer);
                if (game.debug.text(this.board.inputController.isPointerInRange(game.input.activePointer), 10, 10, "#ff0000"), game.debug.text(a, 10, 40, "#ff0000"), game.debug.text(this.board.isCellOnBoard(this.board.inputController.pointerToCell(game.input.activePointer)), 10, 80, "#ff0000"), a) {
                    var b = this.board.getCandy(a[0], a[1]);
                    b && game.debug.text(b.candyType, 10, 150, "#ff0000")
                }
            },
            shutdown: function() {
                G.IMMEDIATE = !1, game.input.mouse.mouseWheelCallback = null
            }
        }, G.EditorWorld = function() {}, G.EditorWorld.prototype = {
            init: function(a) {
                s = game.state.getCurrentState(), this.NOTRESIZABLE = !0, this.EDITOR = !0, this.lastLvlIndex = null, "object" == typeof a ? this.lastLvlIndex = a.lvlNr : "number" == typeof a && (this.lastLvlIndex = a), this.fillSaveState3Stars(), this.selectedLevels = []
            },
            create: function() {
                game.world.setBounds(0, 0, game.width, game.height), game.scale.setGameSize(2300, 1300), this.map = new G.WorldMap(G.json.settings.mapTiles, [], G.json.levels, !0), this.sidePanel = new G.EditorWorldSidePanel(1400, 10), this.keys = game.input.keyboard.addKeys({
                    C: Phaser.Keyboard.C,
                    M: Phaser.Keyboard.M,
                    CTRL: Phaser.Keyboard.CONTROL
                }), this.cursors = game.input.keyboard.createCursorKeys(), game.input.onDown.add(function(a) {
                    var b = Math.floor((a.worldX - this.map.x) * (1 / G.Loader.currentConfigMulti)),
                        c = Math.floor((a.worldY - this.map.y) * (1 / G.Loader.currentConfigMulti));
                    this.keys.C.isDown && (this.map.lvlBtnGroup.add(G.makeImage(b, c, "map_point", .5)), G.json.levels.push({
                        mapX: b,
                        mapY: c,
                        moves: 30,
                        rainbowChance: 2,
                        nrOfTypes: 5,
                        goal: ["collect", [
                            ["1", 5],
                            ["2", 5],
                            ["3", 5],
                            ["4", 5]
                        ]],
                        starsReq: [5e3, 7500, 1e4],
                        drops: [],
                        levelData: [
                            [
                                ["1"],
                                ["3"],
                                ["1"],
                                ["4"],
                                ["1"]
                            ],
                            [
                                ["2"],
                                ["3"],
                                ["2"],
                                ["3"],
                                ["4"]
                            ],
                            [
                                ["4"],
                                ["1"],
                                ["2"],
                                ["1"],
                                ["2"]
                            ],
                            [
                                ["1"],
                                ["4"],
                                ["4"],
                                ["3"],
                                ["1"]
                            ],
                            [
                                ["2"],
                                ["1"],
                                ["3"],
                                ["2"],
                                ["4"]
                            ],
                            [
                                ["3"],
                                ["4"],
                                ["1"],
                                ["4"],
                                ["3"]
                            ]
                        ]
                    }), this.fillSaveState3Stars(), this.map.refreshButtons()), this.keys.M.isDown && this.moveLevels(b, c)
                }, this), void 0 !== this.lastLvlIndex && (this.map.centerOnLvl(this.lastLvlIndex + 1), this.selectLevel(this.lastLvlIndex))
            },
            selectLevel: function(a) {
                "number" == typeof a ? this.keys.CTRL.isDown ? this.selectedLevels.includes(a) ? this.selectedLevels.splice(this.selectedLevels.indexOf(a), 1) : this.selectedLevels.push(a) : this.selectedLevels = this.selectedLevels.includes(a) ? [] : [a] : this.selectedLevels = Array.isArray(a) ? a : [], this.selectedLevels.sort(function(a, b) {
                    return a - b
                }), this.map.refreshButtons(), G.sb("editorLevelSelected").dispatch(), this.sidePanel.refresh()
            },
            moveLevels: function(a, b) {
                if (0 !== this.selectedLevels.length) {
                    var c = this.selectedLevels.map(function(a, b, c) {
                        var d = G.json.levels[c[0]],
                            e = G.json.levels[a];
                        return {
                            x: e.mapX - d.mapX,
                            y: e.mapY - d.mapY
                        }
                    });
                    this.selectedLevels.forEach(function(d, e) {
                        G.json.levels[d].mapX = a + c[e].x, G.json.levels[d].mapY = b + c[e].y
                    }), this.map.refreshButtons()
                }
            },
            fillSaveState3Stars: function() {
                G.saveState.data.levels = [];
                for (var a = 0; a < G.json.levels.length; a++) G.saveState.data.levels.push(3);
                G.saveState.save()
            },
            update: function() {
                this.selectedLevels.forEach(function(a) {
                    this.cursors.up.isDown && (G.json.levels[a].mapY--, this.map.refreshButtons()), this.cursors.down.isDown && (G.json.levels[a].mapY++, this.map.refreshButtons()), this.cursors.left.isDown && (G.json.levels[a].mapX--, this.map.refreshButtons()), this.cursors.right.isDown && (G.json.levels[a].mapX++, this.map.refreshButtons())
                }, this)
            },
            render: function() {
                game.debug.text(game.time.fps, 10, 10, "#ff0000")
            }
        }, G.ErrorState = function() {}, G.ErrorState.prototype = {
            preload: function() {},
            create: function() {
                this.bg = new G.LevelBg, new G.AnotherTabWindow
            }
        }, G.Game = function() {}, G.Game.prototype = {
            init: function(a, b, c, d) {
                this.gameId = game.rnd.uuid(), G.giftStatusIndex = 0, s = game.state.getCurrentState(), d ? (this.lvlNr = 1e4 + (G.saveState.data.dailyBeaten || 0), G.lvlData = d, this.mode = "CHALLENGE") : (this.lvlNr = Math.min(G.json.levels.length - 1, a), G.lvlData = JSON.parse(JSON.stringify(G.json.levels[a])), this.mode = "NORMAL"), this.debugMode = b || !1, G.debugMode = this.debugMode, this.startBoosters = c || [], this.doubleMoney = !1
            },
            preload: function() {},
            create: function() {
                this.lvlNr, game.resizeGame(), G.saveState.loseLife(), "CHALLENGE" === this.mode ? G.gameTracking.start("DailyChallenge", this.getLevelDimension()) : G.gameTracking.start("Gate" + G.saveState.checkGateNr(this.lvlNr).toString(), this.getLevelDimension()), this.tracker = new G.TrackData(this.lvlNr, G.lvlData), G.lvl = new G.LvlObject, this.debugMode && game.resizeGame(), this.bg = new G.LevelBg, this.board = new G.Board(G.lvl.data, G.l(72)), this.topBar = new G.UI_TopBar, this.boosterPanel = new G.UI_BoosterPanel, this.collectableAnimLayer = new G.CollectableAnimLayer(this.board, this.topBar), this.chestLayer = new G.ChestLayer, this.UIFxLayer = new G.UIFxLayer, this.fxTopLayer = new G.TopFxLayer(this.board, "fxTop"), this.fxTopLayer.position = this.board.boardCandies.position, this.fxTopLayer.scale = this.board.boardCandies.scale, this.pointsLayer = new G.PointsLayer(this.topBar), this.popOutMoneyLayer = new G.PopOutMoneyLayer, this.shoutOuts = new G.UI_ShoutOuts, this.overlay = new G.Overlay, this.windowLayer = new G.WindowLayer, this.fadeLayer = new G.FadeLayer, this.windowLayer.pushWindow("taskSlider"), G.json.tutorials[this.lvlNr + 1] && -1 == G.saveState.data.finishedTutorials.indexOf(this.lvlNr + 1) ? (G.sb("onAllWindowsClosed").addOnce(function() {
                    new G.Tutorial(this.lvlNr + 1)
                }, this), G.sb("onTutorialFinish").addOnce(function() {
                    G.sb("actionQueueEmpty").addOnce(function() {
                        this.board.actionManager.newAction("startBoosterInit")
                    }, this)
                }, this)) : G.sb("onAllWindowsClosed").addOnce(function() {
                    this.board.actionManager.newAction("startBoosterInit")
                }, this), this.debugMode && this.debugInit(), game.resizeGame(), game.device.desktop || game.input.onUp.add(function() {
                    if (!game.isFullScreen) {
                        game.isFullScreen = !0;
                        try {
                            document.body[game.device.requestFullscreen]()
                        } catch (a) {
                            console.log(a)
                        }
                    }
                }, this)
            },
            update: function() {
                G.delta(), G.DEBUG && (this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer))
            },
            getLevelDimension: function() {
                return "Level" + G.pad(this.lvlNr + 1, 4)
            },
            render: function() {},
            initDebugTools: function() {
                var a = game.input.keyboard.addKeys({
                    one: Phaser.Keyboard.ONE,
                    two: Phaser.Keyboard.TWO,
                    three: Phaser.Keyboard.THREE,
                    four: Phaser.Keyboard.FOUR,
                    five: Phaser.Keyboard.FIVE,
                    six: Phaser.Keyboard.SIX,
                    r: Phaser.Keyboard.R
                });
                a.one.onDown.add(function() {
                    this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer), s.board.getCandy(this.dbgPos[0], this.dbgPos[1]).changeInto("1")
                }, this), a.two.onDown.add(function() {
                    this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer), s.board.getCandy(this.dbgPos[0], this.dbgPos[1]).changeInto("2")
                }, this), a.three.onDown.add(function() {
                    this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer), s.board.getCandy(this.dbgPos[0], this.dbgPos[1]).changeInto("3")
                }, this), a.four.onDown.add(function() {
                    this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer), s.board.getCandy(this.dbgPos[0], this.dbgPos[1]).changeInto("4")
                }, this), a.five.onDown.add(function() {
                    this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer), s.board.getCandy(this.dbgPos[0], this.dbgPos[1]).changeInto("5")
                }, this), a.six.onDown.add(function() {
                    this.dbgPos = this.board.inputController.pointerToCell(game.input.activePointer), s.board.getCandy(this.dbgPos[0], this.dbgPos[1]).changeInto("6")
                }, this)
            },
            shutdown: function() {},
            debugInit: function() {
                this.initDebugTools();
                var a = game.add.text(0, 0, "LEVEL " + (this.lvlNr + 1));
                game.add.existing(a);
                var b = game.add.text(150, 0, "TOOL");
                b.inputEnabled = !0, b.input.useHandCursor = !0, b.events.onInputDown.add(function() {
                    G.openLevelMgr(G.json.levels)
                }, this), game.add.existing(b);
                var c = game.add.text(250, 0, "MAP");
                c.inputEnabled = !0, c.input.useHandCursor = !0, c.events.onInputDown.add(function() {
                    game.state.start("EditorWorld")
                }, this), game.add.existing(c);
                var d = game.add.text(350, 0, "LVL EDIT");
                d.inputEnabled = !0, d.input.useHandCursor = !0, d.events.onInputDown.add(function() {
                    game.state.start("Editor", !0, !1, this.lvlNr)
                }, this), game.add.existing(d);
                var e = game.add.text(500, 0, "PREV");
                e.inputEnabled = !0, e.input.useHandCursor = !0, e.events.onInputDown.add(function() {
                    console.log("current: " + G.lvlNr), console.log("prev: " + Math.max(0, this.lvlNr - 1)), game.state.start("Game", !0, !1, Math.max(0, this.lvlNr - 1), !0)
                }, this), game.add.existing(e);
                var f = game.add.text(600, 0, "NEXT");
                f.inputEnabled = !0, f.input.useHandCursor = !0, f.events.onInputDown.add(function() {
                    console.log("current: " + G.lvlNr), console.log("nextL " + Math.min(G.json.levels.length - 1, this.lvlNr + 1)), game.state.start("Game", !0, !1, Math.min(G.json.levels.length - 1, this.lvlNr + 1), !0)
                }, this), game.add.existing(f)
            }
        }, G.debugGoToLevel = function(a) {
            G.saveState.data.levels = [], G.saveState.data.finishedTutorials = [], G.saveState.data.boosters = [null, 30, 30, 30, 30, 30, 30, 30, 30];
            for (var b = 0; b < a; b++) G.saveState.data.levels.push(3);
            game.state.start("Game", !0, !1, a - 1, !0)
        }, G.MapEditor = function() {}, G.MapEditor.prototype = {
            init: function() {
                s = game.state.getCurrentState()
            },
            create: function() {
                this.mapGroup = new G.StrObjGroup(.5 * game.width, .5 * game.height, G.json.map), this.gfxHelpLayer = game.add.graphics(), this.gfxHelpLayer.lineStyle(1, 16711680, .5), this.gfxHelpLayer.moveTo(0, 0), this.gfxHelpLayer.lineTo(0, 2e3), this.gfxHelpLayer.moveTo(-600, 0), this.gfxHelpLayer.lineTo(-600, 2e3), this.gfxHelpLayer.moveTo(600, 0), this.gfxHelpLayer.lineTo(600, 2e3), this.modify = new G.Modify, this.modify.addMouseWheel()
            },
            update: function() {
                this.mapGroup.x = game.world.bounds.x + .5 * game.width, this.gfxHelpLayer.x = this.mapGroup.x
            },
            render: function() {}
        }, G.MidLoader = function() {}, G.MidLoader.prototype = {
            init: function(a, b) {
                console.log("mid state loader init"), this.transitionCandy = G.makeImage(480, 0, "transition", .5), this.transitionCandy.angle = G.fadeTransitionAngle || 0, this.transitionCandy.scale.setTo(7), this.transitionCandy.y = .5 * game.height, this.softGamesLogo = new G.Button(480, 0, "softgames_logo", function() {
                    SG && SG.redirectToPortal()
                }), game.add.existing(this.softGamesLogo), this.softGamesLogo.y = .5 * game.height, this.softGamesLogo.width = G.l(800), this.softGamesLogo.scale.y = this.softGamesLogo.scale.x, this.softGamesLogo.addTerm(function() {
                    return 1 == this.alpha
                }), this.softGamesLogo.input.useHandCursor = !1, this.softGamesLogo.alpha = 0, this.goTo = a, this.neededAssets = G.Assets[a], this.args = b || []
            },
            create: function() {},
            update: function() {
                G.delta(), this.transitionCandy.angle += 1 * G.deltaTime, G.fadeTransitionAngle = this.transitionCandy.angle, G.Loader.checkAssets(this.neededAssets) ? (this.softGamesLogo.alpha = game.math.clamp(this.softGamesLogo.alpha - .05, 0, 1), 0 == this.softGamesLogo.alpha && (this.args.splice(0, 0, this.goTo, !0, !1), game.state.start.apply(game.state, this.args))) : this.softGamesLogo.alpha = game.math.clamp(this.softGamesLogo.alpha + .05, 0, 1)
            }
        }, G.Preloader = function() {}, G.Preloader.prototype = {
            preload: function() {
                console.log("Preloader:"), this.ready = !1, this.load.onFileComplete.add(function(a) {
                    console.log("progress:" + a)
                }), this.logo = new G.Logo(320, 360), this.loadingBar = G.makeImage(320, 650, "loading_bar"), this.loadingBar.x -= .5 * this.loadingBar.width, this.loadingBar.y -= .5 * this.loadingBar.height, this.loadingBarFull = G.makeImage(320, 650, "loading_bar_full"), this.loadingBarFull.x -= .5 * this.loadingBarFull.width, this.loadingBarFull.y -= .5 * this.loadingBarFull.height, this.load.setPreloadSprite(this.loadingBarFull, 0), G.SGLOGO && (this.softgamesBtn = game.add.button(320, 850, "softgames_logo", function() {}), this.softgamesBtn.anchor.setTo(.5)), G.Loader.loadAssets(), this.fadeLayer = new G.FadeLayer
            },
            create: function() {
                G.addTextStyles(), G.logoURI = this.getImageURL("logo"), G.json.settings.boostersUnlock = [null, 0, 0, 0, 0], Object.keys(G.json.tutorials).forEach(function(a) {
                    G.json.tutorials[a].boosterNr && (G.json.settings.boostersUnlock[G.json.tutorials[a].boosterNr] = parseInt(a))
                }), G.json.levels.find(function(a) {
                    return a.tutID
                }) || Object.keys(G.json.tutorials).forEach(function(a) {
                    G.json.levels[parseInt(a) - 1].tutID = a
                }), G.saveState.init(), this.processSpecialCandiesJson(), game.resizeGame(), null === game.cache.getSound("music") && (Phaser.Sound.prototype.play = function() {}), game.canvas.addEventListener("click", function() {
                    try {
                        game.sound.context.resume()
                    } catch (a) {}
                })
            },
            update: function() {
                this.ready || !G.saveState.ready || null !== game.cache.getSound("music") && !G.sfx.music.isDecoded || (this.ready = !0, G.globalGoalMgr = new G.GlobalGoalMgr, console.log("game is ready"), window._game_loading_timer && (Date.now(), window._game_loading_timer, window._game_loading_timer = !1), G.firstTime ? G.sb("onStateChange").dispatch("Game", 0) : G.sb("onStateChange").dispatch("World"))
            },
            processSpecialCandiesJson: function() {
                G.specialCandies = {
                    names: [],
                    patterns: [],
                    lookUp: {},
                    combos: G.json.specialCandies.combos,
                    isTypeSpecial: function(a) {
                        return -1 != this.names.indexOf(a)
                    },
                    getSpecialData: function(a) {
                        return this.lookUp[a]
                    }
                }, G.json.specialCandies.candies.forEach(function(a) {
                    G.specialCandies.names.push(a.name), a.patterns && G.specialCandies.patterns.push([a.name, a.patterns]), G.specialCandies.lookUp[a.name] = a
                })
            },
            getImageURL: function(a) {
                return this._bmpMarker || (this._bmpMarker = this.game.make.image(0, 0, null, 0, null)), this._bmp || (this._bmp = this.game.make.bitmapData()), this._bmp.clear(), G.changeTexture(this._bmpMarker, a), this._bmp.resize(this._bmpMarker.width, this._bmpMarker.height), this._bmp.draw(this._bmpMarker), this._bmp.canvas.toDataURL()
            }
        }, G.TestState = function() {
            this.game, this.add, this.camera, this.cache, this.input, this.load, this.math, this.sound, this.stage, this.time, this.tweens, this.state, this.world, this.particles, this.physics, this.rnd
        }, G.TestState.prototype = {
            init: function() {},
            create: function() {
                this.testGroup = game.add.group(), this.testGroup2 = game.add.group(), this.testGroup2.x = 10, this.testGroup2.add(this.testGroup), this.testGroup3 = game.add.group(), this.testGroup3.y = 50, this.testGroup3.add(this.testGroup2), this.testGroup4 = game.add.group(), this.testGroup4.angle = 30, this.testGroup4.add(this.testGroup3);
                for (var a = 0; a < 200; a++) {
                    var b = G.makeImage(0, 0, "b_play_big_1", .5);
                    b.scale.x = 2, b.dirX = 20 * Math.random() - 10, b.dirY = 20 * Math.random() - 10, b.update = function() {
                        this.x += this.dirX, this.y += this.dirY, this.x < 0 && (this.x = 0, this.dirX *= -1), this.y < 0 && (this.y = 0, this.dirY *= -1), this.x > game.width && (this.x = game.width, this.dirX *= -1), this.y > game.height && (this.y = game.height, this.dirY *= -1)
                    }
                }
            },
            update: function() {},
            render: function() {
                game.debug.text(game.time.fps, 300, 10, "#ff0000")
            }
        }, G.TitleScreen = function() {}, G.TitleScreen.prototype = {
            init: function() {
                G.giftStatusIndex = 0, this.stage.backgroundColor = 16768477, s = game.state.getCurrentState(), game.world.children[0] && game.world.children[0].destroy()
            },
            create: function() {
                this.bg = new G.LevelBg, this.gemThrower = new G.TitleScreenGemsThrower, this.gemThrower.alpha = .7, this.mainGroup = game.add.group(), this.logo = new G.Logo(320, 360), this.playBtn = new G.Button(320, 650, "btn_play", function() {
                    G.sb("onStateChange").dispatch("World")
                }), game.add.existing(this.playBtn), this.soundBtn = new G.SoundBtn(100, 850), this.moreGamesBtn = new G.MoreGamesBtn(540, 850), this.mainGroup.addMultiple([this.logo, this.playBtn, this.soundBtn, this.moreGamesBtn]), this.fadeLayer = new G.FadeLayer, this.editorString = "", this.EDITORKEY = game.input.keyboard.addKeys({
                    Q: Phaser.KeyCode.Q,
                    W: Phaser.KeyCode.W,
                    E: Phaser.KeyCode.E
                }), this.EDITORKEY.Q.onDown.add(function() {
                    this.onEditorKey("Q")
                }, this), this.EDITORKEY.W.onDown.add(function() {
                    this.onEditorKey("W")
                }, this), this.EDITORKEY.E.onDown.add(function() {
                    this.onEditorKey("E")
                }, this), G.sb("onScreenResize").add(this.onScreenResize, this), this.onScreenResize(), game.resizeGame()
            },
            onScreenResize: function() {
                G.horizontal ? (this.logo.y = G.l(360), this.soundBtn.x = G.l(50), this.moreGamesBtn.x = G.l(590), this.soundBtn.y = this.moreGamesBtn.y = G.l(850), this.playBtn.y = G.l(800), this.mainGroup.y = 0) : (this.logo.y = G.l(260), this.soundBtn.x = G.l(100), this.moreGamesBtn.x = G.l(540), this.soundBtn.y = this.moreGamesBtn.y = G.l(850), this.playBtn.y = G.l(650), this.mainGroup.y = .5 * (game.height - G.l(960)))
            },
            update: function() {
                G.delta()
            },
            onEditorKey: function(a) {
                this.editorString += a, "QWEWQ" === this.editorString.slice(-5) && G.openLevelMgr(G.json.levels)
            },
            render: function() {}
        }, G.World = function() {}, G.World.prototype = {
            init: function(a) {
                G.globalGoalMgr.unlockCheck(), G.giftStatusIndex = 0, s = game.state.getCurrentState(), this.lastLevelData = a, this.startBoosterConfig = new G.StartBoosterConfig, document.body.style.backgroundColor = "#41354c", document.body.style.backgroundImage = "none"
            },
            create: function() {
                G.sentWorldMapDesignEvent || (G.gameTracking.design("SessionFirstTimeWorldMapVisible"), G.sentWorldMapDesignEvent = !0), game.resizeGame(), G.saveState.increaseMapVisibleCounter(), G.globalGoalMgr.saveGoals(), this.map = new G.WorldMap(G.json.settings.mapTiles, G.json.settings.mapAnimatedElements, G.json.levels);
                var a = G.saveState.getLastPassedLevelNr();
                if (G.json.levels[a] && (this.tutHandGroup = game.add.group(), this.tutHandGroup.position = this.map.position, this.tutHand = new G.MapTutHand(this.map), this.tutHandGroup.add(this.tutHand)), this.panel = new G.UI_MapPanel, this.mapGift = new G.MapGift, this.dailyChallengeIcon = new G.UI_DailyChallengeIcon(855, 220), this.dailyIcon = new G.UI_DailyIcon(855, 130, !G.saveState.data.sawDailyTut), this.globalGoalBtn = new G.GlobalGoalButton(-270, 125), G.GINGEREVENT && (this.gb = new G.GingerMapButton), this.uiTargetParticlesBW = new G.UITargetParticles, this.windowLayer = new G.WindowLayer(0, 0), this.windowLayer.resize(), this.fxMapLayer = new G.FxMapLayer, this.uiTargetParticles = new G.UITargetParticles, this.fadeLayer = new G.FadeLayer, game.device.desktop || game.input.onUp.add(function() {
                        if (!game.isFullScreen) {
                            game.isFullScreen = !0;
                            try {
                                document.body[game.device.requestFullscreen]()
                            } catch (a) {
                                console.log(a)
                            }
                        }
                    }, this), !G.checkedDailyReward) {
                    G.checkedDailyReward = !0;
                    var b = G.saveState.dailyReward_reportVisit();
                    null !== b && G.sb("pushWindow").dispatch(["dailyReward", b])
                }
            },
            update: function() {
                G.delta()
            },
            makeBlackOverlay: function() {},
            render: function() {}
        }, window.startGame = function() {
            var a = new Phaser.Game(800, 1100, Phaser.CANVAS, "", null, !0);
            (window.game = a).state.add("Boot", G.Boot), a.state.add("Preloader", G.Preloader), a.state.add("World", G.World), a.state.add("Game", G.Game), a.state.add("Editor", G.Editor), a.state.add("EditorWorld", G.EditorWorld), a.state.add("TitleScreen", G.TitleScreen), a.state.add("TestState", G.TestState), a.state.add("MidLoader", G.MidLoader), a.state.add("ErrorState", G.ErrorState), a.state.add("MapEditor", G.MapEditor), a.state.start("Boot")
        }, window.initGame = function() {
            document.body.style.backgroundImage = "url(https://830581635-628405001538672842.preview.editmysite.com/uploads/b/139890129-709153476852373754/files/img/bg.jpg)", document.body.style.backgroundRepeat = "no-repeat", document.body.style.backgroundSize = "cover", document.body.style.backgroundPosition = "center", G.BuildEnvironment.RAVEN_DSN && Raven.config(G.BuildEnvironment.RAVEN_DSN).install();
            var a = ["function", "startGame"];
            window[a[1]]()
        }, G.ASSETS = {
            spritesheets: ["board", "BOOT-preloader", "bursteffects", "buttons", "dailyReward", "gems", "leaderboard", "mapsheet", "ssheet"],
            sfx: ["boom.mp3", "sugarcrush.mp3", "sweet.mp3", "tasty.mp3", "delicious.mp3", "divine.mp3", "lvlcompleted.mp3", "lvlfailed.mp3", "booster.mp3", "brick_break.mp3", "cash_register.mp3", "chain_rattle.mp3", "chest_open.mp3", "chest_open_louder.mp3", "clock_tick.mp3", "coin_collect.mp3", "dirt_break.mp3", "exchange.mp3", "explosion_subtle.mp3", "forest_sounds.mp3", "ice_break_0.mp3", "ice_break_1.mp3", "lightning.mp3", "line.mp3", "match_1.mp3", "match_2.mp3", "match_3.mp3", "match_4.mp3", "match_5.mp3", "music.mp3", "pop.mp3", "stone_impact_1.mp3", "stone_impact_2.mp3", "stone_impact_3.mp3", "transition.mp3", "whoosh.mp3", "whoosh_short_1.mp3", "whoosh_short_2.mp3", "xylophone_positive.mp3", "xylophone_positive2.mp3", "xylophone_positive6.mp3", "xylophone_positive_12.mp3"],
            images: ["BOOT-background_1.jpg", "BOOT-logo-ja.png", "BOOT-logo-mini-ja.png", "BOOT-logo-mini.png", "BOOT-logo.png", "Map_background_tileable_0.jpg", "Map_background_tileable_1.jpg", "Map_background_tileable_2.jpg", "Map_background_tileable_3.jpg", "map_margin.png"],
            json: ["json.json", "languages.json", "levels.json", "map.json", "settings.json", "specialCandies.json", "tutorials.json"],
            fonts: {}
        }
    }();</script>
</head>

<body onload="initGame()">
    <div id="focusHelper" style="display: block;"></div>


</body></html>
